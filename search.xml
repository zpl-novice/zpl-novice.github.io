<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux系统编程1</title>
    <url>/2020/06/12/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1/</url>
    <content><![CDATA[<p>摘要：本篇开始将进入Linux系统编程的学习，其中有部分知识是计算机操作系统组成原理，通过对系统编程的学习，能够让我们更加深入的了解Linux。本篇将主要介绍进程相关知识。</p>
<a id="more"></a>
<h2 id="进程相关概念"><a href="#进程相关概念" class="headerlink" title="进程相关概念"></a>进程相关概念</h2><p><strong>首先要明白程序和进程的关系</strong>。<br><strong>程序：编译好的二进制文件，在磁盘上，不占用系统资源（cpu、内存、打开的文件、设备、锁）</strong>。<br><strong>进程：是一个抽象的概念，与操作系统原理联系紧密，进程是活跃的程序，占用系统资源，在内存中执行。（程序运行起来，产生一个进程）</strong>。<br>如果把程序比作剧本，那么进程就是戏，它需要舞台、灯光、演员等条件。这相当于<strong>系统资源</strong>。<br>同一个剧本可以在多个舞台同时上演，同样，<strong>同一个程序可以加载为不同的进程（彼此之间互不影响）</strong>。  </p>
<h2 id="单道程序设计模式"><a href="#单道程序设计模式" class="headerlink" title="单道程序设计模式"></a>单道程序设计模式</h2><p>单道程序设计模式是指cpu同一时刻只能运行一个进程，其他程序只能等该进程结束再运行。<br><img src="https://ae01.alicdn.com/kf/H81a4c0323d4f40fc8dd4e952921fcbfbs.jpg" alt="">    </p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><strong>并发是宏观上的并行运行，是多道程序设计模型。多个进程被分成多个时间片，因为硬件手段的时钟中断，cpu在一个时间片处理一个进程，各进程交替</strong>。<br><img src="https://ae01.alicdn.com/kf/H50d35cb0c09f479392a724848f904dc2R.jpg" alt=""><br><strong>由于cpu处理速度非常快，所以看似多个进程同时在运行。实际上，并发是宏观并行，微观串行。在一个时刻点cpu仍然只有一个进程</strong>。  </p>
<h2 id="cpu和mmu"><a href="#cpu和mmu" class="headerlink" title="cpu和mmu"></a>cpu和mmu</h2><p>中央处理器（cpu）：<br><img src="https://ae01.alicdn.com/kf/H0fa3b2803e004ca080d4b038e1c9a1562.jpg" alt=""><br>内存管理单元（mmu）：<br><img src="https://ae01.alicdn.com/kf/H99c07256267347ec83647f745d5b28a1B.jpg" alt="">  </p>
<h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><p><strong>每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体</strong>。内部有如下部分成员： </p>
<p><strong>进程id</strong>。系统中每个进程都有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。<br><strong>进程的状态</strong>。有初始化、就绪、运行、挂起、停机等状态。<br><strong>进程切换时需要保存和恢复的一些CPU寄存器。<br>描述虚拟地址空间的信息。<br>描述控制终端的信息。<br>当前工作目录。<br>umask掩码</strong>。<br><strong>文件描述符表</strong>。包含很多指向file结构体的指针。<br><strong>和信号相关的信息。<br>用户id和组id。<br>会话和进程组。<br>进程可以使用的资源上限。</strong>  </p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量是指在操作系统中用来指定操作系统运行环境的一些参数，通常具备以下特征：<br>（1）字符串（2）有统一的格式：名=值（：值）（3）值用来描述进程环境信息。<br>存储形式、使用形式、加载位置都与命令行参数类似。<br>使用时需要引入全局环境变量表，<code>extren char **environ</code>。<br>常用环境变量：<br><strong>PATH：可执行文件的搜索路径</strong>。如ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，但我们在执行文件a.out却需要给路径名，这就是因为PATH环境变量的值里包含了ls命令所在的目录。<br><strong>SHELL：当前Shell，通常是/bin/bash</strong>。<br>T<strong>ERM：当前终端类型</strong>，在图形界面终端下它的值通常是xtrem。<br>LANG：语言和locale。<br>HOME：当前用户主目录的路径。<br>环境变量操作函数：<br><strong>getenv函数：获取环境变量值。<br>setenv函数：设置环境变量值。<br>unsetenv函数：删除环境变量值</strong>。  </p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><p><strong>创建子进程：fork函数</strong>。<br><img src="https://ae01.alicdn.com/kf/H0eec814f40884905994497408df16aa8v.jpg" alt="">  </p>
<p><strong>返回值有两个：返回子进程的pid 和 0。（父进程返回的是pid，子进程返回的是0）</strong><br><img src="https://ae01.alicdn.com/kf/H2336834fb4314936949e723ce71782d2N.jpg" alt=""><br>函数调用：<br><img src="https://ae01.alicdn.com/kf/H5a9dcec0126a412bbc6f06b35f4a94d8m.jpg" alt=""><br>创建了一个子进程。结果为：<br><img src="https://ae01.alicdn.com/kf/Hff5d4aa4c0ff44f6aa7873e2894f12dcr.jpg" alt=""><br>可以看到父进程的pid是5331，子进程的pid是5332。<strong>因为有两个进程，所以YYYY被打印了两次</strong>。<br>循环创建N个子进程：<br><strong>不能只使用for循环。因为已经创建过的子进程也会创建新的子进程，使进程数增加。需要在循环里将生成的子进程break，跳出for循环，不再参与下次的循环</strong>。<br><img src="https://ae01.alicdn.com/kf/Hc1f648cc192c4b25a9481df72fa3af71Q.jpg" alt=""><br><strong>如果没有sleep，那父进程和子进程会互相抢占cpu，输出顺序不定。<br>甚至父进程的父进程Shell也会参与进来</strong>。  </p>
<p>在下篇中将会继续介绍进程相关的知识。</p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令8</title>
    <url>/2020/06/09/Linux%E5%91%BD%E4%BB%A48/</url>
    <content><![CDATA[<p>摘要：本篇将介绍剩下的一些系统IO函数以及文件操作函数，在这里只是简单的介绍，了解它们的使用方法，在后续的学习中还会遇到并更深入的介绍。</p>
<a id="more"></a>
<h3 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h3><p>查看read函数的man文档。<br><img src="https://ae01.alicdn.com/kf/Hdd47fd3107354be5b004ec15debbcbdfM.jpg" alt=""><br><strong>返回值：-1表示读文件失败，0表示文件读完，&gt;0表示读取的字节</strong>。<br>查看write函数的man文档。<br><img src="https://ae01.alicdn.com/kf/H4b8c4aa04ff0422d8d7e7296838a35777.jpg" alt=""><br>读写操作：读一个大文件并将其写到另一个文件中。<strong>创建.c文件来实现上述操作</strong>。<br><img src="https://ae01.alicdn.com/kf/H4e75d9db586d4f89be7eb1b82ff18da42.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H3effe84422d24202bfe768ecb1e58401e.jpg" alt="">  </p>
<h3 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h3><p>查看lseek的man文档。lseek用来移动文件指针或获取文件长度、文件拓展。<br><img src="https://ae01.alicdn.com/kf/Ha5ca78c423b4437086462da7213fac7dJ.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/Hbf2ee9aab65d46989d405244908519ecV.jpg" alt="">  </p>
<h2 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h2><p>stat函数：获取文件的信息。<br><img src="https://ae01.alicdn.com/kf/H6f671b71e1ed4cf1bb03f6cb1f93d3a58.jpg" alt=""><br>它的man文档为：<br><img src="https://ae01.alicdn.com/kf/H386354e5e135450ea8560afb2325d758G.jpg" alt=""><br>可以看到，作用跟ls -l命令很像。<br>lstat函数：<br>不穿透符号链接。只能读到链接文件，而不能追踪到映射的文件。<br>access函数：<br>测试指定文件是否拥有某种权限。<br><img src="https://ae01.alicdn.com/kf/He479d7e37b73406f842c903cfbb1cd0cT.jpg" alt=""><br>chmod函数：<br>改变文件权限。<br>chown函数：<br>改变文件所有者。<br>truncate函数：<br><strong>截断文件。如果第二个参数比文件大，则会对文件进行拓展，反之进行截断</strong>。<br><img src="https://ae01.alicdn.com/kf/H2541d289606f49fcb7b9bd1f0d35df86u.jpg" alt=""><br>rename函数：<br>对文件进行重命名。<br>fcntl函数：<br>改变已经打开的文件的属性。  </p>
<p>还有很多的函数，在这里就不一一介绍，我们需要记住一些常见的函数来方便我们对系统进行操作。  </p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令7</title>
    <url>/2020/06/07/Linux%E5%AD%A6%E4%B9%A07/</url>
    <content><![CDATA[<p>摘要：本篇将要介绍makefile文件、虚拟地址空间已经Linux系统IO函数中的open函数，makefile是一个非常重要的代码管理工具，虚拟地址空间在前面也已经有过简单的介绍。</p>
<a id="more"></a>
<h2 id="makefile的编写"><a href="#makefile的编写" class="headerlink" title="makefile的编写"></a>makefile的编写</h2><p><strong>makefile是一个项目的代码管理工具，用来管理源代码。将编译源代码的命令统一写入到makefile中</strong>。<br>创建makefile文件。 <code>vi makefile</code> 或<code>touch makefile</code>。<br>makefile规则中有三要素：目标、依赖、命令。<br><img src="https://ae01.alicdn.com/kf/H4d0d24c7f7d9482c879d017478692ad3i.jpg" alt="">  </p>
<p><img src="https://ae01.alicdn.com/kf/H7eff1c56e07d4013ad94c3a07e094e07F.jpg" alt=""><br>命令make：执行makefile。<br><img src="https://ae01.alicdn.com/kf/H25469836846747acaa3057c15989620bN.jpg" alt=""><br>对makefile进行修改：<br><img src="https://ae01.alicdn.com/kf/H59a8adab967342f681da584ee63a6ab25.jpg" alt=""><br><strong>当有多条规则时，第一条规则里的目标是终极目标，剩下的规则用来生成依赖条件</strong>。<br><img src="https://ae01.alicdn.com/kf/H1fc712e2dc994e7da866b1e2ffeb86aey.jpg" alt=""><br><strong>这样，当有多个文件编译时，若有一些文件修改，makefile只会对修改过的文件进行重新编译，而对没修改过的文件不再编译</strong>。<br>工作原理：<br><strong>比较目标和依赖条件的时间。若目标时间比依赖晚，正常不需更新。若目标时间比依赖早，说明依赖更新过，因此重新编译</strong>。<br>makefile中可以用变量代替复杂的源文件名。<br><img src="https://ae01.alicdn.com/kf/Hd036ca4f75e7488a87c05329db6dc721m.jpg" alt=""><br>模式：  </p>
<pre><code>%.o:%.c    
  g++ -c $&lt; -o $@</code></pre><p>%.o和%.c与终极目标中的.c和.o相匹配。<br><strong>自动变量</strong>：<br>$&lt;：规则中的第一个依赖，<br>$@：规则中的目标，<br>$^：规则中的所有依赖。<br><strong>只能在规则的命令中使用</strong>。<br>makefile也有系统自身维护的一些变量，一般都是大写。<br><strong>makefile中的函数：<br>（1）    获取当前目录下所有的.c文件<br>      <code>src=$(wildcard ./*.c)</code><br>（2）    将.c文件替换成.o文件<br><code>obj=$(patsubst ./%.o, ./%.c,$(src))</code></strong><br>初始化：<br><strong>添加clean命令，声明尾目标</strong>。</p>
<pre><code>.PHONY:clean
clean：
       rm ./*.o app</code></pre><p>先 <code>make clean</code>，再make就可以生成新的app。  </p>
<h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><p>前面讲过每一个运行的程序，系统都会为其分配一个0-4G的虚拟地址空间。<br><img src="https://ae01.alicdn.com/kf/Haca812d55cdc4cf988303ce1095489b7b.jpg" alt=""><br>内核中的进程管理段：<br><img src="https://ae01.alicdn.com/kf/H2e2f18d4840e46618e73b5b04b897f32U.jpg" alt=""><br><strong>在打开文件时都会有一个文件描述符</strong>。  </p>
<h2 id="系统IO函数"><a href="#系统IO函数" class="headerlink" title="系统IO函数"></a>系统IO函数</h2><h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><p>首先查看open函数的man文档，系统函数位于第二章，<code>man 2 open</code>。<br><img src="https://ae01.alicdn.com/kf/Hd104bae8a5474866905059ca251e21e4L.jpg" alt="">  </p>
<p><img src="https://ae01.alicdn.com/kf/H626b9a298d514f9688d79e7109dbda35D.jpg" alt=""><br>可以看到，<strong>open函数返回值是前面所讲的文件描述符，如果出错会返回-1，并且errno也会设置成相应的值。errno是全局变量，不同的值表示不同的错误类型。perror函数能显示错误信息</strong>。<br><img src="https://ae01.alicdn.com/kf/Hf4ea9ddcd33e48eeb85fae32a51562b88.jpg" alt=""><br><strong>在调用系统IO函数时，一定要查看man文档，包含其头文件，按格式调用</strong>。  </p>
<p>在下篇中会介绍剩下的系统IO函数，掌握这些函数是非常有必要的。</p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令6</title>
    <url>/2020/06/05/Linux%E5%91%BD%E4%BB%A46/</url>
    <content><![CDATA[<p>摘要： 本篇将主要介绍gcc的编译、静态库和动态库的制作、gdb的调试等相关的命令，这些都是基础的命令，对于我们在Linux上编程是必须要掌握的。</p>
<a id="more"></a>
<h2 id="gcc的编译过程"><a href="#gcc的编译过程" class="headerlink" title="gcc的编译过程"></a>gcc的编译过程</h2><p><img src="https://ae01.alicdn.com/kf/H0c8088eddacd4fcd9734e277738e0860w.jpg" alt=""><br>安装gcc和g++：<code>yum install gcc</code>，<code>yum install gcc-c++ libstdc++-devel</code>。<br><strong>gcc默认编译c文件，g++编译c++文件</strong>。如将hello.cpp编译，生成.out文件：<br><img src="https://ae01.alicdn.com/kf/H45696bac7c234c04b95d3758383b811bO.jpg" alt=""><br>执行编译好的a.out文件：<br><img src="https://ae01.alicdn.com/kf/Hbf7fed099b974f458807658ca67058329.jpg" alt=""><br>命名选项-o：<code>g++ hello.cpp -o myapp</code>。<br>生成二进制文件来处理而不是可执行文件选项-c：<code>g++ -c hello.cpp</code>。<br><img src="https://ae01.alicdn.com/kf/H78d6ffed6efc45398fe90ef1aebe1fb2g.jpg" alt="">  </p>
<h2 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h2><p>命名：<code>lib+库的名字+.a</code>，如<code>libmytest.a</code>。<br>制作步骤：<strong>生成相应的.o文件，打包</strong>：<code>ar rcs+静态库的名字（libmytest.a）+生成的所有的.o</code>。<br>发布和使用静态库：<strong>只需要给用户头文件和静态库 ，在main函数里直接调用头文件里的接口即可。而不用泄露接口实现源码</strong>。<br>用户操作：<code>g++  main.cpp  ./lib/libmytest.a -I include</code>。<br><img src="https://ae01.alicdn.com/kf/He91195abecc946bab521a353976d696dd.jpg" alt="">  </p>
<h2 id="共享库（动态库）"><a href="#共享库（动态库）" class="headerlink" title="共享库（动态库）"></a>共享库（动态库）</h2><p>命名：<code>lib+库的名字+.so</code>，如<code>libmytest.so</code>。<br>制作步骤：<strong>生成与位置无关的代码(.o)</strong>，<code>g++ -fpic -c hello.cpp -o hello1.o</code>。<br><img src="https://ae01.alicdn.com/kf/H32d5e9c01d934a8893efd7eec84bc7beN.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/Haca812d55cdc4cf988303ce1095489b7b.jpg" alt=""><br>静态库.o文件存放在代码段，位置固定。动态库文件存放在共享库段，位置不定。<br>打包：<code>g++ -shared -o libtest.so hello1.o</code>。<br><img src="https://ae01.alicdn.com/kf/H1aed291328064596ac84299804e76cb5J.jpg" alt=""><br>用户操作：<code>g++ main.c ./lib/libtest.so -o app -I include</code>。<br><img src="https://ae01.alicdn.com/kf/Hea8eb75b26e9404182674469a22ba3632.jpg" alt="">  </p>
<h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p><strong>在编译的时候加上选项-g，包含了调试信息</strong>。<br><img src="https://ae01.alicdn.com/kf/Hd7ec19ec1deb4663ab97ff7ecefc8fc5P.jpg" alt=""><br><strong>可以看到加上-g编译的可执行文件比不加大很多</strong>。<br><strong>开启gdb</strong>： <code>gdb a1.out</code>。<br><img src="https://ae01.alicdn.com/kf/Hd3c3ab915b8743eb8e75f98962166148k.jpg" alt=""><br><strong>l：查看源代码（默认包含main函数的文件）</strong>。<br><img src="https://ae01.alicdn.com/kf/Hf7f5c27808fd493692d6466248d5eb53d.jpg" alt=""><br><strong><code>break 行数</code>：设置断点</strong>。<br><img src="https://ae01.alicdn.com/kf/H084867a3bb2e4f849060b48df10642043.jpg" alt=""><br><strong><code>break 行数 if 条件</code>：设置条件断点</strong>。<br><img src="https://ae01.alicdn.com/kf/Hb90f5afa3e8d4bf2833a627992fefabfw.jpg" alt=""><br><strong>info break：查看断点信息</strong>。<br><img src="https://ae01.alicdn.com/kf/Heca2a4d8e2ef42ceafc4682be553f33eU.jpg" alt=""><br><strong>start: 启动调试程序。c：断点后继续执行</strong>。<br><img src="https://ae01.alicdn.com/kf/Hb5a60fe1cd9e4b53ba306c1582c23762Q.jpg" alt=""><br><strong>p：查看变量值。 p i 、p j：查看当前断点时刻i、j的值。<br>ptype：查看变量类型。<br>display：追踪变量。<br>n：单步调试。</strong><br><img src="https://ae01.alicdn.com/kf/H324748d0354f41f5a48b6afb8f1cd68cI.jpg" alt=""><br><strong>delete 断点编号：删除断点，断点编号在info b里查看</strong>。<br><img src="https://ae01.alicdn.com/kf/H8af2869de7344c6883aa33c9d8af1d039.jpg" alt=""><br><strong>quit：退出gdb</strong>。<br><img src="https://ae01.alicdn.com/kf/Ha8fbe38781f64dc4b9f75e79bb426d75u.jpg" alt="">   </p>
<p>关于gcc和gdb的知识就先讲解到这里，下篇将会介绍makefile文件的编写。</p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令5</title>
    <url>/2020/06/03/Linux%E5%91%BD%E4%BB%A45/</url>
    <content><![CDATA[<p>摘要：本篇将首先介绍剩下的两个服务器的搭建，然后再对vim文本编辑器进行简单的介绍，主要讲解它的三种模式下的各种命令。</p>
<a id="more"></a>
<h2 id="nfs服务器"><a href="#nfs服务器" class="headerlink" title="nfs服务器"></a>nfs服务器</h2><p>需要下载软件: <code>yum install rpcbind nfs-utils -y</code><br>服务器端：<br>创建共享目录 <code>mkdir dir</code><br><img src="https://ae01.alicdn.com/kf/Hb653069e3bdc4bfa96c54c7319101724o.jpg" alt=""><br>   修改配置文件  <code>vi /etc/exports</code><br>   添加共享目录 <code>/home/zpl/nfsshare *(rw,sync)</code>， sync表示实时更新。<br>  重启服务   <code>systemctl restart nfs*</code><br>客户端：<br>使用<strong>挂载</strong>的方式来连接服务器，<code>mount  服务器ip : /home/zpl/nfsshare  /mnt</code>，这样在/mnt目录下就可以查看共享文件夹的内容了。  </p>
<h2 id="ssh服务器"><a href="#ssh服务器" class="headerlink" title="ssh服务器"></a>ssh服务器</h2><p><strong>ssh用来远程登录服务器，并获得相同权限</strong>。<br>安装软件。<code>yum install openssh-server</code><br>远程登录： <code>ssh 用户名@IP</code>，如以zhangsan用户远程登陆zpl用户的服务器。<br><img src="https://ae01.alicdn.com/kf/H950b9f52856c41ecbea802c8f0489b76s.jpg" alt=""><br>退出：<code>logout</code><br><img src="https://ae01.alicdn.com/kf/Hb7983a4e4eb34cfb847db7075c8ca798b.jpg" alt=""><br><strong>scp命令</strong>：super copy 。可实现服务器之间数据的复制。<br><code>scp -r 目标主机名@IP：目录路径 要拷贝到的目录</code>  </p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p><strong>vim是从vi发展过来的一款文本编辑器</strong>。现在虽然输入的是vi，其实调用的是vim。<br>vim共有三种模式。  </p>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>打开文件之后，默认进入命令模式。<br><img src="https://ae01.alicdn.com/kf/Hf0b7b7ad1bcc4f4ea680e496123539a06.jpg" alt=""><br>光标移动：h、j、k、l。<br>行首：0，行尾：$。<br>移动到文本头部：gg，移动到文本尾部：G。<br>行跳转： 行数 G。<br><strong>删除光标所在字符：x，撤销删除：u。</strong><br>删除4行：4dd，<strong>vim的删除并不是真正的删除，而是剪切，可以粘贴出来：p。</strong><br>p表示粘贴到光标下一行，P则是当前行。<br>复制：yy    复制多行：nyy。<br>可视模式：v，可以自由选择，选择完复制：y，选择完删除：d。<br>查找：/内容。向下遍历：n。  </p>
<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><p>需要输入一些命令，切换到编辑模式。<br><strong>a:从光标后面开始插入，A：光标跳到行尾开始插入。</strong><br><img src="https://ae01.alicdn.com/kf/H417cc9f870304bc7aece789637bcfb6aO.jpg" alt=""><br><strong>i:从光标前面开始插入，I：光标跳到行尾开始插入。</strong><br>o:光标所在行下面开辟一个新的行，O：光标所在行上面开辟一个新的行。<br>s:删除光标所在的字符开始插入，S：删除光标所在行开始插入。  </p>
<h3 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h3><p>在末行模式可以输入一些命令。<strong>命令模式输入冒号进入末行模式</strong>。w：保存文件。q：退出。<br><img src="https://ae01.alicdn.com/kf/Hdccc9bb6ee7f4b58981303067e7f0941a.jpg" alt=""><br>sp：水平分屏，vsp：垂直分屏，ctrl+w+w在两个分屏之间切换。<br><img src="https://ae01.alicdn.com/kf/H8457e10a1f7d44608320454bf602b539j.jpg" alt="">  </p>
<p>关于vim的知识就先到这里，在下一篇中会继续介绍。</p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令4</title>
    <url>/2020/06/01/Linux%E5%91%BD%E4%BB%A44/</url>
    <content><![CDATA[<p>摘要：本篇将主要讲解用户管理和服务器搭建的相关命令。我们经常需要添加用户和删除用户，而服务器搭建又分为好几种，本篇将主要讲解ftp服务器的搭建，剩下的两种服务器在下篇中介绍。</p>
<a id="more"></a>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p><strong>useradd命令，添加用户</strong>。<br><img src="https://ae01.alicdn.com/kf/H2c117923c749438a9fa25736272c1378V.jpg" alt=""><br><strong>passwd命令，设置密码。su命令，切换用户</strong>。<br><img src="https://ae01.alicdn.com/kf/Hf94c5ef80b9343e99ba26be76b52807eA.jpg" alt=""><br><strong>userdel命令，选项-r，删除用户和其目录</strong>。<br><img src="https://ae01.alicdn.com/kf/Hc9f18e16fb534c818aded4bcfaf6cc24F.jpg" alt=""><br><strong>vi /etc/passwd命令，查看所有用户</strong>。每一行表示一个用户。<br><img src="https://ae01.alicdn.com/kf/H5c24027651c14f3fb003ed29748a5acfj.jpg" alt=""><br>vi打开文件后，s进行插入，冒号加wq保存退出。  </p>
<h2 id="服务器搭建"><a href="#服务器搭建" class="headerlink" title="服务器搭建"></a>服务器搭建</h2><h3 id="ftp服务器"><a href="#ftp服务器" class="headerlink" title="ftp服务器"></a>ftp服务器</h3><p><strong>ftp负责文件的上传和下载</strong>。<strong>需要安装软件。以vsftpd软件为例</strong>。<br><img src="https://ae01.alicdn.com/kf/H47ec8b83316f4db5941b567596f1a176e.jpg" alt=""><br>在服务器端，需要<strong>修改配置文件</strong>：用vi打开 /etc/vsftpd/vsftpd.conf文件。<br><img src="https://ae01.alicdn.com/kf/H19404f121f8c4930b56aa5a3c2af3f104.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H9313edadcfb04c32ba221dcb749c2a2eZ.jpg" alt=""><br>在修改完配置文件后，需要对服务器进行重启，<code>systemctl restart vsftpd</code><br><img src="https://ae01.alicdn.com/kf/H972279ca14e744c0b57ae698056c29aaM.jpg" alt="">  </p>
<p>在客户端，首先要<strong>安装客户端软件ftp，前面安装的vsftpd是服务器端</strong>。<br><img src="https://ae01.alicdn.com/kf/H48fb2928ec0640e586703d32ae7423a50.jpg" alt=""><br>实名用户登录：命令<code>ftp  服务器IP</code><br>输入服务器的用户名和密码。<br><img src="https://ae01.alicdn.com/kf/Haf842f171307410a928af0e41b8a473dv.jpg" alt="">  </p>
<p><strong>此时已经连接到服务器上</strong>。在登录用户张三下创建了一个haha.txt的文件，将其上传的服务器zpl中。<strong>实名用户可以随意切换目录</strong>。<br><strong>put命令，上传文件</strong>。<br><img src="https://ae01.alicdn.com/kf/Hb5859b73a7154bd5bb1c120491a1fc29i.jpg" alt=""><br><strong>get命令，下载文件</strong>。在服务器zpl建立一个heihei.txt文件，然后下载到zhangsan中。<br><img src="https://ae01.alicdn.com/kf/H168feb90519a423e991dd197f5b0354fY.jpg" alt=""><br>登录zpl用户和张三用户，可以看到上传和下载文件都成功。<br><img src="https://ae01.alicdn.com/kf/H4f7badeaae87461a99cab7735e47238b2.jpg" alt=""><br><strong>ftp服务器只能操作文件，不允许操作目录，因此可以打包 （前面讲的压缩）目录再操作</strong>。<br>匿名用户登录：<strong>实名用户登录会暴露密码，一般都是使用 匿名用户登录</strong>。命令<code>ftp  服务器ip</code><br><strong>输入用户名 anonymous 密码不写</strong>。<br><strong>匿名用户只能在一个指定的目录范围内工作，因此需要在ftp上创建一个匿名用户的目录</strong>。<code>mkdir anonymousftp</code>。<br><img src="https://ae01.alicdn.com/kf/Hc6b6f69ae89e45608a02c88138d90325G.jpg" alt=""><br><strong>在配置文件添加匿名用户根目录</strong>。<br><img src="https://ae01.alicdn.com/kf/Hdaeb403e183b4a738bdb93c72311af83K.jpg" alt=""><br><strong>注意文件的权限，下载文件要求文件对于该用户（其他人）有读权限，上传则是写权限。在服务器端可以修改权限</strong>。<br>lftp客户端访问ftp服务器：    lftp是ftp的一个客户端工具，可以上传和下载目录（不用再压缩）。lftp也需要用yum下载。登录命令 <code>lftp 服务器IP</code>，再输入login 就进入了匿名用户的根目录。<br>put：上传单个文件<br>mput：上传多个文件<br>get：下载单个文件<br>mget：下载多个文件<br>mirror -R ：上传整个目录<br>mirror ：下载整个目录  </p>
<p>关于服务器的命令知识本篇就先讲到这里，下一篇会继续进行讲解。</p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令3</title>
    <url>/2020/05/29/Linux%E5%91%BD%E4%BB%A43/</url>
    <content><![CDATA[<p>摘要：本篇将继续对Linux常见命令进行学习，将主要介绍U盘挂载、压缩包管理、进程管理和网络管理有关的命令。其中对于进程管理只是简单介绍，在后续的学习中会对进程进行更加深入的学习。</p>
<a id="more"></a>
<h2 id="U盘的挂载"><a href="#U盘的挂载" class="headerlink" title="U盘的挂载"></a>U盘的挂载</h2><p>前面已经讲过Linux文件目录，其中/media和/mnt是用来挂载外设的，如U盘、光驱等。当虚拟机全屏时，插入U盘，会自动挂载到/media目录下。如果我们想手动挂载，需要用到的命令为<strong>mount</strong>，而卸载的命令则为unmount。<code>mount 设备名字 要挂载目录</code>，卸载时就不需要设备名字，直接<code>umount 路径</code>。<strong>注意卸载时自己不要在U盘路径中</strong>。因为挂载需要用到设备名字，所以我们需要查看U盘在Linux中的名字，需要用到命令为<code>fdisk -l</code>来获取设备名字。</p>
<h2 id="压缩包管理"><a href="#压缩包管理" class="headerlink" title="压缩包管理"></a>压缩包管理</h2><p><strong>tar命令</strong>，选项：<br>c 创建，即压缩。<br>x 释放，即解压缩。<br>f 指定压缩文件的名字。<br>v 显示提示信息。<br>z 使用gzip的方式压缩文件。<br>j 使用bzip2的方式压缩文件。<br>压缩： <code>tar -zcvf 生成的压缩包名字（xxx.tar.gz）要压缩的文件或目录</code>，例如将hello.c压缩成tar.gz：<br><img src="https://ae01.alicdn.com/kf/Hbbda4f874f0c437ea0dc6e635549299ef.jpg" alt=""><br>解压缩： <code>tar -zxvf 要解压的文件名 -C 指定目录（不加则解压到当前文件夹）</code>，将hello.c删除，然后将上面压缩的tar.gz解压：<br><img src="https://ae01.alicdn.com/kf/Hcac6866ea04f4b8ca71c03e42488d2eft.jpg" alt=""><br><strong>rar命令</strong>，需要安装该软件。选项 a压缩，x 解压。<br><strong>zip命令，需要安装软件</strong>。通过yum安装zip软件。<br>压缩： <code>zip 压缩包的名字 要压缩的文件或目录</code><br>解压缩：<code>unzip 压缩包的名字 -d 解压目录（不指定则解压当前文件夹）</code><br><img src="https://ae01.alicdn.com/kf/H6042f00694584a4fb1bfd9fd20e3a641I.jpg" alt="">  </p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>启动的程序称之为进程。<strong>who命令</strong>，查看当前用户。<br><img src="https://ae01.alicdn.com/kf/H8ec3286e400443a296755273e4a59706V.jpg" alt=""><br>其中tty2表示图形终端。<br><strong>ps命令，查看进程</strong>。选项：<br>-a，显示现行的所有进程，包括其他用户的进程。<br><img src="https://ae01.alicdn.com/kf/H6e8175d287254a88a2d8f047d5a6a7ebs.jpg" alt=""><br>图只截了一部分，可以看到是有非常多的进程的。<br>-u，以用户为主的进程状态。比如当前root用户的：<br><img src="https://ae01.alicdn.com/kf/H0a8c31da4d0643f59aa18eba2c26bb78x.jpg" alt=""><br><strong>pid表示进程的id</strong>。<br>-x，通常与 a 这个参数一起使用，可列出较完整信息。<br><img src="https://ae01.alicdn.com/kf/H5179bf8bb50742c18969f2759628ab98p.jpg" alt=""><br>？表示没有终端。<br><strong>一般直接用-aux，显示出很多信息。但我们需要在这么多进程中找到一个进程时该如何办</strong>？<br><strong>管道（|）相当于重定向。使用管道可以对进程进行过滤。管道将指令1的输出作为指令2的输入，因此我们可以对指令1的结果进行查找</strong> 。<br><code>ps -aux | grep xxx</code>例如查找有bash关键字的进程<br><img src="https://ae01.alicdn.com/kf/Hb600e362b83e47b5adfe3a31d1ccf5adS.jpg" alt=""><br>其中<strong>第三条表示的是grep执行时占用的进程，不是查找的结果</strong>。<br><strong>kill命令可以用来杀死进程</strong>。<br><img src="https://ae01.alicdn.com/kf/Hb4128fede8884714a3001482612eaab8A.jpg" alt=""><br>kill有64个信号，杀死进程使用第9个信号SIGKILL。<code>Kill -SIGKILL 进程ID</code>。<br><strong>env命令，查看当前进程的环境变量</strong>。<br><img src="https://ae01.alicdn.com/kf/H94152aad6f0f472fba3f025178f3789eX.jpg" alt=""> </p>
<p>同样可以使用<strong>管道</strong>可以进行过滤。<br><img src="https://ae01.alicdn.com/kf/H4aa3b68e0bc64d9ba2f27fb168b74b9fX.jpg" alt="">  </p>
<p><strong>ps是显示瞬间进程</strong>的状态，并不动态连续；如果想对进程进行<strong>实时监控应该用top命令</strong>。  </p>
<h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p><strong>ifconfig命令，查看ip地址</strong>。<br><img src="https://ae01.alicdn.com/kf/Hedab32830cfa4293bcf92333dfc28f8av.jpg" alt=""><br>Ens160表示网卡名字。下面192.168.2.2.128则表示ip地址。<br><strong>ping命令</strong>，测试两个地址能不能通信。<br><img src="https://ae01.alicdn.com/kf/H186469deb24c43f9962c98ca53ea4d56K.jpg" alt=""><br><strong>直接ping网站的域名也可以</strong>。如ping百度。<br><img src="https://ae01.alicdn.com/kf/H88fb897ca29144c7a51ef687986e3ec1O.jpg" alt="">  </p>
<p>下一篇将会将用户管理、服务器等相关的命令。</p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Shell命令2</title>
    <url>/2020/05/27/Shell%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<p>摘要：本篇将继续上一篇的学习，对一些常见的命令作出介绍，这些命令在我们以后的Linux学习中是非常常见且有用的。  </p>
<a id="more"></a>
<p>（8） 复制文件或目录<br>cp命令，copy的意思，复制目录需要选项-r，如将桌面文件里的东西复制到temp文件（若没有temp文件将被创建）。<br><img src="https://ae01.alicdn.com/kf/Heb156f57214c4532b82fc315454af513W.jpg" alt="">  </p>
<p>（9） 查看文件内容<br>前面已经介绍过cat命令来查看文件内容，还有more、less、head、tail命令，都可以用来查看。但最常使用的却不是这些，而是后面会学习到的vi命令。<br><img src="https://ae01.alicdn.com/kf/H4f1e43f7a0674c9b9c8a195b27e8213fo.jpg" alt="">  </p>
<p>（10）移动文件或修改文件名<br>mv命令，目录也是相同指令。<br><img src="https://ae01.alicdn.com/kf/Hef5bcf8d3f5f44d7acb8705151adc63fl.jpg" alt="">  </p>
<p><img src="https://ae01.alicdn.com/kf/H2fb27cbc1f1244d4a8b589462a9e7abcC.jpg" alt="">  </p>
<p>（11）创建软链接（快捷方式）<br>ln命令，<strong>需要选项-s</strong>，为了全局使用，需要<strong>绝对路径</strong>，即若为hello.c创建快捷方式<br><img src="https://ae01.alicdn.com/kf/H11d32d28b9664cbab48066d32e8c2cecY.jpg" alt="">  </p>
<p>（12）创建硬链接（另一个入口）<br>同样是ln命令，<strong>不需要选项-s</strong>，<strong>硬链接与软链接的区别在于软链接相当于快捷方式，硬链接相当于智能指针。硬链接可以有多个，而且不需要绝对路径</strong>。<br><img src="https://ae01.alicdn.com/kf/H2f1301d9257347eda50833018387adbfL.jpg" alt="">  </p>
<p>（13）获取文本文件的属性（行数，单词数）<br>wc命令查看普通文件，od命令查看二进制文件。<br><img src="https://ae01.alicdn.com/kf/Hb90128630db24e3f83c385acbcbe3ecaI.jpg" alt="">  </p>
<p>（14）查看命令所用解释器<br>which命令，如查看cp命令和cd命令：<br><img src="https://ae01.alicdn.com/kf/H746f89b0345b4a8888e73dfaf1020c8es.jpg" alt="">  </p>
<p>（15）修改文件权限<br>什么是文件权限，即读r、写w、执行x。在上一篇ls -l查找中有：<br><img src="https://shop.io.mi-img.com/app/shop/img?id=shop_b349f981e1b78d214fa8118d1aec70f3.png" alt=""><br><strong>d表示文件类型，d后前3个字符表示文件所有者权限，中间3个表示文件所属组（组内其他成员）权限，后3个字符表示其他人权限</strong>。2表示硬链接数，后面就是所有者和所属组名字，内存和时间。<br>当修改文件权限时，文字设定法，<strong>chmod命令</strong>，change mod的意思，chmod [who] [+|-|=] [mod]<br>其中who： 文件所有者u，文件所属组g，其他人o，所有的人a。+：添加权限，-：减少权限，=：覆盖原本权限。mod：读r，写w，执行x。<br><img src="https://ae01.alicdn.com/kf/Hb82636e93fa54300a05646d0f8c2e1c9o.jpg" alt=""></p>
<p>数字设定法：-：没有权限。4：读r。1：执行x。2：写w。所以7就是满权限，7：rwx文件所有者，6：rw文件所属组，5：rx其他人。chmod 777 hello  使hello满权限。  </p>
<p>（16）修改文件所有者和所属组<br><strong>文件属于所有者，但不一定属于所有者所在的组，而可能属于其他的组</strong>。因此文件所有者和文件所属组不一定有关系。chown命令。<strong>目录必须拥有执行权限，只有这样，才能进入目录</strong>。   </p>
<p>（17）文件的查找<br>find命令，按文件名查找，选项为查找目录-name，即find -name “文件名”<br><img src="https://ae01.alicdn.com/kf/H6ca487b424044fc78100a150ebe80036m.jpg" alt=""><br>若不知文件全名，加*<br><img src="https://ae01.alicdn.com/kf/Hfac3e4e133234a2e9be7d33e799f821bU.jpg" alt=""><br>按文件大小查找，选项为查找目录-size  </p>
<p>（18）文件的检索<br><strong>grep命令</strong>，对文件的内容进行查找，选项-r “查找的内容“ 查找的目录<br><img src="https://ae01.alicdn.com/kf/H63ce2007e5d04e62a9baa0807b59a7ddM.jpg" alt="">  </p>
<p>软件的安装，分为在线安装，deb包安装和源码安装。<strong>Redhat的在线安装命令为yum</strong>，如前面的安装tree软件。<br><img src="https://ae01.alicdn.com/kf/H9ffbfb8b78974a00a73c556137ccf3ceO.jpg" alt="">  </p>
<p>本篇就先讲解到这里，剩下的知识会在下面慢慢介绍。</p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Shell命令1</title>
    <url>/2020/05/25/Shell%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>摘要：本篇将介绍Linux中的Shell，Shell是一个命令解释器，它可以对我们给出的命令进行解析，若正确则执行相应的操作。并会介绍一些常用的命令。</p>
<a id="more"></a>
<p><strong>Shell是Linux的一个特殊程序，是内核与用户的接口，它是命令语言、命令解释程序及程序设计语言的统称</strong>。Shell是一个命令语言解释器，它拥有自己内建的Shell命令集，Shell也能被系统中其他应用程序所调用。<br><strong>当用户成功登录Linux系统后，即开始了与Shell的对话交互过程</strong>，此时，不论何时键入一个命令，都被Shell解释执行。<br>用户—shell—Kernel（内核）—硬件。 </p>
<p>终端是来使用shell解释器的，<strong>Linux在控制台上虚拟了6个字符终端和一个图形终端，图形化界面中的终端程序就是图形终端</strong>。<strong>为什么有这么多的终端且互不影响？这是为了满足Linux多用户多任务的功能</strong>。用户可以使用不同的终端，一个用户也可以切换多个终端来使用。<br>在Linux终端中，主提示符为：[登录用户@主机名 工作目录]。辅助提示符：root用户登录后 提示符为“#”，普通用户登录后 提示符为“$”，使用su - root命令可以切换到root用户，su - zpl命令切换到普通用户。<br><img src="https://ae01.alicdn.com/kf/H907e61ced359486c9cf9107b0faf46cbg.jpg" alt=""><br>Linux命令行格式：命令字 [选项][参数]。其中选项用于调节命令的具体功能：<br>以-引导短格式选项，单个字符，如-l<br>以–引导长格式选项，多个字符，如–color<br>多个短格式选项可以写在一起，只用一个-引导，如-al  </p>
<p>参数是命令操作的对象，如文件、目录名等。举例，<strong>查看命令ls用来显示文件和目录列表</strong>。用选项-l来显示具体信息。<br><img src="https://ae01.alicdn.com/kf/H38dc764e17964374818ede5e643e6548r.jpg" alt=""><br>而-a、–all选项则是显示全部文件，包括隐藏文件。<br><img src="https://ae01.alicdn.com/kf/H86cde36f72ee4f23b8e89065cf080315s.jpg" alt=""><br>命令行是有快捷键的，如Tab可以自动补齐，反斜杠\用来强制换行，ctrl+a 跳至行首，ctrl+e跳至行尾，ctrl+l清屏等等，方便我们的操作。<br>因为Linux的命令非常多，当遇到我们不清楚具体作用的命令时，可以查看该命令的帮助，–help选项用来查看该命令的选项及作用或者用man命令，如ls –help 或 man ls。<br>再举例一个命令如cat，它可以查看文本文件的内容，如cat /etc/shells  查看系统中的所有shell解释器。<br><img src="https://ae01.alicdn.com/kf/H99895e757b304d5caf120824b4d8ce2am.jpg" alt=""><br>也可以查看此时我们使用的是哪个Shell解释器，一般情况下都为bin中的bash，也可以自己切换Shell解释器。<br>在Linux中有着许多的Shell命令，这对于Linux的使用是非常重要的，随着我们的学习，也会见到更多的命令，了解它们的作用。这里将主要介绍一些常用的命令：<br>（1） 查看所有目录<br>tree命令或者ls命令，注意若使用tree命令需提前安装tree软件。如何安装软件会在后面介绍。<br><img src="https://ae01.alicdn.com/kf/Hda1f3e9d3699472cb2be5d9ddd82b3161.jpg" alt="">  </p>
<p>（2） 进入目录<br>这个是非常常用的命令，cd命令。如进入dev文件，cd /dev<br><img src="https://ae01.alicdn.com/kf/Hd895f28044f14c629aebef1b4128cac01.jpg" alt="">  </p>
<p>（3） 查看当前所在目录<br>pwd命令。<br><img src="https://ae01.alicdn.com/kf/Hbec44d3f7f114c768bb22807fc0429ba0.jpg" alt=""> </p>
<p>（4） 创建目录<br>mkdir命令   dir是目录的意思，如在桌面创建一个Mytest目录<br><img src="https://ae01.alicdn.com/kf/H3c616550d3dc4a1bbebdcf3dd0c21b2en.jpg" alt=""><br>这样，打开桌面文件夹后，就会有一个Mytest文件夹被创建出来。<br><img src="https://ae01.alicdn.com/kf/Haa95e49e6bc14aa5aed67ee980d699f5Z.jpg" alt=""> </p>
<p>（5） 删除目录<br>rm命令  同时<strong>要加-r选项</strong>，意思是递归删除，它直接删除目录，如删掉Mytest目录<br><img src="https://ae01.alicdn.com/kf/H042c4fab27d44e4e985ee79c5b8c8c64k.jpg" alt=""> </p>
<p>（6） 创建文件<br>注意上面是创建目录，这里是创建文件，<strong>touch命令</strong>，如创建一个hello.c文件<br><img src="https://ae01.alicdn.com/kf/Hb2e330d646f645d3929ad4e9d9aefbe22.jpg" alt="">  </p>
<p>（7） 删除文件<br>还是rm指令  <strong>删除文件时不需要添加选项</strong>，如删除hello.c<br><img src="https://ae01.alicdn.com/kf/He6b2858229734c8cb06a56b58ca32229P.jpg" alt="">  </p>
<p>剩下的命令将在下一篇中继续介绍。  </p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>Linux介绍</title>
    <url>/2020/05/22/Linux%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>摘要：本篇将进入Linux操作系统的学习，在开始之际，先对Linux做一个简单的介绍，它是如何产生的？Linux有哪些分类？以及Linux的优缺点。</p>
<a id="more"></a>
<p>在介绍Linux之前，需要先来介绍一下Unix。</p>
<h2 id="Unix"><a href="#Unix" class="headerlink" title="Unix"></a>Unix</h2><p>Unix是1969年汤普森在贝尔实验室开发出的系统原型，由汇编编写而成。在1973年经C语言改写，方便移植，因为Unix的好用性并且开源，很为学生和教授喜欢。但是贝尔实验室属于AT&amp;T公司，AT&amp;T公司为了盈利，在1979年收回版权，不对学生开源。<br>斯蒂曼原本是一个黑客，他为了解决Unix问题，不受专利软件的限制，提出了GNU，<strong>GNU is Not Unix的递归缩写，由斯蒂曼在1984年发起，旨在构建一个自由、开放的操作系统</strong>。<br>斯蒂曼重新开发<strong>自由</strong>的工具软件并推广。开发<strong>GCC</strong>（<strong>GNU的C语言编译器</strong>，如今仍在使用）等其他基础的软件便于自由软件的发展。同时他<strong>开放这些软件的源代码</strong>，允许复制、修改、传播。为了防止自由软件被其他人做成专利软件，制定<strong>GPL授权</strong>。GPL：通用公共许可证。与专利软件的授权截然相反，允许自由使用。<br><strong>但当时并没有设计出GNU操作系统的内核，只有自由软件，仍然在Unix上运行</strong>。  </p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>1991年，芬兰大学生图瓦达开发出<strong>基于x86系统的Linux内核</strong>，经过虚拟团队的维护逐渐发展壮大并被移植到其他的硬件系统上。因此出现了Linux这一操作系统。<br>由于<strong>Linux是一个自由软件，具有GPL授权</strong>，因为有许多种不同的版本。下面介绍其主要的3个版本：<br>1.Ubuntu，2004年9月发布，最为流行的 <strong>桌面</strong> Linux发行版。对于个人用户较为合适。<br>2.RedHat，<strong>使用最广，性能最稳</strong>。<br>3.CentOS，2003年底推出，rhel的重新编译版，免费。<br>Linux的优点有：<br>1.性能稳定<br>2.较高的安全性和Bug的快速修复<br>3.支持多用户多任务<br>4.完善的用户和群组策略<br>5.资源耗费低<br>6.适合嵌入式应用<br>7.免费或费用低廉<br>缺点有：<br>1.专业软件支持不够，不像windows有丰富的软件。<br>2.厂商支持度不够，因为有多种版本，且非盈利。<br>3.标准化不足  </p>
<p>本次的学习将主要通过VMware软件建立虚拟机，然后在虚拟机上装Linux系统来进行对Linux的学习。下图为Linux的目录树结构：<br><img src="https://ae01.alicdn.com/kf/H688517caeb33446e96f6ee6518ef93d9R.jpg" alt=""><br>根目录root用/表示，Linux中所有东西以文件形式存在。/home/oracle/bin/..<br>下面介绍一下一些主要目录：<br>/bin：bin是binary的缩写，这个目录存放着最经常使用的命令。<br>/boot：存放的是启动Linux时使用的一些核心文件，包括一些连接文件和镜像文件。最好不要对其进行改动。<br>/dev：dev是设备device的缩写，存放Linux的外部设备。一切皆文件。<br>/etc：这个目录用来存放所有的系统管理所需要的配置文件和子目录。在后续对配置文件修改时会经常用到。<br>/home：存放所有用户的子目录（不包括root）。<br>/lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于windows里的dll文件，几乎所有的程序都需要用到这些文件。<br>/media和/mnt：挂载外设的，如U盘、光驱等。<br>/root：系统管理员，超级用户的主目录。<br>/usr：这是一个非常重要的目录，user software resource，用户软件资源，用户的很多应用程序和文件都在这个目录下。  </p>
<p>在装Linux系统时需要进行磁盘分区，如同windows中的C盘、D盘等。那么怎么把Linux中的文件与磁盘相对应呢？即将文件系统和目录挂载到磁盘上。<strong>Windows中每一个磁盘分区，如C盘就相当于一个根目录，而Linux只有一个根目录</strong>。  </p>
<p><img src="https://ae01.alicdn.com/kf/H507ecda6affd4e5dad3fefd09ca76794U.jpg" alt="">  </p>
<p><strong>将某一个文件挂载到一个磁盘或分区上，该文件为挂载点</strong>。则该文件的子文件就在该分区内。根目录必须要挂载到一个磁盘或分区上。这样，就有可能<strong>一个目录下的子目录可能保存在不同的分区或磁盘</strong>上。  </p>
]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
  </entry>
  <entry>
    <title>k-d树和配对堆</title>
    <url>/2020/05/13/k-d%E6%A0%91%E5%92%8C%E9%85%8D%E5%AF%B9%E5%A0%86/</url>
    <content><![CDATA[<p>摘要： 本篇将要讲解最后两种数据结构k-d树和配对堆。k-d树是多维查找树，而配对堆则是优先队列的利器，它们有特用的适合场景，并且更加高效。</p>
<a id="more"></a>
<h2 id="k-d树"><a href="#k-d树" class="headerlink" title="k-d树"></a>k-d树</h2><p>设一个广告公司要发邮件给那些年龄34到49之间且年收入在10w到15w之间的人们。这个问题叫作二维范围查询。在一维情况下，可以通过递归遍历二叉查找树解决，我们希望对二维或更高维有同样的界。<br><strong>二维查找树（2-d树）具有简单的性质：在奇数层上按照第一个关键字进行分支，而在偶数层上的分支按照第二个关键字进行。根是任意选取的，位于奇数层</strong>。示例如下：<br><img src="https://ae01.alicdn.com/kf/Hf6615a45deeb4bbcb648bb7924d3811aB.jpg" alt=""><br><strong>第一层根结点处：以第一个关键字53分支子树</strong>，可见左子树中所有结点的第一个关键字都比53小，右子树中所有结点的第一个关键字都比53大。<br><strong>第二层左子树根结点处：以第二个关键字28分支</strong>，可见其左子树中所有结点的第二个关键字都比28小，右子树中所有结点的第二个关键字都比28大。第二层右子树根结点同理。<br><strong>第三层又变为第一个关键字分支下去</strong>…<br><strong>相当于有两个维度x,y，在这两个维度中独立的对结点进行排序</strong>。一棵随机构造的2-d树与一棵随机二叉查找树具有相同的结构性质：高度平均为O(logn)，但最坏情形是O(n)。  </p>
<h2 id="配对堆"><a href="#配对堆" class="headerlink" title="配对堆"></a>配对堆</h2><p>优先队列三大利器：二项堆、斐波那契堆、配对堆。<br>二项树B0是一棵单结点树，且对于k&gt;0，二项树Bk通过将两棵二项树Bk-1合并在一起而得到。二项树B0到B4如图所示：<br><img src="https://ae01.alicdn.com/kf/H44030d861ee54c33b8d4739cf2d2d9786.jpg" alt=""><br><strong>二项堆是二项树的集合。时间复杂度为O(logn)</strong>。  </p>
<p><strong>斐波那契堆是一种松散的二项堆</strong>，与二项堆的主要区别在于构成斐波那契堆的树可以不是二项树，并且这些树的根排列是无序的（二项堆的根结点排序是按照结点个数排序的，不是按照根结点的大小）。<strong>斐波那契堆得优势在于它对建堆、插入、抽取最小关键字、联合等操作能在O(1)的摊还时间内完成（不涉及删除元素的操作仅需要O(1)，删除需要O(logn)的摊还时间）。这是对二项堆效率的巨大改善。</strong>但由于斐波那契堆的常数因子以及程序设计上的复杂度，使它不如通常的二叉堆合适。因此，它的价值仅存在于理论意义上。<br><img src="https://ae01.alicdn.com/kf/H7b58923badc6469181238b2228d8268fc.jpg" alt=""><br>可以看到<strong>根排列无序，且树也是无序的（只满足堆的性质）</strong>。 </p>
<p><strong>插入一个节点到堆中，直接将该节点插入到”根链表的min节点”之前即可；若被插入节点比”min节点”小，则更新”min节点”为被插入节点。根结点的链表是一个双向链表，min结点7看作表头，插入结点放到7前面，也相当于最后，若比7小，替换7</strong>。    </p>
<p><img src="https://ae01.alicdn.com/kf/H61a5057227044923bb665898537cedaae.jpg" alt=""><br>斐波那契堆是可合并堆，合并操作与插入操作相同，将一个堆的根链表插入到另一个堆的根链表上即可。简单来说，就是将两个双链表拼接成一个双向链表。  </p>
<p>斐<strong>波那契堆主要有两个缺点：编程实现难度较大和实际效率没有理论的那么快（由于它的存储结构和四个指针）。配对堆弥补这两个缺点</strong>。<br>配对堆实际上是一棵具有堆性质的多叉树。属于可并堆，因<strong>此对于集合合并维护最值的问题很实用</strong>。<br><img src="https://ae01.alicdn.com/kf/H6502c72ed1c049f8bf38f9ab324d7cee7.jpg" alt=""><br>抽象表示如上所示。具体表示则如下，用的是儿子兄弟表示法：<br><img src="https://ae01.alicdn.com/kf/Hb79690bae4b34e61959fceac475ad1ccp.jpg" alt=""><br>插入、合并操作：<br><img src="https://ae01.alicdn.com/kf/H0cef5bc78d2048b6a4f278b896f71c87A.jpg" alt=""><br><strong>这里以大顶堆为例，将根较小的堆变成根较大的堆的左孩子</strong>。<br><img src="https://ae01.alicdn.com/kf/H4e5d99773e5c4d30ad3ca0f869208fb1b.jpg" alt=""><br><strong>配对堆继承了斐波拉契堆的优秀操作复杂度,同时相比之下降低了空间复杂度和代码复杂度</strong>。</p>
<p>关于数据结构与算法的学习就先到这里，在后续的学习中会不断的对其进行补充和修正。  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>字典树和后缀树</title>
    <url>/2020/05/05/%E5%AD%97%E5%85%B8%E6%A0%91%E5%92%8C%E5%90%8E%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<p>摘要：本篇将要讲解的知识为字典树(trie tree)和后缀树(suffix tree)，用于数据处理当中能够提高效率，字典树(trie tree)经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p>
<a id="more"></a>
<p>数据处理中最基本的问题之一是找出模式（pattern）P在文本T中的位置。P的大小通常要显著的小于T，我们的兴趣是在常见的问题上，其中T是固定的，而对于不同的P的查询是经常发生的。在这种情况下，<strong>我们愿意把T预处理成理想的形式，使得每一次的搜索更加高效，花费的时间显著小于T大小的线性量—或者是T大小的对数，或者甚至更好，与T无关而只依赖于P的长度</strong>。  </p>
<h2 id="trie-tree"><a href="#trie-tree" class="headerlink" title="trie tree"></a>trie tree</h2><p>字典树（trie tree）具有下列性质：<br>1.根结点不包含字符，除根结点外每一个结点都只包含一个字符。<br>2.从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串。<br>3.每个节点的所有子结点包含的字符都不相同。<br>trie tree示例如下，在这个trie结构里，保存了to，tea，ted，ten，A，i，in，inn这8个字符串，仅占用8个字节。<br><img src="https://ae01.alicdn.com/kf/H89d8c6365b1c4283b9c841b1dad6a3e9c.jpg" alt=""><br>可以看出，<strong>trie tree充分利用字符串与字符串间拥有公共前缀的特性，而这种特性在字符串的检索与词频统计中会发挥重要的作用</strong>。 <strong>拿空间换时间</strong>。<br>给定多个字符串，如 {banana,band,apple,apt,bbc,app,ba}，那么所构建的一棵TrieTree形状如下：<br><img src="https://ae01.alicdn.com/kf/Hdbabd91b21594d929c5d8b7f9f5cec28M.jpg" alt=""><br><strong>黄色的节点代表从根节点通往该节点的路径上所经过的节点的字符构成的一个字符串出现在原来的输入文本中</strong>，如以d为例，路径上的字符为：b-a-n-d，对应输入的字符串集合中的”band”。<strong>Trie树可以很方便的扩展，当来了新的字符串时，只要把新的字符串按照原本的规则插入到原来的树中</strong>，便可以得到新的树。<strong>当前的节点并不是黄色的，说明了“从根节点到该节点的路径形成的字符串没有出现在原来的字符串集合中，但该字符串是原字符串集合中某个(些)单词的前缀</strong>。  </p>
<h2 id="suffix-tree"><a href="#suffix-tree" class="headerlink" title="suffix tree"></a>suffix tree</h2><p>后缀树的想法就是把后缀都存储在一棵trie树中。例如bananas字符串的后缀trie树为：<br><img src="https://ae01.alicdn.com/kf/H2dda57ab8b2c4653979d9eca61d60759u.jpg" alt=""><br><strong>可以看到里面有许多只有一个子结点的结点，这会明显的浪费空间，因此需要对trie树进行压缩，变成压缩trie树。把单分支结点压缩成一个结点，这样得到的树称为后缀树（suffix tree）</strong>。<br><img src="https://ae01.alicdn.com/kf/H2bee9ae0e94742b58b9fd5c7b0ab6cf59.jpg" alt=""><br>合并后的bananas的标准后缀树为：<br><img src="https://ae01.alicdn.com/kf/Hf44502761f0d488cb234029f17bf871fP.jpg" alt=""><br>可以得到它的性质（<strong>除了trie树的性质以外</strong>）：<br>1.从根到树叶的路径与后缀一一对应，且每条路径唯一代表了字符串的一个后缀。<br>2.所有内部结点（除根结点外）都有至少两个子结点（<strong>单子结点被压缩</strong>）。<br>用后缀树可以查找字符串o是否在字符串S中，用S构造后缀树，<strong>若o在S中，则o必然是S的某个后缀的前缀</strong>。因此用trie树搜索的方式找到o即可。  </p>
<p>本篇对于字典树和后缀树的知识就讲解到这里，在后面的学习中可能还会遇到相关的问题，到时候再进一步深入学习。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>treap树</title>
    <url>/2020/05/03/treap%E6%A0%91/</url>
    <content><![CDATA[<p>摘要：本篇要讲解的数据结构是treap树，它可能是我们讲的最简单的一种类型的二叉查找树。它像跳跃表一样使用随机数，并且对任意的输入给出的是O(logn)<strong>期望时间</strong>的性能。<strong>查找时间等同于非平衡二叉查找树（从而比平衡二叉树要慢），插入的实现稍慢，删除则慢的多，但仍满足O(logn)的期望时间</strong>。  </p>
<a id="more"></a>
<p>treap是tree 和 heap组合的结构。treap树中每个结点存储一项，一个左指针和一个右指针，以及一个优先级，这个<strong>优先级是建立结点时随机指定的</strong>。一个treap树就是一个二叉查找树，但其<strong>结点优先级满足堆序性质：任意结点的优先级必须至少和它父结点的优先级一样大</strong>。<br>查找时与普通的二叉查找树相同。<br>插入时：先按二叉查找树找到插入的位置，插入数据并生成随机值，因为插入的都是叶结点，所以影响到堆性质的为插入结点和它的父结点。<strong>若插入结点的优先级比父结点小，旋转操作使其满足性质</strong>。<br>示例如下：<br><img src="https://ae01.alicdn.com/kf/H12155f92ea364e3fb20ebbb9db1b7dd7d.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/Hf06cbbfca9a8494b851fbf6f6435b80ap.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/Ha36bd71a7b4940ff98e2f734e3725c58B.jpg" alt=""><br>删除时分为两种情况：<br>1.有两个孩子<br>2.只有一个孩子或无孩子<br>第二种情况无孩子直接删除，有一个孩子就用孩子代替该结点然后删除。第一种情况，<strong>旋转使其变成第二种情况。如果该结点的左孩子优先级比右孩子优先级小，右旋。否则左旋，重复下去直至变为第二种情况</strong>。示例如下：<br><img src="https://ae01.alicdn.com/kf/H484f36155dc24406b77d69181c2b8229w.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H8033a39780c14dad90bfc1bb0983a6a94.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H2fc8fbe98072437995213900162664100.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H56f347a6d7814715b296f3ef32f447a04.jpg" alt=""><br>具体代码实现如下：  </p>
<pre><code>typedef struct node                     
{
    int data;
    node* lchild;
    node* rchild;
    int priority;    
}node,*Node;
 class treap
 {
     private:
         Node root;
         int searchtreap(Node &amp;T,int key);
         int inserttreap(Node &amp;T,int key);
         void delete1(Node &amp;T,int key);
         void delete2(Node &amp;T);
         Node leftrotate(Node &amp;T);
         Node rightrotate(Node &amp;T);
         void preorder(Node T);
     public:
         treap()
         {
             root=NULL;
         }
         void search(int key)
         {
             searchtreap(root,key);
        }
         void insert(int key)
         {
             inserttreap(root,key);
         }
        void deletetreap(int key)
        {
            delete1(root,key);
        }
        void preord()                 //前序遍历 
        {
            preorder(root);    
        }
 };    
 int treap::searchtreap(Node &amp;T,int key)                          
 {
     if(T!=NULL)
     {
         if(T-&gt;data==key)
         {
             cout&lt;&lt;&quot;find &quot;&lt;&lt;key&lt;&lt;endl;
        }
        else if(key&lt;T-&gt;data)
        {
             searchtreap(T-&gt;lchild,key);
        }
        else if(key&gt;T-&gt;data)
        {
            searchtreap(T-&gt;rchild,key);
        }
    }
    else
        cout&lt;&lt;&quot;can&apos;t find &quot;&lt;&lt;key&lt;&lt;endl;
    return 0;
 }
 void treap::delete2(Node &amp;T)                                    
{
    Node q;
    if(T-&gt;rchild==NULL)
    {
        q=T;
        T=T-&gt;lchild;
        delete q; 
    }
    if(T-&gt;lchild==NULL)
    {
        q=T;
        T=T-&gt;rchild;
        delete q; 
    }
    else                               //既有左孩子又有右孩子 
    {
        if(T-&gt;lchild-&gt;priority&gt;T-&gt;rchild-&gt;priority)
        {
            leftrotate(T);
            delete2(T);
        }
        else
        {
            rightrotate(T);
            delete2(T);
        }
    }
}
int treap::inserttreap(Node &amp;T,int key)         
{
    if(T==NULL)
    {
        Node p;
        p=new node;
        p-&gt;data=key;
        p-&gt;lchild=p-&gt;rchild=NULL;
        p-&gt;priority=rand()%500;
        T=p;
        return 1;
    }
    else if(key&lt;T-&gt;data)
    {
        inserttreap(T-&gt;lchild,key);
        if(T-&gt;priority&gt;T-&gt;lchild-&gt;priority)
        {
            T=rightrotate(T);
        }
    }
    else 
    {
        inserttreap(T-&gt;rchild,key);
        if(T-&gt;priority&gt;T-&gt;lchild-&gt;priority)
        {
            T=leftrotate(T);
        }
    }
    return 0;
}
void treap::delete1(Node &amp;T,int key)
{
    if(T!=NULL)
    {
        if(T-&gt;data==key)
        {
            delete2(T);
        }
        else if(key&lt;T-&gt;data)
        {
            delete1(T-&gt;lchild,key);
        }
        else if(key&gt;T-&gt;data)
        {
            delete1(T-&gt;rchild,key);
        }
    }
    else
        cout&lt;&lt;&quot;can&apos;t find and delete &quot;&lt;&lt;key&lt;&lt;endl;
}
Node treap::leftrotate(Node &amp;T)
{
    Node tem;
    tem=T-&gt;rchild;
    T-&gt;rchild=tem-&gt;lchild;
    tem-&gt;lchild=T;
    return tem;
}
Node treap::rightrotate(Node &amp;T)
{
    Node tem;
    tem=T-&gt;lchild;
    T-&gt;lchild=tem-&gt;rchild;
    tem-&gt;rchild=T;
    return tem;
}
void treap::preorder(Node T)
{
    if(T!=NULL)
    {
        cout&lt;&lt;&quot;关键字：&quot;&lt;&lt;T-&gt;data&lt;&lt;&quot; 随机值&quot;&lt;&lt;T-&gt;priority&lt;&lt;endl;
        preorder(T-&gt;lchild);
        preorder(T-&gt;rchild);
    }
}
int main()
{
    treap t;
    srand(0);
    t.insert(5);
    t.insert(3);
    t.insert(15);
    t.insert(2);
    t.insert(4);
    t.preord();
    t.search(5);
    t.search(3);
    t.search(21);
    return 0;
}</code></pre><p>本篇主要讲解了treap树的有关知识，它将二叉查找树和堆结合起来，并通过随机选取优先级的方式获得了不错的期望时间，能够满足在O(logn)期望时间内完成各种操作，且实现相对平衡二叉树简单，因此是一种很好的数据结构。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/05/01/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>摘要：本篇将要学习的数据结构是红黑树。红黑树一种AVL树的变体，它具有良好的性能，能够以花费O(logn)最坏运行时间来完成树的操作。甚至比AVL更快，因此是一种流行的选择。本篇将主要介绍红黑树的概念，以及它是怎么调整来实现各种操作的。</p>
<a id="more"></a>
<p><strong>从历史上看，对AVL树另一种流行的选择是红黑树。对红黑树的操作在最坏情形下花费O(logn)时间。而且，对于插入操作的非递归实现与AVL相比更容易完成</strong>。<br>为什么要叫红黑树(red black tree)呢？因为对于每个结点都着色成黑色或红色。红黑树是具有以下着色性质的<strong>二叉查找树</strong>：<br>1.每一个结点或者着成红色，或者着成黑色。<br>2.根是黑色的。<br>3.<strong>所有的叶子结点是黑色的（注意叶子结点为null）</strong>。<br>4.如果一个结点是红色的，那么它的子结点必须是黑色的。<br>5.从一个结点到一个null指针的每一条路径必须包含相同数目的黑色结点。<br>着色法则的一个结论是，<strong>红黑树的高最多是2log(n+1)</strong>。性质5中，确保没有一条路径会比其他路径长出俩倍。因而，<strong>红黑树是相对是接近平衡的二叉树</strong>。<br><img src="https://ae01.alicdn.com/kf/Hba2f521254f74fe1b95697a0ff01e50dF.jpg" alt=""><br><strong>红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但对之进行平衡的代价较低， 其平均统计性能要强于 AVL</strong>。  </p>
<p>红黑树的查找就是按照二叉查找树的方法，只不过多了个颜色。<strong>困难在于将一个新项插入到树中</strong>，<strong>若将其涂成黑色，显然就违反了性质5，因为该项的子结点为两个黑色的null指针。这样插入后路径上黑色数目就加1。因此，插入的新项必须涂成红色</strong>。 如果它的父结点是黑色的，则插入完成，若它的父结点为红色，则又违背了性质4，在这种情况下，我们必须调整树使其满足性质4而又不违背性质5，基本操作为颜色的改变和树的旋转。<br>插入操作的调整：<br>1.父结点黑色，该项涂成红色，插入完成。<br>2.父结点红色<br>（1）父结点的兄弟是黑色，一字形和之字形变换<br><img src="https://ae01.alicdn.com/kf/Hcd07f775514c47419f1a9c0d7b0d9e9cl.jpg" alt="">  </p>
<p>一字形：<strong>一次对祖父结点的右旋转</strong>。<strong>旋转后，P变为子树的根结点，G变为P的孩子，为了满足性质，需要将P变为黑色，G变为红色</strong>。<br><img src="https://ae01.alicdn.com/kf/Hef825d9b2fbf47bdbd068fe90fdb897cv.jpg" alt=""><br>之字形：<strong>一次对父结点的左旋转再一次对祖父结点的右旋转。这种情况下插入的新项变为子树的根，而其原本的父结点和祖父结点变为其孩子。为了满足性质将该新项变为黑色，祖父结点变为红色</strong>。  </p>
<p>（2）父结点的兄弟是红色<br>这时候父结点以及父结点的兄弟都为红色，需要进行的操作是<strong>翻转</strong>。自上而下的翻转：从根结点开始，在向下的过程中，如果看到一个结点X有两个红儿子的时候，就让X呈红色而让它的两个儿子是黑色的，这样不影响性质，如果X为根，则X和它的儿子都为黑色。<br><img src="https://ae01.alicdn.com/kf/H16080608be144ade9cbd8981e2978df1p.jpg" alt=""><br>若X的父结点为黑色，则继续翻转下去。若X的父结点为红色，这时候就出现了两个连续的红色，需要进行调整。<strong>调整方法就如上面2-(1)所讲过的旋转。这时X的父结点不会是红色，因为已经被自上而下的翻转调整过了</strong>。  </p>
<p>例如将45插入到前面的树中，首先自顶向下的翻转，发现50有两个红儿子，进行翻转，将50变为红色，40和55变成黑色，这样变成了2-(1)中的一字形，进行旋转，60代替70变为子树的根结点，然后将45插入。<br><img src="https://ae01.alicdn.com/kf/H90d4f1e3b13a4ac588ad969f29b0b92f4.jpg" alt="">  </p>
<p>对于红黑树的介绍就到这里了，因为有太多的情况需要考虑，所以红黑树的实现比之前的都要复杂，但红黑树的操作时间却更快一点。  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>优化的伸展树</title>
    <url>/2020/04/29/%E4%BC%98%E5%8C%96%E7%9A%84%E4%BC%B8%E5%B1%95%E6%A0%91/</url>
    <content><![CDATA[<p>摘要：本篇将开始进入高级数据结构的学习。主要讨论6种重点在于实用的数据结构。首先考察前面学习过的AVL树的一些变种，包括优化的伸展树，红黑树，以及treap树。然后考察后缀树，它能够在大文本中对一个模式进行搜索。然后，考察一种可以用于多维数据的数据结构，在这种情况下，每一项均可有多个关键字。K-d树对任何相关的关键字都能够进行查找。最后将考查配对堆，它似乎是对斐波那契堆一种最实用的变种。</p>
<a id="more"></a>
<p>重新复习一下伸展树，根据80-20黄金法则即80%的访问发生在20%的数据上，所以<strong>如果我们能够把经常访问的节点推到靠近根节点的位置，那么就可以极大的提高访问速度</strong>。根据这个思路，我们提出了 “ 旋转到根 ” 这一思路，具体的：每次查找、插入、删除一个节点，我们都使用旋转的方法把这个节点旋转到根节点的位置，并且因为旋转操作能够很好的把其他访问路径上的节点向上移动，所以最后这经常访问的20%的数据基本上都处于靠近根节点的位置。<br><strong>AVL树是全局调控即目的是缩小整棵树的高度，不会针对某一个节点做优化（例如将经常访问的节点移动到根的位置或靠近根的位置），伸展树则不考虑平衡的问题。AVL树是最坏情形运行时间为O(logn)，而伸展树则是摊还时间为O(logn)</strong>。<strong>因此它们的旋转操作也有区别</strong>。<br>前面已经讲了伸展树的伸展操作。其实伸展分为“自底向上”和“自顶向下”两种。<strong>前面所讲解的是“自底向上”。但在实际应用中，一般不用这种方法</strong>。因为，（1）首先要遍历访问路径上的所有节点，找到要访问的节点x （2）在自底向上调整结构的过程中，必须要记住x 的父节点P和祖父节点G，如果旋转G节点那么还需要记录曾祖父节点GG，如果你不想在节点结构中添加额外的成员来记住父节点，那么就只能使用足够深的栈来记录父节点信息。<br>所以使用<strong>自顶向下来替代自底向上，在自顶向下算法中，只需要一次遍历访问路径上的节点，并且在访问过程中我们就要完成“旋转到顶的操作”。只用到了O(1)的附加空间，但却保持了O(logn)的摊还时间界</strong>。<br>下面是自顶向下的旋转操作，分别为单旋转、一字形、之字形旋转。其中树L存储那些在树T中，但不在X子树中的小于X的结点。树R存储那些在树T中，但不在X子树中的大于X的结点。初始时，X为T的根，而L和R都是空树。<br><img src="https://ae01.alicdn.com/kf/Hed0b931faf0e460dbad17506bb7ee45b3.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/H7581283eebd14e20b31da0bf95abf057K.jpg" alt=""><br><img src="https://ae01.alicdn.com/kf/He2aaa84ea09846af8270005cbf4e6187G.jpg" alt=""><br>对于上面之字形的旋转可以进行简化，不再让Z成为中间树的根，而是让Y成为其根。这样，就变的与单旋转的情况相同。<br><img src="https://ae01.alicdn.com/kf/Hd9443bd7a7b9429d8da33dd9abf7ac35B.jpg" alt=""><br>当执行完最后一步展开后，就要处理L、R以及中间树，使其成为一棵树。这里的结果不同于从底部向上的展开，关键的问题在于，它保持了O(logn)的摊还界。<br><img src="https://ae01.alicdn.com/kf/Hee080362ee554f539b6fd9b29d2336b0A.jpg" alt=""><br>举例如下：<br><img src="https://ae01.alicdn.com/kf/Hb5a2f1a30e994789bf1619bb2112158eo.jpg" alt=""><br>我们访问树中的18，<strong>自顶向下是在遍历过程中就开始旋转，即从根结点开始，第一步是一个之字形旋转，我们使用简化后的，25变成中间树的根，不在25子树中且比25小的放在L树中</strong>：<br><img src="https://ae01.alicdn.com/kf/Hab03985db10e40b88b76e0be8181e6829.jpg" alt=""><br>接下来是<strong>一字形旋转，15变成中间树的根，不在15子树中且比15大的放入R树中</strong>：<br><img src="https://ae01.alicdn.com/kf/H072dc90d946b4ce6870b0d76a2d467ffc.jpg" alt=""><br>这样变成了单旋转：<br><img src="https://ae01.alicdn.com/kf/H5852253bcde24c72a27b38825baa7068n.jpg" alt=""><br>到此<strong>伸展已经完成，18为中间树的根，接下来将这三部分合成1棵树</strong>：<br><img src="https://ae01.alicdn.com/kf/Hbcf5c8b705834261b3a74436438ab3ebb.jpg" alt="">  </p>
<p>这就是自顶向下的伸展树的概念了，可以看到它比前面讲过的自底向上的有了很大改进。  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2020/04/26/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>摘要：本篇将介绍最后一个算法设计技巧，回溯算法。它相比穷举算法有了很大的性能改善。通过它的一个应用，收费公路重建问题能够让我们更加形象的对该算法进行理解。</p>
<a id="more"></a>
<p>在许多情况下，<strong>回溯算法相当于穷举搜索的巧妙实现，但性能一般不理想</strong>。即使是如此，在某些情况下，它相对于蛮力穷举搜索的工作量也有显著的节省。性能是相对的：<strong>对于排序而言，O(n^2)的算法是相当差的，但对旅行售货员（或任何NP完全）问题，O(n^5)算法则是里程碑式的结果</strong>。  </p>
<p>回溯算法的一个具体实例是在一套房子里摆放家具的问题。存在许多尝试的可能性，但一般只有一部分可能是具体要考虑的。开始什么也不摆，然后是每件家具被摆放在某个部位。如果所有的家具都摆好并且户主满意，那么算法终止。如果摆到某一步，该步之后的所有家具摆放方法都不理想，那么就撤销这一步并尝试另外的摆放方法。注意，<strong>虽然这个算法基本上是蛮力的，但它并不直接尝试所有的可能。例如，把沙发放进厨房的各种摆法是不会尝试的，许多明显不合适的摆法早就废弃了，因为令人讨厌的摆法的子集是知道的。在一步内删除一大组可能性的做法叫裁剪</strong>。  </p>
<h2 id="收费公路重建问题"><a href="#收费公路重建问题" class="headerlink" title="收费公路重建问题"></a>收费公路重建问题</h2><p>设给定n个点，p1,p2,p3…,pn，它们位于x轴上。xi是点pi的x坐标。并假设x1=0，这些点从左到右给出。这n个点确定了在每一对点间的n(n-1)/2个形如|xi-xj|的距离。显然，如果给定点集，那么容易以O(n^2)时间构造距离的集合。这个集合将不是排好序的，但如果愿意花O(n^2logn)时间界整理，那么这些距离也可以被排序。<strong>收费公路重建问题是从这些距离重新构造出点集。正像大数分解比乘法困难一样，重建问题也比构建问题困难。我们将要介绍的算法一般以O(n^2logn)运行，但最坏情况下可能要花费指数时间</strong>。<br>当然，若给定一个解，则可以通过对所有的点加上一个偏移量而构建无穷多其他的解。<strong>这就是为什么一定要将第一个点置于0处以及构成解的点集以非减顺序输出的原因</strong>。  </p>
<p>令D是距离的集合，|D|=M=n(n-1)/2，举例设：  D={1,2,2,2,3,3,3,4,5,5,5,6,7,8,10}。显然，可求n=6。算法以x1=0开始，又可得x6=10，因为x6与x1为最大距离10。将10从D中删除可得：<br><img src="https://ae01.alicdn.com/kf/Hc5c23a9c8bb542468010817dfc82c794V.jpg" alt=""><br>剩下的数中，最大的距离为8，那么x2=2或者x5=8，因为这时x1和x5或者x2和x6之间为最大距离。由对称性可以判定究竟选择哪个是不重要的，因为或者两个解都引向解（它们互为镜像），或者都不会引向最终的解。所以可置x5=8，这样x5到x6的2也能删除，得：<br><img src="https://ae01.alicdn.com/kf/H7f810f6b4e69439fa5b1f23cf66acf4a0.jpg" alt=""><br>现在7变成了D中最大的数，因此距x1和x6为7的点可能是x2=3或者x4=7。如果选择x2=3，它距x1为3，距x5为5都在D中，满足。如果选择x4=7，它距x5为1，距x6为3，也满足。因此我们先尝试一种求解，若不行再尝试另一种。置x4=7，那么变为：<br><img src="https://ae01.alicdn.com/kf/H33e943225e844a638392e447ba2ecb8fM.jpg" alt=""><br>此时最大的距离变为了6，因此x3=6，或者x2=4。但x3=6不成立，因为x3与x4的距离为1，D中没有。而x2=4则x2与x1和x5的距离都为4，而D中只有1个4，不成立。所以<strong>回溯</strong>。<br>在上一步里，不再选择x4=7，而是选择x2=3。变为：<br><img src="https://ae01.alicdn.com/kf/Hf201d9c900a64748a366d329983a96e99.jpg" alt=""><br>这样，D中最大值为6，即x4=6，或者x3=4。若x4=6，与x2距离为3，与x5距离为2，与x6距离为4，满足条件。若x3=4，与x1距离为4，与x2距离为1，与x5距离4，不满足条件。因此选择x4=6，得：<br><img src="https://ae01.alicdn.com/kf/H767f121848e14a57b29806789ea804abd.jpg" alt=""><br>这样只剩下x3=5，同时它使得D变成空集。因此这是问题的一个解。<br><img src="https://ae01.alicdn.com/kf/H9709d067f2ab4e59a9895824e22cfdbcz.jpg" alt="">  </p>
<p>本篇就是回溯算法的内容了，在下篇开始，将会进入几种高级数据结构的学习。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>随机化算法</title>
    <url>/2020/04/24/%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>摘要：本篇将要介绍的算法是随机化算法。随机化算法是在算法期间，随机数至少有一次用于决策。运行时间不只依赖于特定的输入，还依赖于所出现的随机数。主要介绍了随机数的生成，以及随机化算法的两个用途：查找和素数测试。</p>
<a id="more"></a>
<p>一个随机化算法的最坏情形运行时间常常和非随机化算法的最坏情形运行时间相同。重要的区别在于，好的随机化算法没有坏的输入，只有坏的随机数。<br>例如快速排序算法的两种变形。方法A用第一个元素当作枢纽元，而方法B使用随机选出的元素当作枢纽元，在这两种情形下，最坏情形运行时间都为O(n^2)，因为每一步都有可能选取最大的元素当作枢纽元。两种最坏情形的区别在于，存在特定的输入总能够在A中产生坏的运行时间，比如一个反序排列的数组，而在B中以该输入运行两次，将有两个不同的运行时间。<br>在前面散列的学习当中，已经有过随机数的应用，在本篇中将介绍随机化算法的两个用途：跳跃表、测试是否为素数。  </p>
<h2 id="随机数生成器"><a href="#随机数生成器" class="headerlink" title="随机数生成器"></a>随机数生成器</h2><p>正的随机数在计算机上是不可能生成的，所以一般使用的都是伪随机数。C++中随机数的库为<random>。因为是伪随机数，所以多次运行得到的随机序列是相同的，为了不同需要改变随机种子。  </p>
<pre><code>srand(0);             //随机种子0
for(int i=0;i&lt;5;i++)
{
    cout&lt;&lt;rand()%100&lt;&lt;&quot; &quot;;    
}    
srand(1);             //随机种子1
for(int i=0;i&lt;5;i++)
{
    cout&lt;&lt;rand()%100&lt;&lt;&quot; &quot;;    
}    </code></pre><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>随机化算法的第一个用途是以O(logn)的<strong>期望时间</strong>支持查找和插入的数据结构。这意味着对于任意输入序列的每一次操作的运行时间都有期望值O(logn)，其中的<strong>期望是基于随机数发生器</strong>的。<br>最简单的支持查找的数据结构是链表，一个普通的链表执行一次查找的最坏时间为N。<br><img src="https://p.pstatp.com/origin/fe880001ab73a2a5ff63" alt=""><br>对其进行加链来缩短时间：<br><img src="https://p.pstatp.com/origin/ff9900010cadc8f9c321" alt=""><br><img src="https://p.pstatp.com/origin/dc110005332a06014666" alt=""><br>跳跃幅度的一般情形如下图所示，<strong>每个第2^i节点都有一个链接链到其前面2^i节点。链的总个数是原始链表的2倍，但现在一次查找总的时间消耗为O(logn)</strong>。注意，在这种数据结构中的查找基本都是折半查找。<br><img src="https://p.pstatp.com/origin/ff3600009663364661cb" alt=""><br>但这种情形过于僵硬，不能进行有效的插入。因此要稍微放松它的限制条件。我们将带有k个链的节点定义为k阶节点。<br>当插入一个新元素时，为它<strong>分配一个新节点，此时，必须决定该节点是多少阶的</strong>。下图是一个一般的跳跃表，可以发现，大约一半的节点是一阶节点，1/4的节点是二阶节点，1/2^i的节点是i阶节点。我们<strong>按照这个概率分布随机选择节点的阶数</strong>。<br><img src="https://p.pstatp.com/origin/fedc00008386f119e32c" alt=""><br>跳跃表类似于散列表，它们都需要估计将要出现在链表中的元素个数（从而确定阶的数目）。  </p>
<h2 id="素性测试"><a href="#素性测试" class="headerlink" title="素性测试"></a>素性测试</h2><p>确定一个大数是否为素数。将给出一个可以测试素性的多项式时间算法。如果这个算法宣称一个数不是素数，那么我们可以肯定这个数不是素数。如果该算法宣称一个数是素数，那么，<strong>这个数将以高的概率，但不是100%的肯定是素数。错误的概率不依赖于测试的数，而是依赖于由算法做出的随机选择</strong>。<br>算法的关键是费马小定理：如果P是素数，且0&lt;A&lt;P，那么A^(P-1)=1(mod P)。<br>例如，由于67是素数，因此2^66=1(mod 67)，即2^66和1对于模67同余数。<strong>如果一个数N不满足该条件，那一定不是素数，满足该条件则很大可能是素数</strong>。<br>因此我们<strong>对A进行随机选取</strong>来构造随机化算法进行素性测试。  </p>
<pre><code>void prime(int n,int A)
{
    int m;
    m=pow(A,m-1);
    if(m%n==1)
    {
        cout&lt;&lt;&quot;true&quot;;    
    } 
    else
    {
        cout&lt;&lt;&quot;false&quot;;
    }
}
int main()
{
    int A;
    int n;
    cin&gt;&gt;n;
    A=1+rand()%n;
    cout&lt;&lt;A&lt;&lt;&quot; &quot;;
    prime(n,A);
    return 0;
}</code></pre><p>随机化算法通过随机数进行决策来得到期望时间，是一个非常巧妙地方法。在下一篇中，我们将讲解最后一种算法设计技巧，回溯算法。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/04/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>摘要：本篇将要讲解第三个设计技巧：动态规划。它与前面的贪婪算法和分治算法有相似点，又有不同之处，在前面的学习中，我们同样见到过动态规划的身影。本篇将主要介绍动态规划的思想以及它的应用。</p>
<a id="more"></a>
<p>在上一节，我们看到数学上能够被递归表示的问题也可以表示成一个递归算法，这对枚举做出了改进。<br>然而，编译器常常不能正确对待递归算法，导致低效的程序。当很怀疑是这种情况时，我们必须<strong>给编译器一些帮助，把递归算法重新写成非递归算法，让后者把那些子问题的答案系统的记录在一个表内。一种利用这种方法的技巧叫做动态规划</strong>。  </p>
<h2 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h2><p>例如求斐波那契数的递归算法，其实是非常低效的。  </p>
<pre><code>int fib(int n)
{
    if(n&lt;=1)
        return 1;
    else
        return fib(n-1)+fib(n-2);
}</code></pre><p>T(N)&gt;=T(N-1)+T(N-2)，所以运行时间与斐波那契数相同的速度在增长，从而是指数级的。<br>我们前面讲过通过迭代对递归进行优化，减少重复调用次数。  </p>
<pre><code>int fib(int n)
{
    int first,second,answer;
    first=second=1;
    for(int i=3;i&lt;=n;i++)
    {
        answer=first+second;
        first=second;
        second=answer;    
    } 
    return answer;
}</code></pre><p>而<strong>动态规划是用表来记录子问题的答案来减少重复调用，拿空间换时间</strong>。 </p>
<pre><code>int fib(int n)
{
    int i;
    vector&lt;int&gt; v(n);
    v[0]=0;
    v[1]=1;
    v[2]=1;
    i=3;
    while(i&lt;=n)
    {
        v[i]=v[i-1]+v[i-2];
        i++;
    }
    return v[n];    
}</code></pre><p><strong>可以看到，动态规划和迭代与递归相比，都有了很大的改进，使得能够在线性时间内完成，这是因为迭代只需要记录更新最近的两个解，动态规划把子问题的解都记录在了表中，可以直接调用</strong>，这样就避免了每次递归都要不停调用到起始条件。  </p>
<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>01背包问题是动态规划中最基础的问题之一，它的解法完美地体现了动态规划的思想和性质。<br>给定n件物品的体积和价值，现有给定容量的背包，如何让背包里装入的物品有最大的价值总和？<br>我们先来考虑贪婪算法，发现该问题类似于前面的装箱问题，但是不同之处在于有多个限制，而且<strong>贪婪算法得到的是局部最优，并不一定是最优解</strong>。<br><strong>动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，通过填写表把所有已经解决的子问题答案纪录下来，在新问题里需要用到的子问题可以直接提取，避免了重复计算，从而节约了时间，所以在问题满足最优性原理之后，用动态规划解决问题的核心就在于填表，表填写完毕，最优解也就找到</strong>。<br>示例如下：<br><img src="https://p.pstatp.com/origin/ff0800011f6654081254" alt=""><br>（1）问题抽象。用Xi取0或1，表示第i个物品选或不选，Wi表示第i个物品的体积，Vi表示第i个物品的价值。<br>（2）建立模型。即求max(V1X1+V2X2+V3X3+…+VnXn)。<br>（3）约束条件。W1X1+W2X2+W3X3+…+WnXn&lt;=capacity<br>（4）V(i,j)表示i个物品，容量j时对应的最佳组合的价值。（子问题）<br>（5）寻找递推关系式（状态转移），面对当前商品有两种可能性：<br>第一，包的剩余容量比该商品小，装不下。因此V(i,j)=V(i-1,j)。<br>第二，能装下该商品，但装了也不一定达到当前最优的价值，所以选择装还是不装。V(i,j)=max{V(i-1,j),V(i-1,j-W(i))+V(i)}。V(i-1,j)表示不装，V(i-1,j-W(i))+V(i)表示装了该物品，容量减少W(i)，但价值增加V(i)。<br>算法代码为：  </p>
<pre><code>void findmax(vector&lt;int&gt; &amp;w,vector&lt;int&gt; &amp;v,vector&lt;vector&lt;int&gt;&gt; &amp;V,int n,int capacity)
{                
    for(int i=1;i&lt;=n;i++)
    {
        for(int j=0;j&lt;=capacity;j++)
        {
            if(j&lt;w[i])
            {
                V[i][j]=V[i-1][j];
            }
            else
            {
                if(V[i-1][j]&lt;V[i-1][j-w[i]]+v[i])
                {
                    V[i][j]=V[i-1][j-w[i]]+v[i];
                }
                else
                {
                    V[i][j]=V[i-1][j];
                }
            }
        }
     } 
}
int main()
{
    vector&lt;int&gt; w{0,2,3,4,5};
    vector&lt;int&gt; v{0,3,4,5,6};
    vector&lt;vector&lt;int&gt;&gt; V(5,vector&lt;int&gt;(9,0));
    int capacity=8;
    findmax(w,v,V,4,8);
    cout&lt;&lt;V[4][8];
    return 0;
}</code></pre><p>这其实就是一个一步步填表的过程，初始时：<br><img src="https://p.pstatp.com/origin/ffb50000a427e98bee38" alt=""><br>一步步填写后：<br><img src="https://p.pstatp.com/origin/fe6c00018367a640a493" alt=""><br>时间复杂度为O(num*capacity)，即物品数量与总容量的乘积。  </p>
<h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p>前面在讲图的两点最短路径时，讲解过两种算法，Dijkstra算法和Floyd算法，其中<strong>Floyd算法就是动态规划的一个应用。它的递推关系式就是面对一个结点时进行判断是否将该结点作为中介点。比较选择该点为中介点以及不选择该点为中介点的最短路径的值，来进行状态转移</strong>。  </p>
<p>动态规划是非常高效的一种算法，它也是利用递推来求解最值。但与贪婪算法不同的地方在于动态规划考虑了所有情况，贪婪算法不一定得到最优值，而动态规划得到的一定是最优值。与分治算法相比，动态规划使用表来存储数据，避免了递归的重复调用。虽然会花费更多的空间，但是提高了运行时间的效率。  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/2020/04/18/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>摘要：本篇将要讲解的算法为分治算法，其实在之前的学习中，有过很多分治算法的例子，它的应用非常广泛，在本篇将会再介绍它的一些应用以及解法。</p>
<a id="more"></a>
<p>从名字就可以知道，分治算法由两部分组成：<br>分(divide)：递归解决较小的问题，<br>治(conquer)：从子问题的解构建原问题的解。<br>传统上，在其代码中<strong>至少含有两个递归调用的例程</strong>叫做分治算法，而只含有一个就是递归而不是分治。一般坚持子问题是不相交的。<br>前面讲过很多分治算法的例子，如<strong>树的遍历、归并排序和快速排序</strong>等等。在这里，将给出更多分治算法的实例。<br>首先介绍以下分治算法的运行时间，因为分成两部分递归，若附加的工作时间为O(n)，则总时间T(n)=2T(n/2)+O(n)，可解得为O(nlogn)。若附加的工作时间为O(n^2)，则总运行时间为O(n^2)。  </p>
<h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><p>给定平面上的N个点，证明最近的一对点可以在O(nlogn)时间内找到。<br>显然有N(N-1)/2对点间的距离，若要采用暴力解法全部计算出来，然后排序选择最小的，则需要O(n^2)的时间。<br>若这些点已经按x坐标排好序，因为<strong>排序算法为O(nlogn)的时间复杂度</strong>，因此不增加算法运行时间的级别。如下所示：<br><img src="https://ae01.alicdn.com/kf/Hebdd5758691242ac892a75ada04fe02dO.png" alt=""><br>我们可以画一条想象的垂线，把点集分成两半，PL和PR。这样最近的一对点或者都在PL中，或者都在PR中，或者一个在PL中，一个在PR中。如下所示：<br><img src="https://ae01.alicdn.com/kf/H31cd546ccb16478998580f1f9e8dd971F.png" alt=""><br>根据前面所讲的，我们需要用O(n)的时间来算出dc。然后递归计算dl和dr即可。这样总时间才能为O(nlogn)。在计算dc的时候，显然不需要考虑所有点，因为<strong>dc要满足比dl和dr小</strong>才有意义，因此设min为dl和dr中的最小值。那么计算<strong>dc所需要的点只能分布在mid-min和mid+min这一段x坐标</strong>上。否则dc必定超出min。一种简单的方法是对于每个mid-min区域内的点，遍历mid+min区域求出最短距离。然而若这个区域包含所有点，时间复杂度又变成了O(n^2)。 因此<strong>考虑x坐标划分的方法，显然对于mid-min区域内的点，若mid+min区域点的y坐标与之差别超过min，自然距离也超出min。因此对于mid-min区域内的点，只需计算mid+min区域中y坐标与该点y坐标相差不超过min的点的距离即可</strong>。  </p>
<h2 id="选择问题"><a href="#选择问题" class="headerlink" title="选择问题"></a>选择问题</h2><p>要求找出N个元素集合S中的第k个最小的元素。通过把元素排序选择问题可以容易的以最坏情形时间O(nlogn)解决，但是不知道选择能否以O(n)最坏情形时间完成。  </p>
<h2 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><p>常规的矩阵相乘即3重循环，计算A的第i行和B的第j列的点乘。  </p>
<pre><code>for(int i=0;i&lt;n;i++)
{
    for(int j=0;j&lt;n;j++)
    {
        C[i][j]=0;
        for(k=0;k&lt;n;k++)
        {
            C[i][j]+=A[i][k]*B[k][j];
        }
    }
}</code></pre><p>长期以来一直认为矩阵乘法是需要工作量O(n^3)的。直到后来打破了该屏障。把每一个矩阵分解成四块。<br><img src="https://ae01.alicdn.com/kf/H130893a88ff845babee1049ce89f9a55A.png" alt=""><br>此时容易证明：<br><img src="https://ae01.alicdn.com/kf/Hb4c7c495d5d846bc8dc2fe12bcdf0ee6e.png" alt=""><br>例如计算：<br><img src="https://ae01.alicdn.com/kf/H1f8f14c7e93a47378fdcc020c59c73fde.png" alt=""><br>分成8部分：<br><img src="https://ae01.alicdn.com/kf/H8b465c457a3f425ba0affc92446129bcG.png" alt=""><br>这样共进行8个矩阵乘法和4个矩阵加法，加法花费O(n^2)时间。T(n)=8T(n/2)+O(n^2)。然而通过计算可得时间T(n)=O(n^3)，并没有作出改进，所以要把<strong>子问题优化到8个以下</strong>。需要重新安排运算：<br><img src="https://ae01.alicdn.com/kf/H010b8f6fbb934fb7835fc72441c5044cl.png" alt=""><br>这样，最后答案可由8次加法得到：<br><img src="https://ae01.alicdn.com/kf/H5c6d5224c8be4389924735db90d817ab7.png" alt=""><br>时间复杂度由O(n^3)变成了T(n)=O(n^log7)=O(n^2.81)。  </p>
<p>分治算法利用递归来分和治，巧妙了缩短了运行时间，在后续依然后很多例子会让我们见识到分治算法的巧妙之处。  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>贪婪算法</title>
    <url>/2020/04/16/%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>摘要：在本篇就进入了算法设计的部分。总共有5种类型的算法设计技巧，本篇所要介绍的是贪婪算法。主要讲解贪婪算法的思想以及贪婪算法的应用。</p>
<a id="more"></a>
<p>前面已经讲过3个贪婪算法：Dijkstra算法、Prim算法、Kruskal算法。<strong>贪婪算法分阶段工作，在每一阶段，可以认为所作决定是最好的，而不考虑将来的后果。当算法终止时，我们希望局部最优等于全局最优，如果是这样，那算法就是正确的。否则得到的就是一个次最优解</strong>。例如前面所讲过的货币找零问题，一般情况下贪婪算法是可以解决的，但当增加了面额时，所得到的可能不再是最优解。  </p>
<h2 id="简单的调度问题"><a href="#简单的调度问题" class="headerlink" title="简单的调度问题"></a>简单的调度问题</h2><p>实际上，所有的调度问题或者是NP完全的，或者是贪婪算法可解的。今有作业j1、j2、j3、…、jn，对应的运行时间为t1、t2、t3、…、tn，而处理器只有一个，为了把作业平均完成的时间最小，最好的调度方式是什么？（一旦开始一个作业，就必须将其运行到完成）。<br><img src="https://ae01.alicdn.com/kf/H43de3a03789b4ad1b5c6b86599ce474fa.png" alt=""><br>以上面作业为例，下面两种调度方式，第一种中，j1运行时间为15，j2运行时间为23（因为它必须等j1完成后才能运行），j3运行时间为26，j4为36，因此平均完成时间为25。而在第二种中，平均完成时间为17.75。这也是<strong>最优的调度方法，按照最短的作业最先进行来安排。这个结果也指出了操作系统调度程序一般把优先权赋予那些更短的作业的原因</strong>。<br><img src="https://ae01.alicdn.com/kf/Hf0bb6966470d4856939a7fae6b9c0796E.png" alt=""><br><img src="https://ae01.alicdn.com/kf/H78a497d91341461880e58dd11bf3e60f4.png" alt=""><br>上面讲的是单处理器的情况，如果多处理器呢？假设有3个处理器，作业情况如下所示。<br><img src="https://ae01.alicdn.com/kf/Hb536dd35d2224372917fcf27bd4ebeb4O.png" alt=""><br>一个最优的安排是下图，它把平均完成时间优化到最小。因此解决<strong>多处理器情形的算法是按顺序开始作业，处理器之间轮换分配作业</strong>。<br><img src="https://ae01.alicdn.com/kf/Hbd21997eb01a4a3a85496e7e117bfbb42.png" alt=""><br>当处理器个数P能被作业数N整除时，存在多个最优的排序。如下为第二个最优解。<br><img src="https://ae01.alicdn.com/kf/H3c5e72bfbeb641acba784dc6dcb97d455.png" alt="">  </p>
<h2 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h2><p>这部分知识在前面赫夫曼树的部分已经讲过，也是利用贪婪算法的思想来求解的。这里就不再重复介绍。</p>
<h2 id="装箱问题"><a href="#装箱问题" class="headerlink" title="装箱问题"></a>装箱问题</h2><p>用贪婪算法解决装箱问题，这些算法运行的很快，但<strong>未必产生最优解，然而能证明所产生的解距最优解不太远</strong>。设给定N项物品，大小为s1、s2、s3、…、sn，所有的大小都满足0&lt;=si&lt;=1。问题是要把这些东西装到最小数目的箱子中去，每个箱子的容量是1个单位。作为例子，下图所示为把大小0.2，0.5，0.4，0.7，0.1，0.3，0.8的一列物品最优装箱的方法。<br><img src="https://ae01.alicdn.com/kf/H3e1ca179539f4964bc78f74c7b64afbfJ.png" alt=""><br>装箱问题有两种类型：<strong>联机装箱问题：每一件物品都必须放入一个箱子之后才处理下一个物品。脱机装箱问题：等到所有的输入数据全部被读入后再装箱</strong>。</p>
<h3 id="联机装箱问题"><a href="#联机装箱问题" class="headerlink" title="联机装箱问题"></a>联机装箱问题</h3><p>对于联机装箱问题<strong>不存在最优解法</strong>。有3种简单算法保证所用的箱子数不多于2倍的最优装箱数。<br>下项适合算法：当处理任何一项物品时，检查它是否还能装进刚刚装进物品的同一个箱子中去，如果能就把它装进去，否则开辟一个新箱子。算法简单，以线性时间运行。<br><img src="https://ae01.alicdn.com/kf/H8e8149a8358d481fb6de55f01d2d9cf8n.png" alt=""><br>令M是一列物品I装箱所需的最优装箱数，则下项适合算法所用箱子数绝不超过2M，存在一些顺序使得用箱2M-2个。<br>首次适合算法：可以看到下项适合算法的<strong>效果很差</strong>，如上面的B2、B4箱子都比较空。首次适合算法的策略是依序扫描这些箱子，并把新的一项物品放入足能盛下它的<strong>第一个</strong>箱子中去。只有前面都放不下时才开辟新箱子。需要花费O(n^2)的时间。<br><img src="https://ae01.alicdn.com/kf/H8282542d56e54ce2b69e96b53134a4b7U.png" alt=""><br>最佳适合算法：该法是把新物品放到所有箱子中能够容纳它的<strong>最满的箱子</strong>中。<br><img src="https://ae01.alicdn.com/kf/H0b0d72a81a3d44739fd72009322f78643.png" alt=""><br>最佳适合算法看起来对箱子进行了更细致的划分，性能应该会提高。但情况并非如此，因为一般的坏情形是相同的。  </p>
<h3 id="脱机装箱问题"><a href="#脱机装箱问题" class="headerlink" title="脱机装箱问题"></a>脱机装箱问题</h3><p><strong>所有联机算法的问题在于将大项物品装箱困难，尤其是当它们在输入的后期出现时。因此方法是将各项物品排序，把最大的物品放在最先</strong>，此时可以应用首次适合算法和最佳适合算法，得到首次适合递减算法和最佳适合递减算法。下面为首次适合递减算法示例：<br><img src="https://ae01.alicdn.com/kf/H86f1d89c0327483097f3fe815f3a3523d.png" alt="">  </p>
<p>关于贪婪算法的介绍就先到这里，在后续的学习中会针对具体问题分析如何用贪婪算法求解并实现。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>图的遍历</title>
    <url>/2020/04/14/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>摘要：图的遍历类似于树的遍历。但图的遍历只有两种形式，深度优先遍历和广度优先遍历。本篇将会对这两种遍历方法进行介绍，并给出它们的代码实现。深度优先遍历和广度优先遍历和树的先序遍历和层序遍历有相似之处。</p>
<a id="more"></a>
<p>从图中某一顶点出发访遍图中其他顶点，且使每个顶点仅被访问一次，这就是图的遍历。它类似于树的遍历，通过递归实现。  </p>
<h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>深度优先遍历(DFS)类似于树的<strong>先序遍历</strong>，从一个点v出发进行访问，然后依次从它未被访问的邻接点出发深度搜索遍历图，直至所有和v有路径相通的顶点都被访问到。若尚有其他顶点未被访问，就另选一个顶点作为起始点重复上述过程。<br><img src="https://ae01.alicdn.com/kf/H0adabe8f2c3f41a3b47848cb986cb625t.png" alt=""><br>如上所示的图，若从顶点A作为起始点，首先访问A，然后再访问它的邻接点B，再访问B的邻接点C（B的邻接点有C、E、F，按照存储顺序C在前面），再访问C的邻接点E，E的邻接点D（B已被访问过），D的邻接点C也被访问过，因此<strong>返回到B</strong>，B的邻接点C和E都被访问过，访问F和它的邻接点G。最终顺序为A、B、C、E、D、F、G。<br>DFS实现代码为：  </p>
<pre><code>class graph
{
    private:
        int n;
        vector&lt;vector&lt;int&gt;&gt; G;            //邻接矩阵 
        vector&lt;bool&gt; visit;             //访问标志的数组 
    public:
        graph(int n,vector&lt;vector&lt;int&gt;&gt; G1,vector&lt;bool&gt; v);    //构造函数初始化 
        void DFS(int i);
        void DFS1();
};
graph::graph(int n,vector&lt;vector&lt;int&gt;&gt; G1,vector&lt;bool&gt; v)
{
    this-&gt;n=n;
    G=G1;
    visit=v;
} 
void graph::DFS(int i)
{
    int j;
    visit[i]=true;
    cout&lt;&lt;i&lt;&lt;&quot; &quot;;
    for(j=0;j&lt;n;j++)
    {
        if(visit[j]==false&amp;&amp;G[i][j]==1)
        {
            DFS(j);
        }
    }
}
//若图是非连通的
void graph::DFS1()
{
    for(int i=0;i&lt;n;i++)
    {
        if(visit[i]==false)
        {
            DFS(i);
        }
    }
} 
int main()
{
    int n=7;
    vector&lt;vector&lt;int&gt;&gt; G1{{0,1,0,0,0,0,0},{0,0,1,0,1,1,0},{0,0,0,0,1,0,0},{0,0,1,0,0,0,0},{0,1,0,1,0,0,0},{0,0,0,0,0,0,1},{0,0,0,0,0,0,0}};
    vector&lt;bool&gt; v(7);
    graph g(n,G1,v);
    g.DFS(0);
    g.DFS1();
    return 0;
}</code></pre><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>广度优先遍历(BFS)类似于树的层序遍历,从顶点v出发，访问v以后依次访问它的邻接点，然后再从这些邻接点出发依次访问它们的邻接点，并使得先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，如果最终仍有顶点未被访问到，则另选一个未被访问的顶点重复上述过程。<br>继续以上面的图为例：<br><img src="https://ae01.alicdn.com/kf/Hcc15ccb6bfef4284809ec31ec41d45a1l.png" alt=""><br>以A为起始点访问然后按顺序访问它的邻接点，因为A只有一个邻接点B，访问B然后按顺序访问它的邻接点C、E、F。先访问C，再访问E，最后访问F。然后再依次访问C的邻接点、E的邻接点、F的邻接点。最终顺序为A、B、C、E、F、D、G。<br>广度优先搜索的实现代码如下：  </p>
<pre><code>class graph
{
    private:
        int n;
        vector&lt;vector&lt;int&gt;&gt; G;            //邻接矩阵 
        vector&lt;bool&gt; visit;             //访问标志的数组 
        queue&lt;int&gt; q;
    public:
        graph(int n,vector&lt;vector&lt;int&gt;&gt; G1,vector&lt;bool&gt; v);    //构造函数初始化 
        void BFS(int i);
        void BFS1();
};
graph::graph(int n,vector&lt;vector&lt;int&gt;&gt; G1,vector&lt;bool&gt; v)
{
    this-&gt;n=n;
    G=G1;
    visit=v;
} 
void graph::BFS(int i)
{
    int j;
    int tem;
    visit[i]=true;
    cout&lt;&lt;i&lt;&lt;&quot; &quot;;
    for(j=0;j&lt;n;j++)
    {
        if(visit[j]==false&amp;&amp;G[i][j]==1)
        {
            q.push(j);
            visit[j]=true;
        }
    }
    if(!q.empty())
    {
        tem=q.front();
        q.pop();
        BFS(tem);
    }
}
//若图是非连通的
void graph::BFS1()
{
    for(int i=0;i&lt;n;i++)
    {
        if(visit[i]==false)
        {
            BFS(i);
        }
    }
} 
int main()
{
    int n=7;
    vector&lt;vector&lt;int&gt;&gt; G1{{0,1,0,0,0,0,0},{0,0,1,0,1,1,0},{0,0,0,0,1,0,0},{0,0,1,0,0,0,0},{0,1,0,1,0,0,0},{0,0,0,0,0,0,1},{0,0,0,0,0,0,0}};
    vector&lt;bool&gt; v(7);
    graph g(n,G1,v);
    g.BFS(0);
    g.BFS1();
    return 0;
}</code></pre><p>可以看到，与DFS不同之处在于多了一个队列q进行辅助，来存储要访问的顶点顺序。<br>图的遍历和树的遍历都是非常重要的知识，理解遍历的过程，掌握如何用代码实现遍历是非常重要的。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2020/04/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>摘要：本篇将要讲解的知识为最小生成树。一个n个顶点的图，选取其n-1条边且不构成回路称为生成树。而权值最小的则为最小生成树，求解一个图的最小生成树是非常重要的。本篇将介绍两种算法来求解一个图的最小生成树。</p>
<a id="more"></a>
<p>生活中经常会见到最小成本问题。例如若要对n个村庄通电，布电路线该如何选择使得代价最小。这就是最小生成树所解决的，即用n-1条边将n个顶点连接起来，并且使权值的和最小。如下所示为一个图和它的最小生成树。<br><img src="https://ae01.alicdn.com/kf/H3b479ac33e08479eaa489e938f65f3b2L.png" alt="">  </p>
<h2 id="普里姆-Prim-算法"><a href="#普里姆-Prim-算法" class="headerlink" title="普里姆(Prim)算法"></a>普里姆(Prim)算法</h2><p>即以某顶点为起点，逐步找各顶点上最小权值的边来构建最小生成树。<strong>这与前面最短路径的Dijkstra算法相同，也是利用贪婪算法的思想来求解的</strong>。下面是针对上图的普里姆算法的求解过程。<br><img src="https://ae01.alicdn.com/kf/Hde38f6fd54364bbb9b85a3b9b02d2aabg.png" alt=""><br>因为与Dijkstra算法类似，因此它也需要一个表，初始配置如下：<br><img src="https://ae01.alicdn.com/kf/H8b68ef97875a40f5aba52df2eff319a0O.png" alt=""><br>这里需要说明的是，表中其他项与前面的相同，<strong>但是dv不再表示最短路径长度和，而是连接顶点v到一个known顶点的最短边的权。因此更新法则不同</strong>。首先选取v1，该表被更新：<br><img src="https://ae01.alicdn.com/kf/Hb5620b5e5b684cccb42e75747bfdf7aep.png" alt=""><br>可以看到最短边的权值为1，v4。因此选取v4进行更新它的邻接点，v1已知不改变。v4到v2边为3，大于v1到v2的2，不改变。v4到v3为2比4小，更新。V5、v6、v7更新得：<br><img src="https://ae01.alicdn.com/kf/Hf453c8afc18f45bbae2e664f6ba701696.png" alt=""><br>接下来再在未知的点中选取更新，最终得：<br><img src="https://ae01.alicdn.com/kf/Hc7ac9857aa514e6db580a73f76ed2940d.png" alt=""><br>这时dv为最小生成树所有最短的边，加起来为树的权值。pv可得树的各条边。<br>实现代码如下：  </p>
<pre><code>const int INF=10000;
void Prim(int n,int s,vector&lt;vector&lt;int&gt;&gt; &amp;G,vector&lt;bool&gt; &amp;vis,vector&lt;int&gt; &amp;d,vector&lt;int&gt; &amp;pre) 
    //顶点数，初始点，图，标记是否被访问，最小生成树的边长，树上顶点的前驱顶点 
{
    d[s]=0;
    for(int i=0;i&lt;n;i++)
    {
        int u=-1;
        int MIN=INF;
        for(int j=0;j&lt;n;j++)
        {
            if(vis[j]==false&amp;&amp;d[j]&lt;MIN) //找到d[u]最小的u，确定每一次更新后的下一个顶点 
            {
                u=j;                                   
                MIN=d[j];
            }
        }
        if(u==-1)                               //找不到说明剩下的顶点和s不连通 
        {
            return;
        }
        vis[u]=true;                       //将找到的u表示为已被访问 
        for(int m=0;m&lt;n;m++)            //对剩下未被访问并且u能到达的点进行距离优化 
        {
            if(vis[m]==false&amp;&amp;G[u][m]&lt;d[m])
            {
                d[m]=G[u][m];
                pre[m]=u;                               //并将m点的前驱顶点u记录 
            }
        }
    }    
}
void Print(int s,int v,vector&lt;int&gt; pre)        //利用递归将前驱打印出来 即为树的边 
{
    for(int i=s+1;i&lt;v;i++)
    {
        cout&lt;&lt;&quot;(&quot;&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;pre[i]&lt;&lt;&quot;) &quot;;
    }
}
int main()
{
    int n=7;
    int te=0;
    vector&lt;int&gt; d(n);
    vector&lt;int&gt; pre(n);
    vector&lt;bool&gt; vis(n);
    vector&lt;vector&lt;int&gt;&gt; G{{0,2,4,1,INF,INF,INF},{2,0,INF,3,10,INF,INF},{4,INF,0,2,INF,6,INF},{1,3,2,0,7,8,4},{INF,10,INF,7,0,INF,6},{INF,INF,5,8,INF,0,1},{INF,INF,INF,4,6,1,0}};
    for(int i=0;i&lt;n;i++)
    {
        d[i]=INF;
        pre[i]=i;
    }
    Prim(n,0,G,vis,d,pre);
    for(auto x:d)                         //将最小生成树各边权值相加 
    {
        te=x+te;
    }    
    cout&lt;&lt;te&lt;&lt;endl;
    Print(0,7,pre);
    return 0;
}</code></pre><p>可以看到与前面的Dijkstra算法相比只有稍微的改变，因此时间复杂度为O(n^2)。根据表可以看到，普里姆算法跟顶点个数有关系，因此在稠密图中有优势。  </p>
<h2 id="克鲁斯卡尔-Kruskal-算法"><a href="#克鲁斯卡尔-Kruskal-算法" class="headerlink" title="克鲁斯卡尔(Kruskal)算法"></a>克鲁斯卡尔(Kruskal)算法</h2><p>克鲁斯卡尔(Kruskal)算法也是贪婪策略的一种解法，但这次不是以顶点为重点，而是<strong>以边为重点，选择权值最小的边来构建，但注意不能产生回路</strong>。针对上图的求解过程如下：<br><img src="https://ae01.alicdn.com/kf/Hd32683f7efa044b18843a7a5153ec2ceG.png" alt=""><br>表的形式来表示为：<br><img src="https://ae01.alicdn.com/kf/H1e53c4bf75d44da1b5a5f666a262a5624.png" alt=""><br>关键点在于对边权排序，和添加边权时判断是否产生回路。因为是针对边，所以要<strong>创建边结构体，包括边的两个顶点和它的权值。排序时使用STL的sort即可</strong>。<br>实现代码如下：  </p>
<pre><code>struct edge
{
    int u;            //顶点 
    int v;
    int cost;         //边权
    edge(int x,int y,int z):u(x),v(y),cost(z){} 
};
bool cmp(edge a,edge b)
{
    return a.cost&lt;b.cost;
}
void findfather(vector&lt;int&gt; &amp;v,int n,edge &amp;a)
{
    if(v[a.v]==a.v)
    {
        v[a.v]=v[a.u];
    }
    else
    {
        for(int i=0;i&lt;n;i++)
        {
            if(v[i]==v[a.u])
            {
                v[i]=v[a.v];
            }
        }
    }    
}
int Kruskal(int n,int m,vector&lt;edge&gt; &amp;E)            //顶点数，边数，边集 
{
    vector&lt;int&gt; v(n);
    for(int i=0;i&lt;n;i++)
    {
        v[i]=i;
    }
    int num;
    int cost1;
    num=cost1=0;
    sort(E.begin(),E.end(),cmp);
    for(int i=0;i&lt;m;i++)
    {
        int tem1=E[i].u;
        int tem2=E[i].v;
        if(v[tem1]!=v[tem2])
        {
            cout&lt;&lt;&quot;(&quot;&lt;&lt;E[i].u&lt;&lt;&quot;,&quot;&lt;&lt;E[i].v&lt;&lt;&quot;) &quot;;
            findfather(v,n,E[i]);
            cost1=cost1+E[i].cost;
            num++;
        }
        if(num==n-1)
        {
            break;
        }
    }
    if(num==n-1)
    {
        return cost1;
    }
    else
    {
        return -1;
    }
}
int main()
{
    vector&lt;edge&gt; E{edge(0,1,4),edge(1,2,1),edge(2,3,6),edge(3,4,5),edge(0,4,1),edge(0,5,2),edge(1,5,3),edge(2,5,5),edge(3,5,4),edge(4,5,3)};
    int n=6;
    int m=10;
    int res=Kruskal(6,10,E);
    cout&lt;&lt;res;
    return 0;
}</code></pre><p>可以看到，代码的关键点在于如何判断是否产生回路。首先将一条边的两个顶点都用最小的顶点来表示，即a[v]=a[u]=u，出现问题即<strong>一个顶点被重复赋值造成错误</strong>。<strong>因此需要判断顶点是否已经与其他顶点相连</strong>，即若a[v]!=v，说明它已经被改变过，这时需要将它这条边的u，以及所有与u相连的顶点全变为a[v]。这样只有v[u]!=v[v]时，才说明该边不会构成回路。<br>克鲁斯卡尔的时间复杂度与边数e有关，为O(eloge)。克鲁斯卡尔针对边，对于稀疏图（边少）有很大优势，而普里姆算法则对于稠密图（边多）有很大优势。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>最短路径2</title>
    <url>/2020/04/10/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%842/</url>
    <content><![CDATA[<p>摘要：本篇将继续上一篇对求解图顶点间的最短路径进行讲解。主要讲解第二种算法弗洛伊德算法，算法它的时间复杂度为O(n^3)，但是它的实现却非常简单和巧妙。</p>
<a id="more"></a>
<p>和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。<br>以一个简单的3顶点连通网图为例：<br><img src="https://i.loli.net/2020/04/10/p8D2Cwd6KNAhjou.png" alt=""><br>定义两个二维数组D[3][3]和P[3][3]。D表示顶点到顶点的最短路径权值，P则表示顶点最小路径的后继顶点。注意与上个算法的不同，上个是前驱顶点。初始时：<br><img src="https://s1.ax1x.com/2020/04/10/Go5OWq.png" alt=""><br>可以看到就是图的邻接矩阵。<br><img src="https://s1.ax1x.com/2020/04/10/GoI9w4.png" alt=""><br>P矩阵初始则为顶点的直接路径，如v1到v2，P[1][2]=2。<br>接下来，以v0为中介点进行更新，即v1直接到v2距离为5，但v1若先到v0再到v2距离为3，比5小。因此对D和P进行更新。更新3次，<strong>分别以所有顶点为中介点对其他顶点间的距离更新</strong>。得到：<br><img src="https://pic.images.ac.cn/image/5e901438916dd" alt="">  </p>
<p><img src="https://ae01.alicdn.com/kf/Ha714fbe49b8d4e5b841ea7e1394da3d3M.png" alt=""><br>这时矩阵D就表示的顶点之间的最短路径长度。<br><strong>通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵D和P，矩阵D中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。</strong> 接下来开始，<strong>对矩阵S进行N次更新</strong>。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k]+a[k][j]”，则更新a[i][j]为”a[i][k]+a[k][j]”。更新N次之后，操作完成。<br>依然以上个算法的图为例，实现代码如下：  </p>
<pre><code>const int INF=10000;
class graph
{
    private:
        int n;
        vector&lt;vector&lt;int&gt;&gt; G;            //邻接矩阵 
        vector&lt;vector&lt;int&gt;&gt; P;          //路径结点矩阵
        vector&lt;vector&lt;int&gt;&gt; D;          //最短路径长度矩阵 
    public:
        graph(int n,vector&lt;vector&lt;int&gt;&gt; G1,vector&lt;vector&lt;int&gt;&gt; P1);    //构造函数
        void Floyd();     //弗洛伊德算法 
        void Print(int s,int v);
        void Print1();
};
graph::graph(int n,vector&lt;vector&lt;int&gt;&gt; G1,vector&lt;vector&lt;int&gt;&gt; P1)
{
    this-&gt;n=n;
    G=G1;
    D=G1;
    P=P1;
}
void graph::Floyd()
{
    for(int k=0;k&lt;n;k++)
    {
        for(int i=0;i&lt;n;i++)
        {
            for(int j=0;j&lt;n;j++)
            {
                if(D[i][j]&gt;D[i][k]+D[k][j])
                {
                    D[i][j]=D[i][k]+D[k][j];
                    P[i][j]=k;
                 } 
            }
        }
    }
} 
void graph::Print(int s,int v)              //将路径结点打印出来 
{
    if(s!=v)
    {
        cout&lt;&lt;s&lt;&lt;&quot; &quot;;
        int k=P[s][v];
        while(k!=v)
        {
            cout&lt;&lt;k&lt;&lt;&quot; &quot;;
            k=P[k][v];
        }
        cout&lt;&lt;v&lt;&lt;endl;
    }
}
void graph::Print1()
{
    for(int i=0;i&lt;n;i++)
    {
        for(int j=0;j&lt;n;j++)
        {
            cout&lt;&lt;D[i][j]&lt;&lt;&quot; &quot;;    
        }
        cout&lt;&lt;endl;
    }
}
int main()
{
    int n=6;
    vector&lt;vector&lt;int&gt;&gt; Pm{{0,1,2,3,4,5},{0,1,2,3,4,5},{0,1,2,3,4,5},{0,1,2,3,4,5},{0,1,2,3,4,5},{0,1,2,3,4,5}};
    vector&lt;vector&lt;int&gt;&gt; G1{{0,1,INF,4,4,INF},{INF,0,INF,2,INF,INF},{INF,INF,0,INF,INF,1},{INF,INF,2,0,3,INF},{INF,INF,INF,INF,0,3},{INF,INF,INF,INF,INF,0}};
    graph g(n,G1,Pm);
    g.Print1();
    g.Floyd();
    cout&lt;&lt;endl;
    g.Print(0,5);
    cout&lt;&lt;endl;
    g.Print1();
    return 0;
}</code></pre><p>可以看到，3重嵌套循环，时间复杂度为O(n^3)。但是算法却并不复杂，不停的选择中介点来更新距离，与上一节的算法有异曲同工的作用。通过该算法就能得到各顶点之间的最短路径长度。若顶点之间无法到达，则为我们定义的INF。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>最短路径1</title>
    <url>/2020/04/08/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%841/</url>
    <content><![CDATA[<p>摘要：本篇将要讲解的知识为最短路径。最短路径分为有权的和无权的，无权的即为路径数目，有权的要考虑权值之和最小。求最短路径一般分析的都是有权的，有两种典型算法求解最短路径，在本篇中将主要介绍第一种Dijkstra算法，另一种算法会在下一篇中进行介绍。最短路径是实际生活中经常遇到的问题，学会求解最短路径是非常重要的。</p>
<a id="more"></a>
<p>在网图和非网图中，最短路径的含义是不同的。非网图的边上没有权值，所以最短路径就是两顶点之间经过的边数最少的路径，而对于网图来说，最短路径是指两顶点之间经过的边上权值之和最少的路径，并且称路径的第一个顶点为源点，最后一个顶点为终点。<br>如下，若边上无权，v1到v6最短路径为2，但边上有权值，则最短路径长为6，v1到v4再到v7，最后到v6。<br><img src="https://i.loli.net/2020/04/08/nIMy35USFt79fPl.png" alt=""><br>在很多的情况下需要我们去寻找一个顶点到另一个顶点的最短路径。<strong>对于无权的最短路径，其实是有权最短路径的特殊问题，这相当于所有边的权值都为1</strong>。例如我们选择v3为初始点s，显然s到v3的距离为0。标记该信息如下：<br><img src="https://i.loli.net/2020/04/08/wKAx9aSnqlrBGQV.png" alt=""><br>然后寻找所有从s出发距离为1的点。考查s的邻接点即可，可以看到v1和v6距离s为1，标记。<br><img src="https://i.loli.net/2020/04/08/bHYzILVky8tMEvS.png" alt=""><br>然后寻找所有从s出发距离为2的点，即距离v1，v6为1的点，可以看到v2和v4距离s为2，标记。<br><img src="https://i.loli.net/2020/04/08/RowTcxtanN5vCBO.png" alt=""><br>这样再去寻找距离s为3的点，依次直到把所有的顶点寻找完。<br><img src="https://i.loli.net/2020/04/08/liXG82wzPFSrZvu.png" alt=""><br><strong>这种搜索图的方法称为广度优先搜索，该方法按层处理顶点：距开始点最近的那些顶点首先被求值，而最远的那些顶点最后被求值。这很像对树的层序遍历</strong>。 </p>
<p>在有权最短路径的求法中有两种算法，本篇将介绍第一种，迪杰斯特拉(Dijkstra)算法。<br>如同上面所讲述的无权最短路径方法，<strong>迪杰斯特拉(Dijkstra)算法是按路径长度递增的次序产生最短路径的算法</strong>。这个解法是<strong>贪婪算法</strong>的实例。<strong>贪婪算法一般分阶段求解一个问题，在每个阶段它都把出现的当作是最好的去处理</strong>。例如在美国货币找零钱时，一般是先数出25分一个的硬币，然后是1角币，5分币，以及1分币。这种贪婪算法使用最少数目的硬币找零钱。<strong>贪婪算法主要的问题在于，该算法并不是总能够成功的</strong>。例如添加一个12分的货币，若找还15分零钱时，它给出的答案是一个12分和3个1分，然而并不是最优解一个一角和一个5分。<br>该算法需要一个表来表示其初识配置，如下所示：<br><img src="https://i.loli.net/2020/04/08/32aMeKm1OgzNiX7.png" alt=""><br>这里假设开始顶点为v1，所以只有v1到开始顶点距离为0，其余都为无穷，第一个选择v1。然后表变为：<br><img src="https://i.loli.net/2020/04/08/NTqyhQUmj3S5l91.png" alt=""><br><strong>v1变为已知，v2和v4与v1是邻接点，因此有路径长度2和1，其余不是邻接点，仍为无穷</strong>。这时比较1最小，选择v4，调整表得：<br><img src="https://i.loli.net/2020/04/08/4MxwTDSrvs2iNHR.png" alt=""><br>不停的循环下去，直到得到所有。<br>算法代码如下：  </p>
<pre><code>const int INF=10000;
void dijkstra(int n,int s,vector&lt;vector&lt;int&gt;&gt; &amp;G,vector&lt;bool&gt; &amp;vis,vector&lt;int&gt; &amp;d,vector&lt;int&gt; &amp;pre) 
        //顶点数，初始点，图，标记是否被访问，到每个点的最短距离，路径上的前驱顶点 
{
    d[s]=0;
    for(int i=0;i&lt;n;i++)
    {
        int u=-1;
        int MIN=INF;
        for(int j=0;j&lt;n;j++)
        {
            if(vis[j]==false&amp;&amp;d[j]&lt;MIN)                 //找到d[u]最小的u 
            {
                u=j;                                   
                MIN=d[j];
            }
        }
        if(u==-1)                               //找不到说明剩下的顶点和s不连通 
        {
            return;
        }
        vis[u]=true;                       //将找到的u表示为已被访问 
        for(int m=0;m&lt;n;m++)           //对剩下未被访问并且u能到达的点进行距离优化 
        {
            if(vis[m]==false&amp;&amp;d[u]+G[u][m]&lt;d[m])
            {
                d[m]=d[u]+G[u][m];
                pre[m]=u;                               //并将m点的前驱顶点u记录 
            }
        }
    }    
}
void DFSPrint(int s,int v,vector&lt;int&gt; pre)        //利用递归将前驱打印出来即为路径 
{
    if(s==v)
    {
        cout&lt;&lt;s&lt;&lt;&quot; &quot;;
    }
    else
    {
        DFSPrint(s,pre[v],pre);
        cout&lt;&lt;v&lt;&lt;&quot; &quot;;
    }
}
int main()
{
    int n=6;
    vector&lt;int&gt; d(n);
    vector&lt;int&gt; pre(n);
    vector&lt;bool&gt; vis(n);
    vector&lt;vector&lt;int&gt;&gt; G{{0,1,INF,4,4,INF},{INF,0,INF,2,INF,INF},{INF,INF,0,INF,INF,1},{INF,INF,2,0,3,INF},{INF,INF,INF,INF,0,3},{INF,INF,INF,INF,INF,0}};
    for(int i=0;i&lt;n;i++)
    {
        d[i]=INF;
        pre[i]=i;
    }
    dijkstra(n,0,G,vis,d,pre);
    for(auto x:d)                         //将初始点到每个点的最短路径长打印出来 
    {
        cout&lt;&lt;x&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    DFSPrint(0,5,pre);       //打印出最短路径
    return 0;
}</code></pre><p>可以看到，<strong>关键点在于找到距离最小的顶点，并对与其相邻的顶点进行距离优化，将该顶点记录</strong>。在打印最短路径顶点时利用了<strong>递归</strong>，这是因为<code>pre</code>中存放的是前驱顶点。<br>对该算法时间复杂度进行分析，可以看到在最外围循环里有两个小循环，但这两个循环没有交叉，因此时间复杂度为O(n^2)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2020/04/07/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>摘要：前面讲过了图的基本知识，本篇将会讲解有关拓扑排序和关键路径的知识。拓扑排序是在无环图中的应用，本篇也会介绍如何用算法求得一个图的拓扑序列。</p>
<a id="more"></a>
<p>在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，称为AOV网。AOV网中的弧表示活动之间存在的某种制约关系。正如在拍戏过程中，只有演员确定好了，场地也确定好了，才能够开始拍摄。<br>设G=（V,E）是一个具有n个顶点的有向图，V中的顶点序列v1,v2…vn满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在vj之前。则我们称这样的顶点序列为一个拓扑序列。<br>显然<strong>拓扑排序是没有圈</strong>的，因为对于圈上的两个顶点vi和vj，vi先于vj同时vj又先于vi，这是不合理的。同时，拓扑排序不是唯一的，任何合理的排序都是可以的。所谓拓扑排序，就是对一个有向图构造拓扑序列的过程。<br>一个简单的求拓扑排序的算法是先找出任意一个没有入边的顶点。然后显示出该顶点，并将它和它的边一起删除，然后对其余的继续应用该方法。如下所示的图：<br><img src="https://i.loli.net/2020/04/07/oPZ7LeTu3Qm4GWc.png" alt=""><br>V1的入度为0，将其和它的边删除：<br><img src="https://i.loli.net/2020/04/07/BtvGaoOIEweqpM3.png" alt=""><br>这时v2的入度为0，同样删除得：<br><img src="https://i.loli.net/2020/04/07/dOcYCbqlzApTaXD.png" alt=""><br>v5的入度又变成了0：<br><img src="https://i.loli.net/2020/04/07/bwMXC5ya427ukrl.png" alt=""><br>v4入度变为0：<br><img src="https://i.loli.net/2020/04/07/cOLBwvgVK6ozWsY.png" alt=""><br>v3，v7的入度都是0，选择一个即可：<br><img src="https://i.loli.net/2020/04/07/8AUDKmafEI3RoCM.png" alt=""><br>v7也删除，只剩下了v6：<br><img src="https://i.loli.net/2020/04/07/lpqJguBXbKrHC5k.png" alt=""><br>因此得到的一个拓扑序列为：v1，v2，v5，v4，v3，v7，v6。<br>在算法实现时，<strong>将图以邻接表或邻接矩阵的形式存放，计算每个顶点的入度，然后将入度为0的顶点放到一个队列中，再将队列中的顶点输出，并且每输出一个时，将与其相关的顶点的入度减1，若有顶点入度为0，放入队列中。最后判断输出顶点个数是否为总数，若相等，则拓扑排序成功</strong>。<br>具体代码如下（邻接表）：  </p>
<pre><code>class graph
{
    private:
        int n;
        list&lt;int&gt; *lst;                //邻接表 
        queue&lt;int&gt; q;              //入度为0的点进队
        vector&lt;int&gt; indegree;
    public:
        graph(int n,vector&lt;int&gt; v);            //构造函数初始化 
        void add(int v,int u);     //添加边
        bool topsort();          //拓扑排序 
};
graph::graph(int n,vector&lt;int&gt; v)
{
    this-&gt;n=n;
    lst=new list&lt;int&gt;[n];
    indegree=v;
} 
void graph::add(int v,int u)
{
    lst[v].push_back(u);            //v指向u，将u放在v的后面，并且u的入度加1 
    indegree[u]++;
}
bool graph::topsort()
{
    for(int i=0;i&lt;n;i++)
    {
        if(indegree[i]==0)
        {
            q.push(i);
        }
    }
    int count=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        cout&lt;&lt;x&lt;&lt;&quot; &quot;;
        list&lt;int&gt;::iterator i;
        for(i=lst[x].begin();i!=lst[x].end();i++)
        {
            indegree[*i]--;
            if(indegree[*i]==0)
            {
                q.push(*i);
            }    
        }
        count++;
    }
    if(count==n)
    {
        return true;
     } 
    else
    {
        return false;
    }
}
int main()
{
    vector&lt;int&gt; v(7);
    graph g(7,v);
    g.add(0,1);
    g.add(0,3);
    g.add(0,2);
    g.add(1,3);
    g.add(1,4);
    g.add(2,5);
    g.add(3,2);
    g.add(3,5);
    g.add(3,6);
    g.add(4,3);
    g.add(4,6);
    g.add(6,5);
    if(g.topsort())
    {
        cout&lt;&lt;&quot;拓扑排序成功&quot;; 
    }
    else
    {
        cout&lt;&lt;&quot;拓扑排序失败&quot;;
    }
    return 0;
}</code></pre><p>邻接矩阵实现的代码为： </p>
<pre><code>class graph
{
    private:
        int n;
        vector&lt;vector&lt;int&gt;&gt; G;            //邻接矩阵 
        queue&lt;int&gt; q;              //入度为0的点进队
        vector&lt;int&gt; indegree;
    public:
        graph(int n,vector&lt;vector&lt;int&gt;&gt; G1,vector&lt;int&gt; v);    //构造函数初始化 
        void add(int v,int u);     //添加边
        bool topsort();          //拓扑排序 
};
graph::graph(int n,vector&lt;vector&lt;int&gt;&gt; G1,vector&lt;int&gt; v)
{
    this-&gt;n=n;
    G=G1;
    indegree=v;
} 
void graph::add(int v,int u)
{
    G[v].push_back(u);            //v指向u，将u放在v里面，并且u的入度加1 
    indegree[u]++;
}
bool graph::topsort()
{
    for(int i=0;i&lt;n;i++)
    {
        if(indegree[i]==0)
        {
            q.push(i);
        }
    }
    int count=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        cout&lt;&lt;x&lt;&lt;&quot; &quot;;
        for(int i=0;i&lt;G[x].size();i++)
        {
            int v=G[x][i];
            indegree[v]--;
            if(indegree[v]==0)
            {
                q.push(v);
            }    
        }
        count++;
    }
    if(count==n)
    {
        return true;
     } 
    else
    {
        return false;
    }
}
int main()
{
    vector&lt;int&gt; v(7);
    vector&lt;vector&lt;int&gt;&gt; G1(7);
    graph g(7,G1,v);
    g.add(0,1);
    g.add(0,3);
    g.add(0,2);
    g.add(1,3);
    g.add(1,4);
    g.add(2,5);
    g.add(3,2);
    g.add(3,5);
    g.add(3,6);
    g.add(4,3);
    g.add(4,6);
    g.add(6,5);
    if(g.topsort())
    {
        cout&lt;&lt;&quot;拓扑排序成功&quot;; 
    }
    else
    {
        cout&lt;&lt;&quot;拓扑排序失败&quot;;
    }
    return 0;
} </code></pre><p>在上面的AOV网中，若有向边上是有权值的，称之为AOE网。<br>路径上各个活动所持续的时间之和称为路径长度，从<strong>源点到汇点具有最大长度的路径叫关键路径</strong>，在关键路径上的活动叫关键活动。<br><img src="https://i.loli.net/2020/04/07/ypsTHxLc3KlEwmG.png" alt=""><br><strong>改变关键路径上的关键活动时间，才能提高效率</strong>。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>图的基本知识</title>
    <url>/2020/04/04/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>摘要：本篇开始将进入图这一数据结构的学习。图与前面所学的表和树有很大的不同，它的概念也比较多，因此在本篇中将主要介绍图的基本知识，便于后续学习。</p>
<a id="more"></a>
<p>线性表中数据元素是线性关系，都是只有一个直接前驱和直接后继，在树中数据之间有着明显的层次关系。图是一种比线性表和树更复杂的数据结构。在图形结构中，结点之间的关系可以是任意的，图中任意两个元素之间都可能相关。<br>图是由顶点的有穷非空集合和顶点之间的边的集合组成，通常表示为：G（V，E），其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。<br><img src="https://i.loli.net/2020/04/04/dO2chfXDGRHWtrC.png" alt=""><br>线性表中数据元素叫元素，树中则叫结点，而在图中叫顶点。有空表和空树，但是没有空图这个概念，即<strong>在图结构中，不允许没有顶点</strong>。顶点之间的逻辑关系用边来表示。<br>下面来讲解图的一些基本概念：<br>无向边是指两个顶点之间的边没有方向，(vi,vj)表示。任意的边都是无向边的图为无向图，如下所示。<br><img src="https://i.loli.net/2020/04/04/zLnTRXp8hIO64la.png" alt=""><br>有向边则是两个顶点之间的边有方向，也称为弧。&lt;vi,vj&gt;表示，其中vi称为弧尾，vj称为弧头。任意的边都是有向边的图为有向图，如下所示，A,D之间的边为&lt;A,D&gt;。<br><img src="https://i.loli.net/2020/04/04/wevfVTSqCX4NsK1.png" alt=""><br><strong>不存在顶点到自身的边，且同一条边不重复出现的图称为简单图</strong>，我们后面要学习的基本都是简单图。<br>在无向图中，如果任意两个顶点之间都存在边，则称为无向完全图。<br><img src="https://i.loli.net/2020/04/04/4ykQCLNx9uBY6Rf.png" alt=""><br>根据无向完全图的定义可得，N个顶点，共有<code>N*(N-1)/2</code>条边。<br>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称为有向完全图。<br><img src="https://i.loli.net/2020/04/04/SzKFP41e528sdGX.png" alt=""><br>根据有向完全图的定义可得，N个顶点，共有<code>N*(N-1)</code>条边。<br>与图的边或弧相关的数叫做权。这种带权的图通常称为网。权可以表示一个顶点到另一个顶点的距离或耗费。如下所示：<br><img src="https://i.loli.net/2020/04/04/9vSt6xuVFaQLjHs.png" alt=""><br>如果一个图的顶点和边都是另一个图的顶点和边的集合的子集，则这个图为另一个图的子图。如下所示，右边的图为左边图的子图。 </p>
<p><img src="https://i.loli.net/2020/04/04/x4bEis1f5HeGtoC.png" alt="">  </p>
<p>顶点V的度是和V相关联的边的数目。在有向图中，以顶点v为头的弧的数目称为v的入度，以顶点v为尾的弧的数目称为v的出度。<strong>V的度等于出度与入度之和</strong>。<br>路径的长度是路径上边或弧的数目。到自身的路径为回路，<strong>回路中各顶点只出现一次的叫简单回路</strong>。<br>如果图中任意两个顶点都是连通的（即有路径从一个顶点到另一个顶点），则为连通图。下图左边不是连通图，右边是。<br><img src="https://i.loli.net/2020/04/04/qt9gScJzkow1Xj4.png" alt=""><br>一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边。如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一棵有向树。一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。如下图1的生成森林为图2和图3。<br><img src="https://i.loli.net/2020/04/04/kFPYGCHnBXjm41c.png" alt="">  </p>
<h2 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>图由顶点和边或弧两部分组成。合在一起比较困难，用两个结构来存储。<br>图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中边或弧的信息。设图G有n个顶点，则邻接矩阵是一个n*n的方阵。<br><img src="https://i.loli.net/2020/04/04/NeokVxmsgj7ptnO.png" alt=""><br><img src="https://i.loli.net/2020/04/04/oB5YhnTDV9IuRld.png" alt=""><br><img src="https://i.loli.net/2020/04/04/sSx1tyDhW8pTeFE.png" alt=""><br>邻接矩阵对于边数相对顶点较少的图，对空间会很大浪费。  </p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>参考树的孩子表示法。<br>数组与链表相结合的存储方法称为邻接表。<br><img src="https://i.loli.net/2020/04/04/CTOmN4fAkzD6cbE.png" alt=""><br>在有向图中，若以顶点为弧尾来存储，则为邻接表（方便查找出度）。若以顶点为弧头来存储，为逆邻接表（方便查找入度）。<br><img src="https://i.loli.net/2020/04/04/j2WgFEHeclQYSLr.png" alt="">  </p>
<h3 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h3><p>边集数组由两个一维数组组成。一个存储顶点的信息，一个存储边的信息。<br><img src="https://i.loli.net/2020/04/04/N3Dxs8krFKaZXQq.png" alt="">  </p>
<p>此外，还有将邻接表与逆邻接表结合，既能得到出度又能得到入度的十字链表表示法，以及对无向图邻接表进行优化的邻接多重表表示法等。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法4</title>
    <url>/2020/04/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%954/</url>
    <content><![CDATA[<p>摘要：本篇是排序算法的最后一篇，将主要讲解基于常数时间运行的桶排序和基数排序，以及外部排序算法。到此就对排序算了进行了一个完整的讲解，不同的排序算法有不同的特点。</p>
<a id="more"></a>
<p>前面讲过的排序算法的时间复杂度最好达到了O（nlogn)。下面将介绍两种达到时间常数的算法，但它们有着特定的局限性。</p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序要求输入的元素A1、A2、…、An必须由只小于M的正整数构成，这样使用一个大小为M的数组count，它被初始化成全0。相当于有M个桶，初始时这些桶全为空，当读入Ai时，count[Ai]就加1。读入完后，将数组中排序好的打印出来即可。例如2，5，3，2，7，4。可以看到他们都小于8，建立一个大小为8的初始为0的数组count，读入2时，count[2]变为1，这样count[5]、count[3]、count[7]、count[4]全为1，而count[2]为2，按照count中元素的大小，0不读取，1读取一次，2读取2次，来读取下标并输出。可得2，2，3，4，5，7。<br><img src="https://i.loli.net/2020/04/04/DAgh1eGf8SbLOpV.png" alt=""><br>桶排序的实现代码为：  </p>
<pre><code>void bucketsort(vector&lt;int&gt; &amp;v,vector&lt;int&gt; &amp;temv)
{
    int tem;
    for(int i=0;i&lt;v.size();i++)
    {
        tem=v[i];
        temv[tem]++;
    }
    for(int j=0;j&lt;temv.size();j++)
    {
        while(temv[j]!=0)
        {
            cout&lt;&lt;j&lt;&lt;&quot; &quot;;
            temv[j]--;
        }
    }
}
int main()
{
    vector&lt;int&gt; v{2,5,3,2,7,4};
    vector&lt;int&gt; temv(10);
    bucketsort(v,temv);
    return 0;    
} </code></pre><p>尽管桶排序看似太一般而用处不大，但是实际上却存在很多其输入只是一些小的整数的情况。这样使用快排这些排序算法就小题大做了。  </p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是对桶排序的升级。基数排序也称为卡片排序，假设有10个0~999范围内的数，对其进行排序，显然不能使用桶排序，那样桶太多了。怎么改进呢？按照位数来排序，比如先按个位数大小进行一次桶排序，再按十位数大小，最后百位数大小排序。如下所示：<br><img src="https://i.loli.net/2020/04/04/nClFe9XSgzNi75b.png" alt=""><br><strong>需要注意这里与桶排序不同的地方在于，桶中存放的不再是个数，而是元素值，并且有可能一个桶有多个元素（个位数相同），因此桶定义成二维数组的类型</strong>。<br>基数排序的实现代码为：</p>
<pre><code>void radixsort(vector&lt;int&gt; &amp;v,vector&lt;vector&lt;int&gt;&gt; &amp;temv)
{
    int tem;
    int s=1;
    for(int m=1;m&lt;4;m++)
    {
        for(int i=0;i&lt;v.size();i++)
        {
            tem=v[i]/s;
            temv[tem%10].push_back(v[i]);
        }
        int idx=0;
        for (auto &amp; thisBucket : temv)                            
        {    
            for (int &amp;s : thisBucket)    
            {        
                v[idx++] = std::move(s);
            }
            thisBucket.clear();        
        }
        s=s*10;
    }
}
int main()
{
    vector&lt;int&gt; v{202,105,314,202,745,423};
    vector&lt;vector&lt;int&gt;&gt; temv(10);
    radixsort(v,temv);
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;    
} </code></pre><p>可以看到，<strong>在对二维数组temv进行搜索时，使用C++ 11新特性中的基于范围的for循环以及move语句</strong>，这提供了很大方便。<br>基数排序还有一种为计数基数排序，计数排序中依然保留了桶中装元素的个数，它的关键点在于每一次排序后将数组还原，这就需要探索<strong>桶中元素值的序号与原始数组的对应关系</strong>，再用临时的数组把每一次排序后的结果存储。<br><strong>基数排序也可用于字符串的排序</strong>，它的时间复杂度为O(n)。</p>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><p>前面讲过的算法都需要将输入数据装进内存，然而，存在一些应用程序，它们的输入数据量太大装不进内存。因此就有了外部排序算法来解决数据量很大的输入。<br>基本的外部排序算法是使用归并排序中的合并算法。设有4盘磁带，Ta1、Ta2、Tb1、Tb2。其中两盘用来输入，两盘用来输出。设数据最初在Ta1盘上，内存一次容纳M个记录。一种自然的做法就是从输入磁带一次读入M个记录，在内部排序，然后再输出，我们把每组排过序的记录叫做一个顺串。如下所示，设M=3。<br><img src="https://i.loli.net/2020/04/04/6NaKq5ISVzeLPfk.png" alt=""><br>构造顺串放入磁盘后为：<br><img src="https://i.loli.net/2020/04/04/AFW23MLdvaS1Now.png" alt=""><br>然后将顺串合并：<br><img src="https://i.loli.net/2020/04/04/QyArBkYhLJdS6HK.png" alt=""><br>上述为2路合并的情况，如果有多余的磁带，那么可以扩充成<strong>k路合并</strong>来减少将输入数据排序所需的趟数。  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法3</title>
    <url>/2020/04/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%953/</url>
    <content><![CDATA[<p>摘要：本篇主要讲解快速排序算法并对前面讲的所有的排序算法进行一个总结。快速排序一直是实践中已知最快的排序算法，只有对它进行了深入学习才算是真正的学了排序算法。后序还有其他算法如桶排序、基数排序和外部排序算法等，将在下一篇中进行讲解。</p>
<a id="more"></a>
<p>快速排序算法被列为20世纪十大算法之一。快速排序与归并排序一样，也是用了分而治之的思想。快速排序的基本思想是通过一趟排序将待排记录分割成独立的两部分，其中一部分的关键字均比另一部分小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。<br>它的技巧是：<br>将某个数当作分割元素，从第二个数开始，向右寻找大于等于第一个数的数，从最后一个数开始，向左寻找小于等于第一个数的数，直到它们交叉，并将分割元素与最终这两个数里较小的交换位置。<br><strong>快排算法的每一步都相当于将一个数归位。迭代n次，最终将所有数归位。</strong><br>将选取的分割元素称为枢纽元，如下所示，选择第一个元素50为枢纽元，然后从10往后，20往前寻找比50小和大的数，10比50小，跳过，90比50大，选择90，另一边选择20，然后将20与90交换，继续寻找，这样一边下来可以将数组分为比50大的一组和比50小的一组。再在子数组中快排。<br><img src="https://i.loli.net/2020/04/02/igLIY1XvQEUa3jR.png" alt=""><br>下面直接来看实现代码：  </p>
<pre><code>template&lt;class T&gt;
void quicksort(vector&lt;T&gt; &amp;v,int left,int right)
{
    if(left&lt;right)
    {
        int pivot;
        pivot=qsort(v,left,right);
        quicksort(v,left,pivot-1);
        quicksort(v,pivot+1,right);
    }
} 
template&lt;class T&gt;
int qsort(vector&lt;T&gt; &amp;v,int left,int right)
{
    int pivotkey;
    T tem;
    pivotkey=left;
    while(left&lt;right)
    {
        left=left+1;
        while(left&lt;right&amp;&amp;v[left]&lt;v[pivotkey])
        {
            left++;
        }
        while(left&lt;right&amp;&amp;v[right]&gt;v[pivotkey])
        {
            right--;
        }
        tem=v[right];
        v[right]=v[left];
        v[left]=tem;
    }
    if(v[left]&gt;v[pivotkey])
    {
        tem=v[left-1];
        v[left-1]=v[pivotkey];
        v[pivotkey]=tem;
        return left-1;
    }
    else
    {
        tem=v[left];
        v[left]=v[pivotkey];
        v[pivotkey]=tem;
        return left;
    }
}
int main()
{
    vector&lt;int&gt; v{2,5,1,8,6,4,7};
    quicksort(v,0,v.size()-1);
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>代码中主要包含函数<code>quicksort()</code>和它调用的函数<code>qsort()</code>，<code>qsort()</code>的功能是选择枢纽元，将数组排序成小于枢纽元、枢纽元、大于枢纽元的三部分，然后返回枢纽元。而<code>quicksort()</code>则是通过递归不断调用排序，最终实现整体排序。<strong>其中有一些细节地方需要注意，比如临界情况、枢纽元最终位置等</strong>。<br>对其时间复杂度进行分析，显然与枢纽元的选择有关。如果每次选择的数都偏中间，就如同平衡二叉树一样，得到<strong>最佳的时间复杂度为O(nlogn)，但如果选择的枢纽元为两端值，则时间复杂度能达到O(n^2)。但是快速排序的平均时间复杂度为O(nlogn)</strong>。因此，快速排序法的执行速度和分割元素所在的位置有密切的关系。当分割最平均时，快速排序执行的最快，相反则最慢。  </p>
<h2 id="快排的优化"><a href="#快排的优化" class="headerlink" title="快排的优化"></a>快排的优化</h2><p>首先就是对枢纽元的选择进行优化。<strong>常见的选择是将第一个元素当作枢纽元，但是这是错误的方式</strong>。如果输入是随机的还能接受，如果是预排序或者反序的，时间复杂度可能达到O(n^2)。比较好的方法是随机选取，或者<strong>三数中值法，即比较首位、末位和中间元素大小，选择中位数来当枢纽元</strong>。<br>下面是三数中值法的代码，只需要对<code>qsort()</code>函数进行修改。  </p>
<pre><code>int pivotkey;
T tem;
int center;                       //三数中值法 
center=(left+right)/2;
if(v[left]&gt;v[right])
{
    tem=v[right];
    v[right]=v[left];
    v[left]=tem;
}
if(v[center]&gt;v[right])
{
    tem=v[right];
    v[right]=v[center];
    v[center]=tem;
}
if(v[center]&gt;v[left])
{
    tem=v[left];
    v[left]=v[center];
    v[center]=tem;
}
pivotkey=left;</code></pre><p>通过三次比较大小，就将中位数移动到了最左边，然后令枢纽元为最左边的元素即可。<br>另一个优化的地方就是对递归的优化，之前已经讲解过，迭代的性能比递归要好，因此可以将递归改换成迭代。  </p>
<p>到此已经讲了7种排序算法，这7种全部都是内部排序，希尔排序相当于插入排序的升级，堆排序相当于选择排序的升级，而快速排序则是前面认为最慢的冒泡排序的升级。<br><img src="https://i.loli.net/2020/04/02/dpiu2K1kPCDnTeL.png" alt=""><br>从平均情况来看，显然最后3种算法要胜过希尔排序，并远远胜过前3种。但是从最好情况来看，冒泡排序更胜一筹，因此使用哪种算法是不固定的，需要具体情况来分析。没有十全十美的算法。  </p>
<p>在下一篇中将会讲解桶排序和基数排序，它们的时间复杂度甚至能达到O(n），但是限制条件是很大的，需要我们了解，同时外部排序的知识也会简单讲解。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法2</title>
    <url>/2020/03/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%952/</url>
    <content><![CDATA[<p>摘要：本篇将继续对排序算法进行介绍，上一篇讲解了3种基本算法和希尔排序算法，本篇将介绍堆排序和归并排序，而最后一种快速排序将在下一篇中进行介绍。堆排序和归并排序的时间复杂度都为O(nlogn)，它们各有特点，都有很高的效率。</p>
<a id="more"></a>
<p>本篇将会介绍时间复杂度达到O(nlogn)的两种算法堆排序和归并排序。  </p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>前面已经学习过二叉堆的知识，堆排序利用二叉堆的性质，根结点为最大值，将其与最后一个元素互换位置，再去掉最后一个元素，对剩下元素重新构建成二叉堆。这样就能实现排序。<br><img src="https://i.loli.net/2020/03/31/c8SYT4BhKsGUpuj.png" alt=""><br>如上面所示的二叉堆，根结点为97最大值，将其与最后一个元素31互换位置。然后对去掉97的这些结点重新构建二叉堆，如下图。<br><img src="https://i.loli.net/2020/03/31/8OLsNWwXEDAhbtg.png" alt=""><br>这样再把59拿出来，一直下去就可以实现堆排序了。<br>具体实现代码就是对前面二叉堆的代码进行了简单修改：</p>
<pre><code>template&lt;class T&gt;
void buildheap(vector&lt;T&gt; &amp;v)
{
    for(int i=v.size()/2-1;i&gt;=0;i--)
    {
        adjust_heap(v,i,v.size());
    }
    for(int j=v.size()-1;j&gt;0;j--)
    {
        T tem=v[j];
        v[j]=v[0];
        v[0]=tem;
        adjust_heap(v,0,j);
    }
}
template&lt;class T&gt;
void adjust_heap(vector&lt;T&gt; &amp;v,int i,int n)
{
    T tem;
    if(2*i+1&lt;n&amp;&amp;v[2*i+1]&gt;v[i])
    {
        tem=v[i];
        v[i]=v[2*i+1];
        v[2*i+1]=tem;
        adjust_heap(v,2*i+1,n);
    }
    if(2*i+2&lt;n&amp;&amp;v[2*i+2]&gt;v[i])
    {
        tem=v[i];
        v[i]=v[2*i+2];
        v[2*i+2]=tem;
        adjust_heap(v,2*i+2,n);
    }
}
int main()
{
//    vector&lt;int&gt; v{2,5,1,8,6,4,7};
    vector&lt;double&gt; v{2.55,2.35,1.7,-8,6.3,7.4,7.4};
    buildheap(v);
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>从代码中可以看到，在构建了二叉堆以后，将最后一个元素与根结点交换位置，然后去掉最后一个元素重构二叉堆，直到所有元素排序完成。运行结果为：<br><img src="https://i.loli.net/2020/03/31/7tq8e61bTXRDSwW.png" alt=""><br>对其时间复杂度进行分析，<strong>整个构建堆的时间复杂度为O(n)，每次取记录重建的时间复杂度为O(nlogn)，所以总体的时间复杂度为O(nlogn)</strong>。它在性能上远远好于前面讲过的简单算法。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并在数据结构中的定义是将两个或两个以上的有序表合成一个新的有序表。分而治之的思想。将一个数组分为两部分，对两部分分别排序，然后归并。子数组同时也是这样递归进行的。<br><img src="https://i.loli.net/2020/03/31/VSu5IWP4TmOpdlG.png" alt=""><br>在合并时，如下所示：<br><img src="https://i.loli.net/2020/03/31/uAq8Tc6nNLMbJR3.png" alt=""><br>A和B中的较小者被复制到C中，另一个则与较小者的下一个元素比较，直到一个表复制完后，将另一个表中剩余部分复制到C中。如1与2先比较，1较小复制到C中第一个位置上，然后2再与13比较，将2复制到第二个位置上…。<br>归并排序的实现代码为：  </p>
<pre><code>template&lt;class T&gt;
void mergesort(vector&lt;T&gt; &amp;v)
{
    vector&lt;T&gt; tem(v.size());
    msort(v,tem,0,v.size()-1);
}
template&lt;class T&gt;
void msort(vector&lt;T&gt; &amp;v,vector&lt;T&gt; &amp;tem,int left,int right)
{
    if(left&lt;right)
    {
        int center=(left+right)/2;
        msort(v,tem,left,center);
        msort(v,tem,center+1,right);
        merge(v,tem,left,center+1,right);
    }
}
template&lt;class T&gt;
void merge(vector&lt;T&gt; &amp;v,vector&lt;T&gt; &amp;tem,int left,int center1,int right)
{
    int leftpos=left;
    int leftend=center1-1;
    int rightpos=center1;
    int tempos=leftpos;
    int num=right-left+1;
    while(leftpos&lt;=leftend&amp;&amp;rightpos&lt;=right)
    {
        if(v[leftpos]&lt;=v[rightpos])
        {
            tem[tempos]=v[leftpos];
            tempos++;
            leftpos++;    
        }
        else
        {
            tem[tempos]=v[rightpos];
            tempos++;
            rightpos++;
        }
    }
    while(leftpos&lt;=leftend)
    {
        tem[tempos]=v[leftpos];
        tempos++;
        leftpos++;
    }
    while(rightpos&lt;=right)
    {
        tem[tempos]=v[rightpos];
        tempos++;
        rightpos++;
    }
    for(int i=0;i&lt;num;i++,--right)
    {
        v[right]=tem[right];
    }
}
int main()
{
    vector&lt;int&gt; v{2,5,1,8,6,4,7};
    mergesort(v);
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>可以看到，代码略微有些复杂，主要包括3个函数，总体函数<code>mergesort()</code>、分割函数<code>msort()</code>和合并函数<code>merge()</code>。总体的流程如最上面的图所示，<strong>先是不停的分割直到分割成两位或1位为止，然后对其合并，直到最后合并成一个完整有序数组</strong>。合并过程上面也已经介绍过，主要有3种情况进行判断。<br>归并排序的最坏情形时间运行为O(nlogn)，它比较占用内存，但是效率高且稳定。  </p>
<p>在下一篇将会介绍快速排序，它是非常常见而且很重要的一种排序算法。  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法1</title>
    <url>/2020/03/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%951/</url>
    <content><![CDATA[<p>摘要：排序是我们生活中经常会面对的问题。如果整个排序工作能够在主存中完成，为内部排序。如果不能在主存中完成而必须在磁盘上完成的排序为外部排序。我总共会介绍7种排序算法，本篇将会对其中4种排序算法介绍，冒泡排序、选择排序、插入排序、希尔排序。剩下的其他排序算法将会在下几篇中给出介绍。</p>
<a id="more"></a>
<p>7种排序算法，按照复杂度分为两类，冒泡、选择、插入排序属于简单算法，而希尔排序、堆排序、归并排序、快速排序属于改进算法。  </p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡是一种交换排序，它的基本思想就是两两相邻记录的元素，如果反序则交换，直到没有反序的为止。<br><img src="https://i.loli.net/2020/03/29/SjtJ3V45s8fx1kh.png" alt=""><br><strong>从后序开始，两两比较，将较小的数字如同气泡一样慢慢浮到上面，因此称其为冒泡算法</strong>。如上图所示，为i=1时，从最后一个元素2开始，与它相邻的元素比较交换，最终选择出了最小的元素1，交换到了最上面。它的优点在于2也被交换到了较上面。<br>冒泡排序实现代码如下：</p>
<pre><code>template&lt;class T&gt;
void bubblesort(vector&lt;T&gt; &amp;v)
{
    for(int i=0;i&lt;v.size();i++)
    {
        T tem;
        int j;
        for(j=v.size()-1;j&gt;i;j--)
        {
            if(v[j]&lt;v[j-1])
            {
                tem=v[j];
                v[j]=v[j-1];
                v[j-1]=tem;
            }
        }
    }
}
int main()
{
    vector&lt;int&gt; v{2,4,7,1,5,8,6};
    bubblesort(v);
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>将其写成了模板函数的形式，使用嵌套循环，从最后开始两两交换。对其时间复杂度进行分析，显然最坏的情况下，即<strong>逆序情况，需要进行n(n-1)/2次比较，因此时间复杂度为O(n^2)</strong>。  </p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>冒泡排序的思想是不断的比较交换，通过交换完成最终的排序，而选择排序则是通过n-i次的比较，选出关键字最小的元素并和第i个记录交换。即它们的区别在于比较的次数是一样多的，但选择排序交换的次数少。<br><img src="https://i.loli.net/2020/03/29/nhz7ioXbLGEw1KH.png" alt=""><br>上图为i=1时，即从9开始，对9以后的元素与9比较并找出最小值，然后把最小值与9交换。可以看到9之后的元素都比9小，选择其中最小的1交换。<br>选择排序实现代码为：  </p>
<pre><code>template&lt;class T&gt;
void selectsort(vector&lt;T&gt; &amp;v)
{
    for(int i=0;i&lt;v.size();i++)
    {
        T min=v[i];
        int j,p;
        for(j=i+1;j&lt;v.size();j++)
        {
            if(v[j]&lt;min)
            {
                min=v[j];
                p=j;
            }
        }
        v[p]=v[i];
        v[i]=min;
    }
}
int main()
{
    vector&lt;int&gt; v{2,4,7,1,5,8,6};
    selectsort(v);
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>可以看到，关键地方在于找到最小值，然后交换。对其时间复杂度进行分析，第i趟排序需要n-i次的比较，即总共n(n-1)/2比较次数，<strong>时间复杂度为O(n^2)。尽管与冒泡排序时间复杂度相同，但是选择排序性能上还是略优于冒泡排序</strong>。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序由n-1趟排序组成。对于p=0到p=n-1趟，<strong>插入排序保证从位置0到位置p上的元素为已排序状态</strong>。示例如下：<br><img src="https://i.loli.net/2020/03/29/vU5rdQFxshiflaN.png" alt=""><br>关键在于先找到要插入的位置，然后<strong>将受到影响的元素（插入位置之后的元素）全都向后移一位</strong>，后移操作即从最后开始每一个元素都等于上一个元素的值。插入位置的元素值替换为插入元素即可。重复n-1次。从上图可以看到，第3次插入时，将51插入到前面已排好序的元素中，找到它的位置为34之后，64之前，将其插入，64后移一位。<br>插入排序实现代码为：  </p>
<pre><code>template&lt;class T&gt;
void insertsort(vector&lt;T&gt; &amp;v)
{
    for(int i=0;i&lt;v.size();i++)
    {
        T tem;
        tem=v[i];
        int j;
        for(j=i;j&gt;0&amp;&amp;v[j-1]&gt;tem;j--)
        {
            v[j]=v[j-1];
        }
        v[j]=tem;
    }
}
int main()
{
    vector&lt;int&gt; v{2,4,7,1,5,8};
    insertsort(v);
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>对其时间复杂度进行分析，嵌套循环并且每个最大为n次，即<strong>时间复杂度为O(n^2)。插入排序比冒泡排序和选择排序性能要好一些</strong>。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序是D.L.Shell于1959年提出来的一种排序算法，在这之前的排序算法的时间复杂度基本上都是O(n^2)的，希尔排序算法是突破这个时间复杂度的第一批算法之一。<br>它通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟为止。希尔排序使用一个序列h1,h2,h3…，叫做增量序列。只要h1=1，任何增量序列都是可行的。在使用增量hk的一趟排序后，对于每一个i都有a[i]&lt;=a[i+hk]，所有相隔hk的元素都被排序。<br><img src="https://i.loli.net/2020/03/29/LxueIQMcbA23gpW.png" alt=""><br>如图，在增量为5时，从35开始往后，将其与前面和它相隔增量的元素比较交换，如35比81小，交换。17比94小，交换…。<strong>关键点在于当进行a[j]与a[j-hk]的交换后，还需要判断v[j-hk]是否还需要再与之前的元素进行交换</strong>。如在1排序时，首先28与12交换，变成了12，28，11…，这时对11进行交换时，它先与28交换，交换完之后还比12小，再次交换，变成11，12，28…。<br>希尔排序实现代码为：  </p>
<pre><code>template&lt;class T&gt;
void shellsort(vector&lt;T&gt; &amp;v)
{
    for(int i=v.size()/2;i&gt;0;i=i/2)
    {
        T tem;
        for(int j=i;j&lt;v.size();j++)
        {
            while(v[j]&lt;v[j-i])
            {
                tem=v[j];
                v[j]=v[j-i];
                v[j-i]=tem;
                if(v[j-i]&lt;v[j-2*i]&amp;&amp;j-2*i&gt;=0)
                {
                    j=j-i;
                }
            }
        }
    }
}
int main()
{
    vector&lt;int&gt; v{2,4,7,1,5,8};
    shellsort(v);
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>虽然代码中有很多循环，但是最大并不是进行n次的，实际上，<strong>希尔排序的时间复杂度与选择的增量序列有关</strong>。而这个增量序列是我们自己选择的，如在代码中我选择增量最大为数组长度的一半，然后每次减小一半，直到变为1。<strong>一种比较好的选择方式是1，3，7…，2^k-1，时间复杂度为O(n^3/2)</strong>。这突破了传统的O(n^2)。</p>
<p>本篇就先介绍这4种排序算法，其中冒泡、选择、插入都是简单算法，时间复杂度为O(n^2)。希尔排序则进行改进，达到了O(n^3/2)。在下篇中将介绍算法时间复杂度变成了O(nlogn)。性能更加优化。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>优先队列（堆）</title>
    <url>/2020/03/22/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88%E5%A0%86%EF%BC%89/</url>
    <content><![CDATA[<p>摘要：本篇将会简单介绍一下优先队列和堆的知识。通过本篇的介绍，大家也会对前面STL所学的优先级队列有更深的认识。堆是一种特殊的数据结构，它用来实现优先队列是最有效率的。本篇主要介绍什么是优先队列和堆，以及堆的基本操作。</p>
<a id="more"></a>
<p>前面在C++ STL的容器迭代器中讲过优先级队列。优先队列与一般队列不同的地方在于，一般队列都是先进先出的，而优先队列中优先级高的元素放在队头。举个例子，我们把作业发送到打印机中，按照一般的队列则一个个去完成这些作业。但若有一项作业特别重要，因此希望打印机先处理这项作业，就需要有优先级的概念。<br>优先队列最少具有两个功能：插入和删除最小的元素。<br>优先队列（priority queue）实现方法可以有很多种，如用链表、二叉查找树等，但这样要么增加查找时间，要么使功能过于复杂，因此靠堆（heap）这一数据结构来实现最为方便。<br>这里的堆指的都是二叉堆。<strong>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</strong>。<br><img src="https://i.loli.net/2020/03/22/X1kHNAKTGzuVOwI.png" alt="">  </p>
<h2 id="基本的堆操作"><a href="#基本的堆操作" class="headerlink" title="基本的堆操作"></a>基本的堆操作</h2><p>下面讲解以小顶堆为例。  </p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><strong>为将一个元素X插入堆中，我们在下一个可用位置创建一个空穴，否则堆将不是完全树</strong>。如果X可以放在该空穴中而不破坏堆的序，则插入完成。否则，就把空穴的父结点上的元素移入该空穴中，空穴就向上进了一步，继续该过程直到X能放入空穴为止。如下为将25插入堆中的例子，25比31小，所以空穴与31换位置，25还比21大，满足条件。将25放入空穴即可。<br><img src="https://i.loli.net/2020/03/22/vhQFtwcS5uAefOD.png" alt="">  </p>
<h3 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h3><p><strong>删除以类似插入的方式处理</strong>。找出最小值是很简单的，根据堆的性质，即为根结点。删除的时候，用空穴代替根结点，由于少了一个元素，因此堆中最后一个元素X必须移动到该堆的某个地方。如果X能被放在空穴中，则删除完成，不过这一般不可能，因此将空穴的两个儿子中较小者移入空穴，这样空穴就往下推了一层，重复直至X能放入空穴。下面为一个删除的例子，删除了13后用空穴代替，31就要移动，但31不能放入空穴中，将空穴较小的孩子14与空穴交换，31还是不满足性质不能放入空穴，继续与19交换、26交换，最终31放入空穴中。<br><img src="https://i.loli.net/2020/03/22/e1mbwYZMNtBvXsG.png" alt=""><br><img src="https://i.loli.net/2020/03/22/nyO6kVwIKc2ZTNq.png" alt=""><br><img src="https://i.loli.net/2020/03/22/DGNxuQsBXU8EIWF.png" alt="">  </p>
<p>关于堆的实现代码如下所示：</p>
<pre><code>template&lt;class T&gt;
void buildheap(vector&lt;T&gt; &amp;v)
{
    for(int i=v.size()/2-1;i&gt;=0;i--)
    {
        adjust_heap(v,i,v.size());
    }
}
template&lt;class T&gt;
void adjust_heap(vector&lt;T&gt; &amp;v,int i,int n)
{
    T tem;
    if(2*i+1&lt;n&amp;&amp;v[2*i+1]&gt;v[i])
    {
        tem=v[i];
        v[i]=v[2*i+1];
        v[2*i+1]=tem;
        adjust_heap(v,2*i+1,n);
    }
    if(2*i+2&lt;n&amp;&amp;v[2*i+2]&gt;v[i])
    {
        tem=v[i];
        v[i]=v[2*i+2];
        v[2*i+2]=tem;
        adjust_heap(v,2*i+2,n);
    }
}
int main()
{
    vector&lt;int&gt; v{2,5,1,8,6,4,7};
    buildheap(v);
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>可以看到，代码中包含两个函数<code>buildheap()</code>和<code>adjust_heap()</code>，根据二叉堆的特点，当我们对其进行调整时，只需要调整<strong>非叶节点</strong>即可，而二叉堆是完全二叉树，所以非叶节点的个数为结点总数除以2再减一（根结点从零开始），调整过程中，判断该结点的左孩子或右孩子是否大于该结点，若有比该结点大的，交换。<strong>需要注意的时，当交换以后还需要再次进行判断交换完的结点是否满足二叉堆特点，否则再次调整</strong>。这样才能保证交换不破坏二叉堆的特性。上述代码的运行结果为8 6 7 2 5 1 4。可见，构建成功了一个二叉堆。关于删除和插入这里不再实现。</p>
<h2 id="d堆"><a href="#d堆" class="headerlink" title="d堆"></a>d堆</h2><p>二叉堆是如此简单，以至于它们几乎总是用在需要优先队列的时候。d堆是二叉堆的简单推广，它恰像一个二叉堆，只是所有的结点都有d个儿子。如图所示的d堆是d=3时的情况。<br><img src="https://i.loli.net/2020/03/22/cyFZD7d8B4kusx9.png" alt="">  </p>
<p>在后续学习中，会学到堆排序，还会用到二叉堆的知识。在那里会发现堆在排序中的应用。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>散列</title>
    <url>/2020/03/20/%E6%95%A3%E5%88%971/</url>
    <content><![CDATA[<p>摘要：本篇将会讲解一种新的数据结构，散列。它通过关键字直接找到存储地址，而不再进行比较。在本篇中，将主要讲解什么是散列？怎么构造散列函数？怎么解决冲突？散列的优点和用途是什么？散列与二叉树的不同。</p>
<a id="more"></a>
<p>在我们之前学习过的查找当中，都有一步不可避免的操作，比较。但是比较是否真的有必要？能不能直接通过关键字找到它的内存位置？也就是说，我们只需要通过某个函数f，使得存储位置=f(关键字)。那样我们可以通过<strong>查找关键字不需要比较就可获得需要记录的存储位置</strong>。这就是一种新的存储技术-散列。<br>散列是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。查找时，根据这个确定的对应关系找到给定值key的映射f(key)，若查找集合存在这个记录，则必定在f(key)的位置上。<strong>我们把这种对应关系f称为散列函数，又称为哈希(Hash)函数</strong>。采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。那么关键字对应的记录存储位置称为散列地址。<br>散列是一种用于以<strong>常数平均时间执行插入、删除和查找的技术</strong>。表、树、图等几种结构，数据元素之间都存在着某种逻辑关系，可以用连线图示表示出来，而散列技术的记录之间不存在什么逻辑关系，它只与关键字有关联。但同样的，散列就实现不了其他数据结构的一些功能，它是主要面向查找的。<br>在理想情况下，每个关键字通过散列函数计算出来的地址都是不一样的，可现实中，时常会碰到<strong>两个不一样的关键字通过散列函数后地址是一样的，这种现象称为冲突</strong>。我们需要解决冲突。  </p>
<h2 id="构造散列函数"><a href="#构造散列函数" class="headerlink" title="构造散列函数"></a>构造散列函数</h2><p>一个好的散列函数一般有两个原则：<br>1.计算简单<br>2.散列地址分布均匀<br>构造散列函数的方法有好几种，下面对其分别进行介绍。  </p>
<h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>这是最常用的构造散列函数方法。对于散列表长为m的散列函数公式为： <code>f(key)=key mod p (p&lt;=m)</code>。mod是取余数的意思。本方法的关键在于选择合适的p，p如果选的不好，就很容易产生同义词。例如，对于有12个记录的关键字构造散列表时，就用了f(key)=key mod 12的方法，如下表所示。比如29 mod 12=5，所以它存放在下标为5的位置。<br><img src="https://i.loli.net/2020/03/20/XqmZ9DidAN4YTyU.png" alt=""><br>不过这种是存在冲突的可能的。极端一点，对于下表，所有的关键字都得到了0这个地址数，这时不选择p=12，而选择p=11，就会好很多。<br><img src="https://i.loli.net/2020/03/20/zWwRXNLuxpMgP4n.png" alt=""><br>根据经验，若散列表表长为m，<strong>通常p为小于或等于表长（最好接近m）的最小质数或不包含小于20质因子的合数</strong>。  </p>
<h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p>选择一个随机数，取关键字的随机函数值为它的散列地址。也就是<code>f(key)=random(key)</code>。这里random是随机函数，当关键字的长度不等时，采用这个方法构造散列函数比较合适。<br>如果关键字是字符串怎么办？其实无论是英文字符还是中文字符，包括各种各样的符号，它们都可以转化成某种数字来对待，比如ASCII码等。</p>
<h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p>这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用做散列地址。再比如关键字是4321，它的平方是18671041，抽取中间的3位就可以是671，也可以是710，用做散列地址。平方取中法适用于不知道关键字的分布，而位数又不是很大的情况。  </p>
<p>还有其它很多种方法来构造散列函数，这里就不再一一细说，要视不同的情况选择不同的散列函数。但这些方法当中都可能会出现冲突的情况，因此接下来讲解一下如何解决冲突。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>开放定址法就是<strong>一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入</strong>。它的公式是：<code>fi(key)=(f(key)+di) mod m (di=1,2,3…,m-1)</code>。比如我们关键字的集合为{12,67,56,16,25,37,22,29,15,47,48,34}，表长为12。我们用散列函数<code>f(key)=key mod 12</code>。<br>当计算前5个数时，都是没有冲突的散列地址，直接存入，如表所示：<br><img src="https://i.loli.net/2020/03/20/sZ3fdtxhr6QkA7E.png" alt=""><br>计算key=37时，发现f(37)=1，此时就与25所在的位置冲突。于是应用上面的公式，f(37)=(f(37)+1) mod 12=2。于是将37存入下标为2的位置，如表所示：<br><img src="https://i.loli.net/2020/03/20/K8fMHJAmcuCjoEN.png" alt=""><br>接下来22，29，15，47都没有冲突，正常的存入。<br><img src="https://i.loli.net/2020/03/20/4XwnmFvB1JzI7Hh.png" alt=""><br>到了key=48，f(48)=0，冲突。然后f(48)=(f(48)+1) mod 12=1，又冲突。f(48)=(f(48)+2) mod 12=2，继续冲突…直到f(48)=(f(48)+6) mod 12=6，有空位，存入。<br><img src="https://i.loli.net/2020/03/20/G5Al3ugebpyPfWq.png" alt=""><br><strong>我们把这种解决冲突的开放定址法称为线性探测法。线性探测法是开放定址法的一种，还有二次探测法，随机探测法等。</strong>下面对其介绍。<br>从例子中也可以看出，在解决冲突的时候，还会碰到如48和37这种本来都不是同义词却要争夺同一个地址的情况，称这种现象为堆积。<strong>堆积的出现使得我们需要不断的处理冲突</strong>。如果发生这样的情况，当最后一个key=34，f(key)=10，与22所在的位置冲突，可是22后面没有空位置了，反而它的前面有一个空位置，尽管可以不断的求余数后得到结果但效率很差。因此我们可以改进<code>di=1^2,-1^2,2^2,-2^2…,q^2,-q^2(q&lt;=m/2)</code>。这样就等于是双向寻找可能的空位置。<strong>增加平方运算的目的是为了不让关键字都聚集在某一块区域，我们称这种方法为二次探测法</strong>。<br>还有一种方法是，在冲突时，对于<strong>位移量di采用随机函数计算得到，称之为随机探测法</strong>。注意，这里的随机函数其实是伪随机数，可以复现的。  </p>
<h3 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h3><p>对于散列表，事先准备多个散列函数：<code>fi(key)=RHi(key) (i=1,2…,k)</code>。这里的RHi就是不同的散列函数，可以把前面说的各种方法都用上，每当散列地址发生冲突时，就换一个散列函数计算。这种方法能够使得关键字不产生聚集，但是相应的也增加了时间。  </p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>对于冲突，可以不换地方，而用链表来解决。<strong>将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针</strong>。如对于上面的例子，表示如下：<br><img src="https://i.loli.net/2020/03/20/qRJWZoO4rXNLhdb.png" alt=""><br>链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然这也就带来了查找时需要遍历单链表的性能损耗。  </p>
<h3 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h3><p><strong>为所有冲突的关键字建立了一个公共的溢出区来存放</strong>。<br><img src="https://i.loli.net/2020/03/20/8fxAXbyNFSEUOgo.png" alt=""><br>在查找时，对给定值通过散列函数计算出散列地址后，先于基本表中的相应位置进行比对，如果相等，则查找成功。如果不相等，则到溢出区去进行顺序查找。  </p>
<p>如果没有冲突，散列查找将是所有查找中效率最高的，因为它的时间复杂度为O(1)。但在实际的应用中，冲突是不可避免的，因此散列查找的平均查找长度取决于下面3个因素：<br>1.散列函数是否均匀。散列函数的好坏直接影响着出现冲突的频繁程度。<br>2.处理冲突的方法。相同的关键字和散列函数，处理冲突的方法不同，平均查找长度也不同。<br>3.散列表的装填因子。散列表装填因子=填入表中的记录个数/散列表长度。它标志着散列表装满的程度，当填入表中的记录个数越多，装填因子越大，产生冲突的可能性就越大。<br>前面讲过的二叉查找树也能实现插入和查找功能。虽然它的时间复杂度为O(logn)，但是二叉查找树还支持那些需要序从而功能更强大的例程。<strong>使用散列表不可能找出最小元素</strong>。<br>散列有着丰富的应用：<br>1.编译器使用散列表跟踪源代码中声明的变量。<br>2.散列表在任何图论问题中都有用。<br>3.散列表可用在为游戏编制的程序中。<br>4.可用于在线拼写检验程序。  </p>
<p>本篇主要讲解了有关散列的各种知识，在后续的学习中也会继续对散列进行学习。  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>多路查找树（B树）</title>
    <url>/2020/03/17/%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88B%E6%A0%91%EF%BC%89/</url>
    <content><![CDATA[<p>摘要：本篇将要讲解的树为B树，它不再是二叉树，与前面所讲的不太相同，而且它的作用体现在内存与外存数据交换上。本篇将会主要介绍什么是多路查找树？它的特点是什么？以及为什么要构建多路查找树？在学完了本篇之后，也希望大家对计算机的数据交换有更深一步的认识。</p>
<a id="more"></a>
<p>我们前面讨论过的数据结构，处理数据都是在内存中，因此考虑的都是内存中的运算时间复杂度。但若是我们要操作的数据集非常大，大到内存已经没法处理了怎么办？在这种情况下，<strong>对数据的处理需要不断的从硬盘等存储设备中调入或调出内存页面</strong>。而且涉及到这样的外部存储，关于时间复杂度的计算也就发生了改变，访问该集合元素的时间已经不仅仅是寻找该元素所需比较次数的函数，我们必须考虑对硬盘等外部存储设备的访问时间以及将会对设备做出多少次单独访问。<br>为了降低对外存设备的访问次数，我们需要新的数据结构来处理这样的问题。我们之前谈的树，都是一个结点可以有多个孩子，但是它自身只存储一个元素，二叉树的限制更多，结点最多只能有两个孩子。这使得在元素非常多的时候，要么树的度非常大，要么树的高度非常大，甚至两者都要很大才行。<br><strong>多路查找树，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在特定的排序关系</strong>。本篇将讲4种特殊形式：2-3树、2-3-4树、B树和B+树。  </p>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>2-3树是这样的一棵多路查找树：其中每一个结点都具有两个孩子（称它为2结点）或3个孩子（称它为3结点）。一个2结点包含一个元素和两个孩子（或没有孩子），<strong>但与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两个，不能只有一个孩子</strong>。一个3结点包含一小一大（较小元素和较大元素）两个元素和三个孩子（或没有孩子）。左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。这个3结点要么没有孩子，要有就有三个。<br><strong>并且2-3树中所有叶子都在同一层次上</strong>。如图所示为一棵2-3树：<br><img src="https://i.loli.net/2020/03/17/3Wc7ynIoNLOSGiF.png" alt=""><br>因为要保证所有的叶结点在同一层上，而且每个结点既有可能是2结点，也有可能是3结点，所以2-3树的插入和删除操作是比较复杂的。</p>
<h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><p>2-3-4树就是2-3树的概念扩展，包括了4结点的使用。一个4结点包括小中大三个元素和4个孩子（或没有孩子），一个4结点要么没有孩子，要有就有4个孩子。其中左子树包含小于最小元素的元素，第二子树包含大于最小元素，小于第二元素的元素，第三子树包含大于第二元素，小于最大元素的元素，右子树包含大于最大元素的元素。<br>举个例子来说明构建2-3-4树的过程。如构建一个数组为{7,1,2,5,6,9,8,4,3}的2-3-4树。首先在插入7、1、2时满足4结点的定义，因此不需要拆分，如图1所示，当插入5时，就需要增加结点，但是要满足2-3-4树所有叶子结点在同一层的要求，所以不能简单的把5插入成4结点的子树，因此拆分成图2的形状，这样不停的插入，最终形成了图7所示的2-3-4树。<br><img src="https://i.loli.net/2020/03/17/GDXlxN3qsvIdt7S.png" alt="">  </p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>本篇的标题是B树，可现在才开始讲到B树，是不是太晚了？其实，前面一直在讲B树。<br><strong>B树(B-tree)是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶，因此2-3树是3阶B树，2-3-4树是4阶B树</strong>。一个m阶的B树具有如下属性：<br>1.如果根结点不是叶结点，那么它至少有两棵子树。<br>2.每一个非根的分支结点都有k-1个元素和k个孩子，每一个叶结点都有k-1个元素，其中k介于m/2和m之间（可以等于边界）。<br>3.所有叶子结点都位于同一层次。<br>4.所有分支结点包含下列信息数据(n,A0,K1,A1,K2,…,Kn,An)，其中，Ki为关键字，i=1,2,3…，且Ki&lt;K(i+1)。Ai为指向子树根结点的指针，且指针A(i-1)所指向的子树中所有结点的关键字都小于Ki。An所指子树中所有结点的关键字都大于Kn。n为关键字的个数，或者说n+1为子树的个数。<br>例如上面讲的2-3-4树的例子转换成B树就变成了如图所示,左侧灰色方块表示当前结点的元素个数。<br><img src="https://i.loli.net/2020/03/17/pjrsfgTbxemvzZE.png" alt=""><br>在B树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程。比如，我们要查找数字7，首先从外存中读取到根结点3、5、8三个元素，发现7不在其中，但在5和8之间，因此就通过A2再读取外存的6、7结点，查找到所要的元素。B树的插入和删除与前面讲的2-3树类似，只不过更加复杂。<br>前面提过，多路查找树涉及到内存与外存的数据交换，如果交换次数频繁，就会造成增加时间。那么B树结构怎么做到减少次数呢？我们的外存，比如硬盘，是将所有的信息分割成相等大小的页面，每次硬盘读写的都是一个或多个完整的页面。在一个典型的B树应用中，我们会对B树进行调整，使得B树的阶数与硬盘存储的页面大小相匹配。比如说一棵B树的阶为1001（即1个结点包含1000个关键字），高度为2，它可以存储超过10亿个关键字，我们只要让根结点持久的保留在内存中，那么在这棵树上，寻找某一关键字至多需要两次硬盘的读取即可。<br>通过这种方式，在有限内存的情况下，每一次磁盘的访问我们都可以获得最大数量的数据。B树的数据结构就是为内外存的数据交互准备的。  </p>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>尽管前面讲了B树的好处，但它还是有缺陷的。对于树结构来说，我们都可以通过中序遍历来顺序查找树中的元素，这一切都是在内存中进行的。<br>可是在B树结构中，往返于每个结点之间意味着必须得在硬盘的页面之间进行多次访问，如下图所示，若要遍历这棵B树，则顺序为页面2-&gt;页面1-&gt;页面3-&gt;页面1-&gt;页面4-&gt;页面1-&gt;页面5。这就很麻烦。<br><img src="https://i.loli.net/2020/03/17/2cICYrhvNuZ5aBd.png" alt=""><br>B+树是应文件系统所需而出的一种B树的变形树，在B树中，每一个元素在该树中只出现一次，有可能在叶结点上，也有可能在分支结点上。而<strong>在B+树中，出现在分支结点中的元素会在它们的中序后继者（叶结点）中再次列出，另外，每一个叶结点都会保存一个指向后一叶结点的指针</strong>。<br>如下所示，根结点中的关键字在叶结点中再次列出，并且所有叶子结点都链接在一起。<br><img src="https://i.loli.net/2020/03/17/JTihD8VLIvsxAkw.png" alt=""><br><strong>B+树与B树的不同之处在于B+树的叶结点包含所有关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字大小顺序链接。所有分支结点可以看成是索引，结点中仅含其子树的最大（或最小）关键字</strong>。<br>B+树的结构特别适合带有范围的查找。它的插入、删除过程也与B树类似，只不过都是在叶结点上进行而已。  </p>
<p>本篇简单的介绍了B树相关的概念，了解了它的构成及用途，在后续的学习中，还会有再次用到它的地方，到时会细讲。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>伸展树(splay tree)</title>
    <url>/2020/03/15/%E4%BC%B8%E5%B1%95%E6%A0%91(splay%20tree)/</url>
    <content><![CDATA[<p>摘要：本篇将要讲解的二叉树为伸展树，伸展树其实是一种特殊的二叉查找树，它会调整自己的结构，提高查找效率。本篇将会介绍伸展树的概念，以及伸展树是如何伸展的。</p>
<a id="more"></a>
<p>伸展树保证从空树开始连续M次对树的操作最多花费O(Mlogn)时间，不过这种保证并不排除单次操作花费O(n)时间的可能，而且这样的界也不如每次操作最坏情形的界为O(logn)那么强，但实际效果是一样的：不存在坏的输入序列。<br>伸展树是基于这样的事实：对于二叉查找树来说，每次操作最坏情形时间O(n)并不坏，只要它相对不常发生就行。于是为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。伸展树的基本想法是，当一个结点被访问后，它就要经过一系列AVL旋转向根推进。注意，如果一个结点很深，那么在其路径上就存在许多结点也相对较深，通过重新构造以使得对所有这些结点的进一步访问所花费的时间变少。它是一种自调整形式的二叉查找树。</p>
<h2 id="简单想法"><a href="#简单想法" class="headerlink" title="简单想法"></a>简单想法</h2><p>实施上面描述的重新构造的一种方法是执行单旋转，从底向上进行。这意味着我们将在访问路径上的每一个结点和它们的父结点实施旋转。注意，<strong>该想法是不能直接使用的</strong>，下面会说明原因。如下所示，对k1进行一次访问后：<br><img src="https://i.loli.net/2020/03/15/EL9ix51l4uo7TdU.png" alt=""><br>虚线是访问的路径，首先单旋转使k1与k2交换：<br><img src="https://i.loli.net/2020/03/15/6J9uj87YtgcEUFI.png" alt=""><br>然后k1和k3之间执行旋转：<br><img src="https://i.loli.net/2020/03/15/uKaB5MXGedZ8UnD.png" alt=""><br>再然后：<br><img src="https://i.loli.net/2020/03/15/hntDSNW8gjZBk4z.png" alt=""><br><img src="https://i.loli.net/2020/03/15/nE5YcAj8O76XVTR.png" alt=""><br>最终使得k1变成了根结点，使得对k1的进一步访问很容易。但是，它把另一个结点k3推向和以前k1一样深，而对k3的访问又会推动下一个结点。所以这个想法存在着问题，需要改进。  </p>
<h2 id="伸展"><a href="#伸展" class="headerlink" title="伸展"></a>伸展</h2><p>伸展(splaying)的思路类似于前面的旋转，但有一些改变。令X是访问路径上的一个结点，我们将在这个结点上实施伸展。若X的父结点是树的根，那么只需要旋转X和根即可。否则，X就有父亲(P)和祖父(G)，于是存在两种情况外加对称的情形要考虑。  </p>
<h3 id="之字形"><a href="#之字形" class="headerlink" title="之字形"></a>之字形</h3><p><img src="https://i.loli.net/2020/03/15/8XquI1wSmMCL2VT.png" alt=""><br>这种情况下执行的是双旋转。  </p>
<h3 id="一字形"><a href="#一字形" class="headerlink" title="一字形"></a>一字形</h3><p><img src="https://i.loli.net/2020/03/15/T7d3zFA8CGMoKQH.png" alt=""><br><strong>注意，这种情况下既不是单旋转，也不是双旋转</strong>。  </p>
<p>这样，再对上面的例子进行伸展：<br><img src="https://i.loli.net/2020/03/15/q4wMVCLurXIR1j7.png" alt=""><br>这是一个之字形，因此我们执行一次AVL的双旋转，得：<br><img src="https://i.loli.net/2020/03/15/VR4Su6eJOWp9hGY.png" alt=""><br>此时变成了一字形，进行一次一字形的变换，得最终的树：<br><img src="https://i.loli.net/2020/03/15/8xUjoZM3NXt4197.png" alt=""><br>伸展操作不仅将访问的结点移动到根处，而且还有把访问路径上的大部分结点的深度大致减少一半的效果。  </p>
<p>伸展树因为没有平衡信息要保留所以比平衡二叉树实现简单，情形少，所占用内存也少，它会自调整逐步优化自己，使得最终查找速度变快，更有效率。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>平衡二叉树(AVL)</title>
    <url>/2020/03/13/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(AVL)%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>摘要：根据上一篇二叉查找树的学习，对其加入平衡条件，降低查找的时间复杂度，因此有了平衡二叉树(AVL)。本篇将会介绍平衡二叉树的概念，平衡二叉树的特点，以及当平衡被打破（插入或删除时）它是如何通过旋转保持平衡的。</p>
<a id="more"></a>
<p>在介绍平衡二叉树(AVL)之前，首先再来回顾一下二叉树的高度的定义，二叉树的高度等于二叉树的层次，根结点为第一层。平衡二叉树是带有<strong>平衡条件</strong>的二叉查找树。它要求<strong>每个结点的左子树和右子树的高度最多差1</strong>。<br><img src="https://i.loli.net/2020/03/13/QepfMC3DVr8tqFs.png" alt="">  </p>
<p>上图的两棵树中，左边的是AVL树，而右边的不是。这是因为右边根结点7的左子树高度为3，右子树高度为1，相差为2。<br>可以证明，一棵AVL树实际上的高度只比 log N 稍微多一些。如下图显示一棵具有最少结点（143）高度为10的AVL树。这棵树的左子树是高度为8且大小最小的AVL树，右子树是高度为9且大小最小的AVL树。在高度为h的AVL树中，最少结点数S(h)由S(h)= S(h-1)+ S(h-2)+1给出。对于h=1，S(h)=1。而当h=2，S(h)=2。函数S(h)与斐波那契数密切相关。<br><img src="https://i.loli.net/2020/03/13/aHmiB1CDtbnYLIP.png" alt=""><br>这样，平衡二叉树就使得查找的时间复杂度变为了O(logn)。<br>当插入和删除结点时，显然会使得平衡被改变（如将结点6插入到第一张图左AVL树中，成为结点7的左孩子，改变了结点8的平衡），因此需要在插入后恢复平衡的性质，需要用到的操作为旋转。<br>当插入以后，距离插入结点最近且平衡条件的被破坏的结点为根的子树，称为最小不平衡子树。如下插入结点37后，结点58的平衡条件被破坏，且它离插入结点最近，因此以结点58为根结点的子树为最小不平衡子树。<br><img src="https://i.loli.net/2020/03/13/PEv4wXOykhr8DfB.png" alt=""><br>把必须重新平衡的结点叫做α，由于任意结点最多有两个儿子，因此出现高度不平衡就需要α点的两棵子树的高度差2。容易看出，这种不平衡出现在下面4种情况中：<br>1.对α的左儿子的左子树进行一次插入。<br>2.对α的左儿子的右子树进行一次插入。<br>3.对α的右儿子的左子树进行一次插入。<br>4.对α的右儿子的右子树进行一次插入。<br>第一种和第四种是插入发生在“外边”的情况（即左-左的情况和右-右的情况），该情况通过对树的一次<strong>单旋转</strong>完成。而第二种和第三种情况则需要复杂点的<strong>双旋转</strong>完成。</p>
<h2 id="单旋转"><a href="#单旋转" class="headerlink" title="单旋转"></a>单旋转</h2><p>如下为调整情况1的单旋转。旋转前的图在左边，旋转后的图在右边。可以看到插入后结点k2不满足AVL平衡性质，因为它的左子树比右子树深两层（图中间的几条虚线标示树的各层）。为了使树恢复平衡，我们要想办法使X上移一层，Z下移一层。我们可以抽象的把树看成柔软灵活的，抓住不平衡结点k2的左孩子k1摇，将k1变成了根结点，k2变成了右子树，又因为要满足二叉查找树的性质，Y比k1大，所以把Y变成k2的左孩子。这样就变成了新的AVL树。<br><img src="https://i.loli.net/2020/03/13/mqXsT9iaMNLPFlz.png" alt=""><br>例子如下所示，插入结点6之后破坏了结点8的平衡，因此进行单旋转，使结点8的左孩子结点7代替结点8。<br><img src="https://i.loli.net/2020/03/13/4oZl3CFGYjpTD89.png" alt=""><br>第四种情况是第一种情况的对称情况。<br><img src="https://i.loli.net/2020/03/13/pkfEtCSvAobXem3.png" alt=""><br>不过这次我们是抓住不平衡结点k1的右孩子k2摇，使右孩子变成根结点。示例如下：<br><img src="https://i.loli.net/2020/03/13/y3WFBgeINDGuaMT.png" alt="">  </p>
<h2 id="双旋转"><a href="#双旋转" class="headerlink" title="双旋转"></a>双旋转</h2><p>但是单旋转不能解决第二种和第三种情况，如下图所示，问题在于子树Y太深，单旋转并没有减低它的深度。<br><img src="https://i.loli.net/2020/03/13/DOI5vVAYpJ72bjq.png" alt=""><br>解决这个问题需要双旋转，我们假设Y有一个根和两个子树，于是可以把整个树看成4棵子树由3个结点连接。为了重新平衡我们需要旋转两次（第一次是围绕k1的右-右旋转，第二次是围绕k3的左-左旋转），如图所示，最终使得k2变成根结点。<br><img src="https://i.loli.net/2020/03/13/toNqUZye8293Au4.png" alt=""><br>示例如下，先进行一次左-左旋转使结点15替换结点16的位置，结点16为它的右孩子，再进行一次右-右旋转，使得结点15变成根结点，结点7和结点16为它的左右孩子，满足AVL树平衡条件。<br><img src="https://i.loli.net/2020/03/13/XxkbPO5CMhHfWDe.png" alt="">  </p>
<p>由于在二叉查找树中进行删除多少要比插入复杂，因此可以假设，在AVL树中的删除也会更复杂。一次删除能够造成树的一边比另一边浅了两层，即打破平衡，类似于由插入引起的不平衡，但又不完全一样。在此就不过多介绍。关于平衡二叉树如何用程序实现，网上有很多源码，因为行数过多，在这里就不再介绍，大家可以自行搜索。本篇主要介绍旋转这一操作是如何使平衡二叉树保持平衡的。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>二叉查找树</title>
    <url>/2020/03/11/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<p>摘要：二叉查找树又称二叉排序树。本篇将会介绍什么是二叉查找树，二叉查找树的优势是什么，如何建立一个二叉查找树及对它进行操作。通过本篇的学习也能够后面AVL树和伸展树打下基础。</p>
<a id="more"></a>
<p>我们经常会对数据进行查找，假如查找的数据是普通的顺序存储，插入操作就是将记录放在表的末端，给表记录数加一，删除操作可以是删除后，后面的记录往前移，也可以是要删除的元素与最后一个元素互换，表记录数减一，反正整个数据集也没什么顺序，这样的效率也不错。插入和删除操作对于顺序存储结构来说，效率是可以接受的，但是这样的表由于无序造成查找的效率很低。<br>如果查找的数据集是有序线性表，并且是顺序存储的，查找可以折半、插值、斐波那契等查找算法来实现，但是因为有序，在插入和删除操作上就要耗费大量的时间。<br>有没有一种既可以使得插入和删除效率不错，又可以比较高效率的实现查找的算法？举个例子，假设数据集只有一个数{62}，然后将88插入，于是数据集变成了{62,88}，还保持从小到大的顺序。再查找有没有58，没有则插入，可此时若用线性表的顺序存储结构，就要移动62和88，可不可以不移动？用二叉树结构来实现，将第一个数62定为根结点，第二个数88比它大，就把它做62的右子树，58比62小，让它做62的左子树。此时，58的插入并没有影响到62与88的关系。<br><img src="https://i.loli.net/2020/03/11/Lw6dI8QCx9hgUeB.png" alt=""><br>二叉查找树又称二叉排序树，它或者是一棵空树，或者是具有下列性质的二叉树：<br>1.若它的左子树不为空，则左子树上所有结点的值均小于它的跟结构的值。<br>2.若它的右子树不为空，则右子树上所有结点的值均大于它的跟结构的值。<br>3.它的左、右子树也分别为二叉查找树。<br><img src="https://i.loli.net/2020/03/11/91fHdgjw2OruKXL.png" alt=""><br>如上面的两棵树中，左边的树是查找树，右边的不是。<br>构造一棵二叉查找树的目的，并不是为了排序，而是为了提高查找和插入删除关键词的速度。<br>接下来介绍一下二叉查找树的一些操作，由于树的递归定义，通常是递归的编写这些操作的例程。因为二叉查找树的平均深度为为O(logn)，所以一般不必担心栈空间被用尽。  </p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>首先判断当前结点的值是否为查找的值，如果是，直接返回。如果不是，比较当前结点的值与查找值的大小，因为二叉查找树的特点，若查找值大，则只需在当前结点的右子树查找即可。若查找值小，则只需在当前结点的左子树查找。如果最终还是查找不到，返回。  </p>
<pre><code>int searchBST(Node &amp;T,int key) 
 {
     if(T!=NULL)
     {
         if(T-&gt;data==key)
         {
             cout&lt;&lt;&quot;find &quot;&lt;&lt;key&lt;&lt;endl;
        }
        else if(key&lt;T-&gt;data)
        {
             searchBST(T-&gt;lchild,key);
        }
        else if(key&gt;T-&gt;data)
        {
            searchBST(T-&gt;rchild,key);
        }
    }
    else
        cout&lt;&lt;&quot;can&apos;t find &quot;&lt;&lt;key&lt;&lt;endl;
    return 0;
 }</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><strong>根据特性，插入的都是叶结点</strong>。首先判断结点是否为空，如果是，直接新生成一个结点即可。如果不是，判断当前结点的值与插入值的大小，因为二叉查找树的特点，若插入值大，则只需在当前结点的右子树插入即可。若插入值小，则只需在当前结点的左子树插入。  </p>
<pre><code>int insertBST(Node &amp;T,int key) 
{
    if(T==NULL)
    {
        Node p;
        p=new node;
        p-&gt;data=key;
        p-&gt;lchild=p-&gt;rchild=NULL;
        T=p;
        return 1;
    }
    else if(key&lt;T-&gt;data)
    {
        insertBST(T-&gt;lchild,key);
    }
    else 
    {
        insertBST(T-&gt;rchild,key);
    }
    return 0;
}</code></pre><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>在讲完插入之后，再来说明如何构造二叉查找树就很简单了。相当于一个个结点的插入，生成了一个二叉查找树。  </p>
<pre><code>int a[10]={62,88,58,47,35,73,51,99,37,93};
Node T=NULL;
for(i=0;i&lt;10;i++)
{
    insertBST(T,a[i]);
}</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除操作相比较而言就有些麻烦。因为结点的位置不同，操作也不一样，假如要删除的结点为叶结点，直接删除即可，不影响二叉查找树的其他地方。若删除的结点只有左子树或右子树，这也比较容易，将该结点的左子树或右子树整体移动到该结点的位置，然后删除该结点即可。但若是要删除的结点既有左子树又有右子树，就会很麻烦。因此根据二叉查找树的特性，有一个比较好的方法是，找到要删除结点p的直接前驱或直接后继s（中序遍历），用s替换结点p，然后再删除此结点s。这样只改变了要删除结点的左子树或右子树，而不用全部操作，同时不影响二叉查找树的特点。  </p>
<pre><code>void deleteBST(Node &amp;T,int key)
{
    if(T!=NULL)
    {
        if(T-&gt;data==key)
        {
            delete1(T);
        }
        else if(key&lt;T-&gt;data)
        {
            deleteBST(T-&gt;lchild,key);
        }
        else if(key&gt;T-&gt;data)
        {
            deleteBST(T-&gt;rchild,key);
        }
    }
    else
        cout&lt;&lt;&quot;can&apos;t find and delete &quot;&lt;&lt;key&lt;&lt;endl;
}</code></pre><p>可以看到，在<code>deleteBST</code>函数中，与前面没有太大的区别使用递归，关键在于<code>delete1</code>函数。  </p>
<pre><code>void delete1(Node &amp;T)
{
    Node q,s;
    if(T-&gt;rchild==NULL)
    {
        q=T;
        T=T-&gt;lchild;
        delete q; 
    }
    if(T-&gt;lchild==NULL)
    {
        q=T;
        T=T-&gt;rchild;
        delete q; 
    }
    else 
    {
        q=T;
        s=T-&gt;lchild;
        while(s-&gt;rchild)
        {
            q=s;
            s=s-&gt;rchild;
        }
        T-&gt;data=s-&gt;data;
        if(q!=T)
        {
            q-&gt;rchild=s-&gt;lchild;
        }
        else
        {
            q-&gt;lchild=s-&gt;lchild;
        }
        delete s;
    }
}</code></pre><p>在该函数里判断了上述的3种情况并分别进行操作。  </p>
<p>最后对上述操作做一个总结，在主函数里：  </p>
<pre><code>int main()
{
    int i;
    int a[10]={62,88,58,47,35,73,51,99,37,93};
    Node T=NULL;
    for(i=0;i&lt;10;i++)
    {
        insertBST(T,a[i]);
    }
    searchBST(T,58);
    searchBST(T,100);
    deleteBST(T,100);
    deleteBST(T,58);
    searchBST(T,58);
    return 0;
}</code></pre><p>构造了一棵二叉查找树，然后在树中查找58和100，显然58能够找到，100找不到，然后删除100和58，因为100查找不到，所以自然也无法删除，58被删除，当再次查找58时，也无法查找到。运行结果为：<br><img src="https://i.loli.net/2020/03/11/lQYHB54T8orziVU.png" alt="">  </p>
<p>总之，二叉查找树是以链接的方式存储，保持了链接存储结构在执行插入和删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需要修改链接指针即可。插入删除的时间性能比较好。而对于二叉查找树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉查找树的层数。极端情况下，最少为1次，即根结点就是要查找的结点，最多也不会超过树的深度。也就是说，二叉查找树的查找性能取决于二叉查找树的形状。可问题在于，二叉查找树的形状是不确定的。<br>例如如下两图，它们都是二叉查找树，数据元素也是相同的，但同样是查找结点99，左图只需要两次比较，而右图却需要10次。<br><img src="https://i.loli.net/2020/03/11/NfoGwPXZE5lmY4a.png" alt=""><br>也就是说，我们希望二叉查找树是比较平衡的，即其深度与完全二叉树相同，那么查找的时间复杂度也就为O(logn)，近似于折半查找，而不是最坏情况下的O(n)。因此如何让二叉查找树带有平衡条件，这就是我们接下来要学习的平衡二叉树(AVL)。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>赫夫曼树和表达式树</title>
    <url>/2020/03/09/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/</url>
    <content><![CDATA[<p>摘要：本篇将开始介绍一些二叉树的应用。赫夫曼树又称最优二叉树，赫夫曼编码大大减少了常规编码的长度。而表达式树则是数据为操作符和操作数的树，我们将会通过二叉树的形式再次介绍一下前面学习的用栈实现逆波兰表达式。</p>
<a id="more"></a>
<p>在我们的日常生活中，当我们下载或发送软件时，我们经常会做一件事：压缩。通过压缩发送再解压，以此来提高速度。那么压缩是如何做到不出错的呢？今天会介绍一种基本的编码方法：赫夫曼编码。  </p>
<h2 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h2><p>美国数学家赫夫曼在1952年发明了赫夫曼编码，为了纪念他的成就，于是就把他在编码中用到的特殊二叉树称之为赫夫曼树，他的编码称为赫夫曼编码。我们平时所用的压缩和解压缩技术都是基于赫夫曼的研究之上发展而来。<br>二叉树中一个结点到另一个结点的路径的分支数目称为路径长度。<br><img src="https://i.loli.net/2020/03/09/VlraIpqeNikv69M.png" alt=""><br>树a中根结点到A路径长度为1，到B为2，到C为3，D和E都是4。树b中根结点到A和B路径长度为3，到C为2，D和E也是2。树的路径长度就是从树根到每一结点的路径长度之和。可以看到，叶结点是带权值的，结点的带权路径长度为路径长度与权值的乘积。<strong>树的带权路径长度(WPL)为树中所有叶子结点的带权路径长度之和</strong>。二叉树a的<code>WPL=5*1+15*2+40*3+30*4+10*4=315</code>。二叉树b的<code>WPL=5*3+15*3+40*2+30*2+10*2=220</code>。<br>假设有n个权值{w1，w2，…，wn}，构造一个有n个叶子结点的二叉树，其中带权路径长度WPL最小的二叉树称为赫夫曼树。那么该如何构造出赫夫曼树呢？<br>1.把有权值的叶子结点按照从小到大的顺序排列成一个有序序列，即：A 5，E 10, B 15, D 30, C 40。<br>2.取头两个权值最小的结点作为新结点N1的两个子结点，相对较小的为左孩子。新结点的权值为两个子结点的权值之和，N1 15。<br><img src="https://i.loli.net/2020/03/09/U2Yhor5ImuNKR3C.png" alt=""><br>3.将<strong>N1替换A和E</strong>，插入到有序序列中，再重新从小到大排列。即N1 15，B 15， D 30, C 40。<br>4.重复步骤2，生成新结点N2，权值为30。<br><img src="https://i.loli.net/2020/03/09/yFWMIXxnbSukaOr.png" alt=""><br>5.循环直到生成根结点T。<br><img src="https://i.loli.net/2020/03/09/o7PRq6zEwhuLXxB.png" alt="">)<img src="https://i.loli.net/2020/03/09/7Id5SyiYZsjlhVQ.png" alt="">  </p>
<p>接下来介绍一下赫夫曼编码。假如要将BADCADFEED传输，若用二进制：<br><img src="https://i.loli.net/2020/03/09/TF9XLqcaPKJxvU2.png" alt=""><br>则为：001000011010000011101100100011，以3个一位解读，如果内容过多，会非常长。怎么改进呢？可以看到不同字母出现的频率是不一样的，假设 A 27,B 8,C 15,D 15,E 30,F 5，合起来正好100%。构造赫夫曼树：<br><img src="https://i.loli.net/2020/03/09/2VUv1gN7s6m5FKZ.png" alt=""><br>将权值左分支改为0，右分支改为1后：<br><img src="https://i.loli.net/2020/03/09/4kYvMUgqy8Cj7Ti.png" alt=""><br>可得：<br><img src="https://i.loli.net/2020/03/09/YPElNFXOzdtQaJi.png" alt=""><br>新编码：1001010010101001000111100。可以看到个数减少了，当解码的时候按照约定好的赫夫曼树解码即可。  </p>
<h2 id="表达式树"><a href="#表达式树" class="headerlink" title="表达式树"></a>表达式树</h2><p>表达式树的树叶是操作数，如常数或变量名字，而其他的结点为操作符。如果操作都是二元（二目）的，则构成的树正好是二叉树。如图所示为一个表达式树的例子，<code>(a+b*c)+((d*e+f)*g)</code>。<br><img src="https://i.loli.net/2020/03/09/5SrgMIczDNAU9Qd.png" alt=""><br>如何求该树的值，就需要用到前面学习过的遍历。因为前面已经详细的介绍过二叉树的遍历，这里就不再介绍，而只是说明一下。<br>在构造表达式树时，就需要回忆一下前面学过的栈的应用：逆波兰表达式。构造表达式树的方法酷似逆波兰表达式。一次一个符号的读入表达式，如果符号是操作数，那么建立一个单结点树并将指向它的指针推入栈中，如果符号是操作数，那么就从栈中弹出指向两棵树的两个指针并形成一棵新的树，该树的根就是操作符，它的儿子为前面的两棵树，然后将指向这棵新树的指针压入栈中。<br>来看一个例子，设输入为：<code>a b + c d e + * *</code>。<br>前两个符号是操作数，因此创建两棵单结点树并将它们压入栈中。<br><img src="https://i.loli.net/2020/03/09/cz3ugnWLV91sBoG.png" alt=""><br>接着，<code>+</code>被读入，因此指向这两棵树的指针被弹出，一棵新的树形成，指向新树的指针被压入栈中。<br><img src="https://i.loli.net/2020/03/09/5jMCvEsihlAaOTb.png" alt=""><br>然后<code>c d e</code>被读入，在每个单结点树创建后，对应的指向树的指针被压入栈中。<br><img src="https://i.loli.net/2020/03/09/Od7Tc16iwtrUs25.png" alt=""><br>接下来读入<code>+</code>号，因此右边的两棵树合并。<br><img src="https://i.loli.net/2020/03/09/XMiWa5pRcA6DQLw.png" alt=""><br>继续进行，读入<code>*</code>，弹出两棵树的指针并形成一棵新的树，<code>*</code>为它的根。<br><img src="https://i.loli.net/2020/03/09/CXsoacyphSu12mf.png" alt=""><br>最后，读入最后一个符号，两棵树合并，而指向最后的树的指针被留在栈中。<br><img src="https://i.loli.net/2020/03/09/mbwR1jxOvDUyh5P.png" alt="">  </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树知识2</title>
    <url>/2020/03/07/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9F%A5%E8%AF%862/</url>
    <content><![CDATA[<p>摘要：本篇继续上一篇对二叉树的学习。主要讲解如何用代码实现对二叉树的建立以及遍历，同时也会介绍一下树、森林和二叉树的转换。这些也是我们后面学习的基础，了解树这一结构是怎么通过程序来实现。</p>
<a id="more"></a>
<p>前面已经说过二叉树的存储。二叉树是由结点组成的，每个结点又包括一个数据位和两个指向其左右孩子的指针。因此对于结点的建立，我们可以用结构体来完成。  </p>
<pre><code>typedef struct node
{
    char data;
    node* lchild;
    node* rchild;    
 }node,*Node;</code></pre><p>可以看到，定义了一个结点结构<code>node</code>，还定义了一个指向该结构体的指针<code>Node</code>。<strong>二叉树建立和遍历过程中，需要不停的生成结点，赋值。因此需要修改指针的指向，指向新的结点</strong>。在我们创建的时候，若二叉树某个结点为空，那我们就令指针<code>Node</code>的引用为空。而如果<code>Node</code>的值是空的，那么自然就没有结构体<code>node</code>的地方了，这个结点就相当于没有了。<br>还有一个问题是怎么确定每个结点是否有左右孩子？为了解决这个问题，对二叉树进行扩展，将二叉树中每个结点的空指针引出一个虚结点，其值为一特定值，比如<code>#</code>。这种处理后的二叉树称为扩展二叉树，<strong>扩展二叉树可以做到一个遍历序列确定一棵二叉树</strong>。 </p>
<p><img src="https://i.loli.net/2020/03/07/DCw4VPqRlJftyYT.png" alt=""><br>扩展后前序为：AB#D##C##。<br>接下来就是利用递归生成二叉树。代码如下：  </p>
<pre><code>typedef struct node
{
    char data;
    node* lchild;
    node* rchild;    
 }node,*Node;
 void CBtree(Node &amp;T)
 {
     char data;
     cin&gt;&gt;data;
     if(data==&apos;#&apos;)
     {
         T=NULL;
     }
     else
     {
         T=new node;
         T-&gt;data=data;
         CBtree(T-&gt;lchild);
         CBtree(T-&gt;rchild);
     }
 }
 void print(Node T)
 {
     if(T != NULL)
     {
          print(T-&gt;lchild);
          cout&lt;&lt;T-&gt;data;
         print(T-&gt;rchild);
    }
 }
 int main()
 {
     Node T;
     CBtree(T);
     print(T);
     return 0;
 }</code></pre><p>首先定义了一个创建树的函数<code>CBtree</code>，输入参数为结点结构指针的引用。然后输入前序顺序，根据顺序判断若字符是<code>#</code>，则表示是空结点，否则就新建一个结点，将读入的数据赋给这个新建的结点，然后递归去创建该结点的左子树和右子树。需要说明的是，<strong>这是以前序顺序来建立的二叉树，如果以中序和后序就需要换一下位置</strong>。<br>在遍历函数中，先判断树是否为空，若不为空，则递归遍历二叉树的左子树，再打印该结点数据，最后递归遍历右子树，可以看到这是中序遍历。以上篇中的二叉树为例：<br><img src="https://i.loli.net/2020/03/05/xu4q5W6TiM8Jh3X.png" alt=""><br>前序遍历顺序为：ABDGHCEIF。中序遍历顺序为：GDHBAEICF。将其变成扩展二叉树后前序遍历顺序为：ABDG##H###CE#I##F##。运行结果为：<br><img src="https://i.loli.net/2020/03/07/8rapH9dMsEXoIcT.png" alt=""><br>可见，成功的实现了二叉树的建立与遍历。若想要实现中序和后序遍历，只需修改代码为：  </p>
<pre><code>//将二叉树按照中序输出
void Print2(Node T)
{
    if(T != NULL)
    {
        Print2(T-&gt;lchild);
        cout&lt;&lt;T-&gt;data;
        Print2(T-&gt;rchild);
    }
}
//将二叉树按照后序输出
void Print3(Node T)
{
    if(T != NULL)
    {
            Print3(T-&gt;lchild);
           Print3(T-&gt;rchild);
        cout&lt;&lt;T-&gt;data;
        }
}</code></pre><p>接下来介绍一下树、森林和二叉树的转换。在前面对树的表示中，我们学过一种方法叫孩子兄弟表示法。这里复习一下：任意一个树，它的结点的第一个孩子和该结点的右兄弟如果存在就是唯一的。设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟，因为我们要转换成二叉树，所以规定左子树为第一个孩子，右子树为右边第一个兄弟，没有则为空。如下所示树：<br><img src="https://i.loli.net/2020/03/07/8F7xqEb42PActG9.png" alt=""><br>A的第一个孩子为B，无兄弟，因此转换后A为根结点，左孩子为B，无右孩子。B的第一个孩子为E，右边第一个兄弟为C，因此转换后左孩子为E，右孩子为C。E没有孩子，右边第一个兄弟为F，因此E的左孩子为空，右孩子为F…转换后：<br><img src="https://i.loli.net/2020/03/07/GOv7kqzYjSywAK5.png" alt=""><br>森林有多棵树，将每个树先转换成二叉树，然后将根结点连起来（根结点相当于兄弟）。<br><img src="https://i.loli.net/2020/03/07/W6xnXr1sK5fkFqH.png" alt=""><br>每棵树转换后为：<br><img src="https://i.loli.net/2020/03/07/zDVwTb3fLUWdjch.png" alt=""><br>合在一起：<br><img src="https://i.loli.net/2020/03/07/3Nb1uXEhjWpQtRd.png" alt=""><br>二叉树转换成树和森林，反过来即可。   </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树知识1</title>
    <url>/2020/03/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9F%A5%E8%AF%861/</url>
    <content><![CDATA[<p>摘要：本篇将进入二叉树的学习，二叉树是数据结构中的重点知识，它包含的内容很多，因此将会分为几篇来讲解。在本篇当中将会主要介绍什么是二叉树？二叉树有哪些特点？二叉树有什么性质？二叉树是如何存储的以及二叉树的遍历。</p>
<a id="more"></a>
<p>二叉树(binary tree)是一棵树，它的每个结点<strong>最多</strong>有两个孩子，并且子树是有<strong>顺序</strong>的。这也是它与前面学习的树的最主要的区别，二叉树的左子树和右子树严格区分。  </p>
<h2 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h2><p>1.每个结点最多有2个子树，所以二叉树不存在度大于2的结点。可以只有1个子树或没有子树。<br>2.左子树和右子树有顺序，且次序不能颠倒。<br>3.即使树中某一结点只有1个子树，也要区分是左子树还是右子树。树1和树2是同一棵树，却是不同的二叉树。<br><img src="https://i.loli.net/2020/03/05/LdfCzOhibHrZ9In.png" alt=""><br>二叉树的基本形态有5种：<br>1.空二叉树<br>2.只有一个根结点<br>3.根结点只有左子树<br>4.根结点只有右子树<br>5.根结点既有左子树又有右子树<br>根据它的基本形态，也就有了一些特殊的二叉树：<br>1.斜树：包括左斜树和右斜树，显然左斜树指每个结点只有左孩子，右斜树则是每个结点只有右孩子。<br>2.满二叉树：所有的结点都有左孩子和右孩子并且<strong>所有的叶子在同一层</strong>上。<br><img src="https://i.loli.net/2020/03/05/fEM6cdKr9heqkV7.png" alt=""><br>3.完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号与同样深度的满二叉树的编号位置完全相同，则称为完全二叉树。相当于是满足特定要求的满二叉树的子树。<br><img src="https://i.loli.net/2020/03/05/uSts9hV3oRWy86P.png" alt=""><br>要注意完全二叉树与满二叉树的区别。满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满二叉树。而下面所示的3棵树就不是完全二叉树:<br><img src="https://i.loli.net/2020/03/05/EvTtyAeJfUB21c7.png" alt=""><br>因此可得完全二叉树的特点：叶子结点只能出现在最下两层。最下层的叶子一定是在左部连续的。倒数二层若有叶子结点，则一定在右部且是满叶。同样结点数的二叉树，完全二叉树的深度最小。  </p>
<h2 id="二叉树性质"><a href="#二叉树性质" class="headerlink" title="二叉树性质"></a>二叉树性质</h2><p>1.在二叉树的第i层上最多有2^(i-1)个结点。这是在满二叉树的情况下最多。<br>2.深度为k的二叉树最多有2^k-1个结点。注意与第一条的区别，上一个求的是第i层上的结点，这个是二叉树的所有结点。也是满二叉树的情况下结点最多。<br>3.对任意一个二叉树T，如果其终端结点数（叶子数）为n0，度为2的结点数为n2，则n0=n2+1。<br>4.具有n个结点的完全二叉树的深度为[logn+1]，括号表示不大于的最大整数，log以2为底。   </p>
<h2 id="二叉树存储"><a href="#二叉树存储" class="headerlink" title="二叉树存储"></a>二叉树存储</h2><p>前面提到顺序存储对树这一结构是比较困难的。但是二叉树是一种特殊的树，它可以用顺序存储结构实现。我们用数组存储结点，对于如下的完全二叉树：<br><img src="https://i.loli.net/2020/03/05/Nv26qUsFZ13OGhb.png" alt=""><br>它的数组存储如下：<br><img src="https://i.loli.net/2020/03/05/Mcz1Vsihn7ludoA.png" alt=""><br>对于一般的二叉树，将其按照完全二叉树编号，把存在的结点设置成空即可。如下二叉树：<br><img src="https://i.loli.net/2020/03/05/3AD2mSNl7w8dYGZ.png" alt=""><br>若在极端的情况下，一棵深度为k的右斜树，它只有k个结点，却要分配2^k-1个存储空间，这是对存储空间的很大浪费，<strong>所以顺序存储一般只用于完全二叉树</strong>。<br><img src="https://i.loli.net/2020/03/05/pgiNvrmFZcJRPfl.png" alt=""><br>另一种存储为链表存储构成二叉链表。因为二叉树每个结点最多有两个孩子，所以设计一个数据域和两个指针域。<br><img src="https://i.loli.net/2020/03/05/UoG5eVXNj8zR16D.png" alt=""><br><img src="https://i.loli.net/2020/03/05/VPrLX6uUkitzoRE.png" alt=""><br>如果有需要，可以增设一个指针指向其双亲，那样就成了三叉链表。</p>
<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><p>二叉树的遍历就是从根结点出发，按照某种次序依次访问二叉树种的所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>先访问根结点，然后前序遍历左子树，再前序遍历右子树。如下所示，前序遍历顺序为：ABDGHCEIF。<br><img src="https://i.loli.net/2020/03/05/xu4q5W6TiM8Jh3X.png" alt="">  </p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>中序遍历左子树，再访问根结点，再中序遍历右子树。如下所示，中序遍历顺序为：GDHBAEICF。<br><img src="https://i.loli.net/2020/03/05/Yp6hCQiTyq3j9Ox.png" alt="">  </p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>后序遍历左子树，再后序遍历右子树，最后再访问根结点。后序遍历顺序为：GHDBIEFCA。<br><img src="https://i.loli.net/2020/03/05/TkJoOhWb3axZ1PD.png" alt="">  </p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>从上而下逐层遍历，在同一层中，从左到右顺序遍历。层序遍历顺序为：ABCDEFGHI。<br><img src="https://i.loli.net/2020/03/05/USK81qYeVfH4uTc.png" alt="">  </p>
<p>可以看到，前、中、后序遍历的定义都用到了递归的概念，而二叉树的也可以用递归来定义。这就给了我们一个启示，在用程序将二叉树建立以及遍历二叉树时，是否可以用递归算法来实现呢？在下篇当中，将会讲解如何建立一个二叉树。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>树的基础知识</title>
    <url>/2020/03/03/%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>摘要：本篇开始将进入树这种数据结构的学习。但由于树的相关知识比较多，所以将会分几篇进行介绍。在本篇中将主要说明树的概念、树的表示、树的存储以及树的遍历和应用。</p>
<a id="more"></a>
<p>对于大量的输入数据，链表的线性访问耗时过多，不便访问。有一种简单的数据结构，其大部分操作的运行时间平均为O(long n)。涉及到的这种数据结构叫作二叉查找树，它是<code>set</code>类和<code>map</code>类实现的基础，用于许多应用之中。在计算机科学中树（tree）是非常有用的抽象概念。</p>
<h2 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h2><p>树是n(n&gt;=0)个结点的有限集，n=0时称为空树。在任意一棵非空树中：<br>1.有且仅有一个特定的称为根(root)的结点。<br>2.当n&gt;1时，其余结点可分为m个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的子树。<br><img src="https://i.loli.net/2020/03/03/NOPTbjykq8Rzd7S.png" alt=""><br>树的定义中用到了递归的概念，需要强调的是，树的子树必须是互不相交的。<br>结点可以分为3类：根结点、内部结点和叶结点。如上图中，A是根结点，B、C、D、E是内部结点，F、G、H、I、J是叶结点。结点拥有的子树数称为结点的度，因为叶结点是没有子树的，所以叶结点的度为0。树的度是树内各结点的度的最大值。上面树中D的度最大为3，因此树的度为3。以后我们将要学习的二叉树，度为2。<br>结点间是有关系的。结点的子树的根称为该结点的孩子(child)。该结点称为孩子的双亲(parent)，同一个双亲的孩子之间互称为兄弟(sibling)，同理可以定义祖父(grandparent)和孙子(grandchild)。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中任一结点都成为该结点的子孙。<br>结点的层次(level)从根开始定义，根为第一层，根的孩子为第二层，…，双亲在同一层的结点互称为堂兄弟。树中结点的最大层次称为树的深度(depth)。<br><img src="https://i.loli.net/2020/03/03/YGmWpTvJPH8ehUa.png" alt=""><br>如果把树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。<br>森林是m(m&gt;=0)个互不相交的树的集合。  </p>
<h2 id="树的存储和表示"><a href="#树的存储和表示" class="headerlink" title="树的存储和表示"></a>树的存储和表示</h2><p>树有多种表示方法，不同的表示方法也代表了不同的存储方式，下面会对其进行介绍。  </p>
<h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>根据树的特点可知，<strong>除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲</strong>。因此我们可以以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在链表中的位置。<br><img src="https://i.loli.net/2020/03/03/Bs6gex1lWaSKHXV.png" alt=""><br><code>data</code>是数据域，存储结点的数据信息，<code>parent</code>是指针域，存储该结点的双亲的位置。根结点的位置域设置为-1。举例如上面的树，双亲表示法为：<br><img src="https://i.loli.net/2020/03/03/4bWwNaUgVxdDGik.png" alt=""><br>这种表示法可以很容易找到孩子的双亲，但要知道结点的孩子是什么，必须遍历完整个树。</p>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶结点则此单链表为空。然后n个头指针又组成一表，采用顺序存储结构，存放进一个一维数组中。如上面树的孩子表示法为：<br><img src="https://i.loli.net/2020/03/03/iTnkQD97yFVbWXS.png" alt=""><br>孩子表示法对于找到某个结点的某个孩子，或者某个结点的兄弟都很方便。但找到某个结点的双亲就需要遍历完整个树。<br>孩子表示法和双亲表示法各有优劣，显然可以将它们结合成双亲孩子表示法。</p>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>任意一个树，它的结点的第一个孩子和该结点的右兄弟如果存在就是唯一的。设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟（右边第一个兄弟）。<br><img src="https://i.loli.net/2020/03/03/U8dJRuIOLafoVsh.png" alt=""><br>这样通过变换可以将上面的树变成：<br><img src="https://i.loli.net/2020/03/03/m3GxhNeJ5HCdZKP.png" alt=""><br>简单变形一下为：<br><img src="https://i.loli.net/2020/03/03/VK1iAWjHTPoCDBF.png" alt=""><br>这其实是一个二叉树。孩子兄弟表示法最大的好处是将一个复杂的树变成了一个二叉树。只有两个指针域，一左一右。在后面讲树和二叉树的转换时会再提到该方法。</p>
<h2 id="树的遍历和应用"><a href="#树的遍历和应用" class="headerlink" title="树的遍历和应用"></a>树的遍历和应用</h2><p>树的遍历有两种：先根遍历和后根遍历。<br>树的先根遍历为先访问树的根结点，然后依次的先根遍历根的每个子树。如上面树的先根遍历顺序为：ABDGHICEJF。<br>树的后根遍历为先依次的后根遍历每个子树，然后访问树的根结点。如上面树的后根遍历顺序为：GHIDBJEFCA。<br>树有很多应用，流行的用途之一是许多常用操作系统中的目录结构，包括UNIX和DOS在内。下面是UNIX文件系统中一个典型的目录：<br><img src="https://i.loli.net/2020/03/03/ZhPsflGQjgrLdWq.png" alt="">  </p>
<p>在本篇当中讲了许多的有关树的概念内容，可能一时会记不住，在用到的时候需要多看回忆。在接下来将会介绍一种特殊的树：二叉树。它也是我们所学习的数据结构中的重点知识。 </p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>栈ADT和队列ADT</title>
    <url>/2020/03/01/%E6%A0%88ADT%E5%92%8C%E9%98%9F%E5%88%97ADT/</url>
    <content><![CDATA[<p>摘要：本篇将继续上一篇的讲解，对栈ADT和队列ADT作一下简单的介绍。因为有些相关的知识已经在C++ STL当中介绍过。所以本篇重点将会是介绍它们的应用。</p>
<a id="more"></a>
<h2 id="栈ADT"><a href="#栈ADT" class="headerlink" title="栈ADT"></a>栈ADT</h2><p>栈（stack）是一个带有限制的表。前面也说过它是后进先出的（LIFO），插入和删除只能在一个位置进行，即表的末端–栈顶（top）。<br>栈是一个表，任何能实现表的方法都能实现栈。<code>list</code>和<code>vector</code>都支持栈的操作，前面也已经讲过，因为它们的功能过于强大，所以才有了容器适配器。<br>栈的链表实现和数组实现与前面讲的表相似。在数组实现中，用下标为0的一端作栈底。<code>top</code>表示栈顶元素在数组中的位置，空栈的判定条件为<code>top=-1</code>。</p>
<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>1.平衡符号<br>编译器检查程序的语法错误，但是常常由于缺少一个符号而引起编译器上百行的诊断，因此我们希望有一个算法来检查符号。可以用栈来实现，比如<code>{[()]}</code>是合法的，而<code>{([)]}</code>是不合法的。<br>算法的实现原理为：做一个空栈，读入字符直到文件尾。如果字符是一个开放符号，则将其推入栈中。如果字符是一个封闭符号，则判断栈是否为空，为空则报错。否则将栈元素弹出，如果弹出的符号不是对应的开放符号也报错。在文件尾，如果栈非空报错。实现代码如下：  </p>
<pre><code>int peidui(string &amp;s1,string &amp;s2)
{
    if(s1==&quot;{&quot;)
    {
        if(s2==&quot;}&quot;)
        {
            return 1;
        }
        else return 0;
    }
    if(s1==&quot;(&quot;)
    {
        if(s2==&quot;)&quot;)
        {
            return 1;
        }
        else return 0;
    }
    if(s1==&quot;[&quot;)
    {
        if(s2==&quot;]&quot;)
        {
            return 1;
        }
        else return 0;
    }
}
int main()
{
    stack&lt;string&gt; s;
    string s1;
    string tem;
    cin&gt;&gt;s1;
    for(int i=0;i&lt;s1.length();i++)
    {
        tem=s1.at(i);
        if(s1.at(i)==&apos;{&apos;||s1.at(i)==&apos;(&apos;||s1.at(i)==&apos;[&apos;)
        {
            s.push(tem);
        }
        else
        {
            if(s.empty()==1)
            {
                cout&lt;&lt;&quot;error&quot;;
                return 0;
            }
            else
            {
                if(peidui(s.top(),tem)==1)
                {
                    s.pop();
                }
                else
                {
                    cout&lt;&lt;&quot;error&quot;;
                    return 0;    
                }
            }
        }
    }
    if(s.empty()==1)
    {
        cout&lt;&lt;&quot;true&quot;;
    }
    else
    {
        cout&lt;&lt;&quot;error&quot;;
    }
    return 0;
 } </code></pre><p>可以看到，定义了一个配对函数用来判断两个符号是否是一对的。在栈里面按符号进行判断。运行结果为：<br><img src="https://i.loli.net/2020/03/01/nYejlxfZ8ky5Aap.png" alt=""><br><img src="https://i.loli.net/2020/03/01/3WAnj7HZxGKr8Cd.png" alt="">  </p>
<p>2.逆波兰表达式<br>我们常用的表达式是中缀表达式，而逆波兰表达式又叫后缀表达式，波兰表达式则为前缀表达式。逆波兰表达式是操作数在前，再操作符号。举例如下：<br><code>1 + 2</code>的逆波兰表达式为<code>1 2 +</code><br><code>3 + 4 - 5</code>的逆波兰表达式为<code>3 4 + 5 -</code><br><code>2 * 3 + 7</code>的逆波兰表达式为<code>2 3 * 7 +</code><br>因此它的实现原理为：如果当前符号是数字，压栈。如果是运算符，弹出栈顶的两个元素并运算。再将运算结果压入栈中。直到扫描完整个字符串，栈里的就是结果。实现代码如下：  </p>
<pre><code>int exchange(char s)
{
    switch(s)
    {
        case &apos;1&apos;: return 1;break;
        case &apos;2&apos;: return 2;break;
        case &apos;3&apos;: return 3;break;
        case &apos;4&apos;: return 4;break;
        case &apos;5&apos;: return 5;break;
        case &apos;6&apos;: return 6;break;
        case &apos;7&apos;: return 7;break;
        case &apos;8&apos;: return 8;break;
        case &apos;9&apos;: return 9;break;
    }
}
int main()
{
    stack&lt;int&gt; s;
    char str[20];
    int a,b,c;
    cin&gt;&gt;str;
    for(int i=0;str[i]!=0;i++)
    {
        if(str[i]!=&apos;+&apos;&amp;&amp;str[i]!=&apos;-&apos;&amp;&amp;str[i]!=&apos;*&apos;&amp;&amp;str[i]!=&apos;/&apos;)
        {
            c=exchange(str[i]);
            s.push(c);
        }
        else
        {
            a=s.top();
            s.pop();
            b=s.top();
            s.pop();
            switch(str[i])
            {
                case &apos;+&apos;: b=a+b;s.push(b);break;
                case &apos;-&apos;: b=b-a;s.push(b);break;
                case &apos;*&apos;: b=a*b;s.push(b);break;
                case &apos;/&apos;: b=b/a;s.push(b);break;
                default: cout&lt;&lt;&quot;error&quot;;
            }
        }
    }
    cout&lt;&lt;s.top();
    return 0;
}</code></pre><p>从代码中可以看到，为了方便定义了一个转换函数，将字符转换成数字。输入字符串，判断是否为运算符，不是则将其通过转换函数变成数字压栈。运行结果为：<br><img src="https://i.loli.net/2020/03/02/SDtsPnzbIoGXyWl.png" alt=""><br><img src="https://i.loli.net/2020/03/02/RDCoxXNhvQkP1gd.png" alt="">  </p>
<h2 id="队列ADT"><a href="#队列ADT" class="headerlink" title="队列ADT"></a>队列ADT</h2><p>队列是一种先进先出的表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。<br>队列也有两种实现方式，数组和链队列。对于数组实现，可以使队列的头尾相接，构成循环队列来解决假溢出问题（即数组中还有位置，但是队尾无位置）。</p>
<h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><p>有许多算法使用队列给出高效运行时间。它们当中有些可以在图论中找到，后面的学习中会讨论它们。实际上，每一个实际生活中的排队都是一个队列。  </p>
<p>表、栈和队列或许在全部计算机科学中是3个基本的数据结构，大量的例子证明了它们广泛的用途。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>抽象数据类型和表ADT</title>
    <url>/2020/02/28/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%A1%A8ADT/</url>
    <content><![CDATA[<p>摘要：本篇将开始对数据结构进行学习。首先介绍一下什么是抽象数据类型，以及表的抽象数据类型是什么样的。怎么对表进行实现？最后将通过前面C++ STL中的容器对表做进一步的介绍。</p>
<a id="more"></a>
<p>抽象数据类型（Abstract Data Type,ADT）是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象，在ADT的定义中没有地方提到关于这组操作是如何实现的任何解释。抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是自定义的数据类型，比如我们定义一个<code>point</code>的抽象数据类型，它有<code>x,y,z</code>三个整型变量。抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。</p>
<h2 id="表ADT"><a href="#表ADT" class="headerlink" title="表ADT"></a>表ADT</h2><p>表是零个或多个数据元素的有限序列。元素是有顺序的，第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。表元素的个数n定义为表的长度，当n=0时，称为空表。在较复杂的表中，一个数据元素可以由若干个数据项组成。<br>根据表的特性，它有两种存储方式：顺序存储和链式存储。即用数组实现和链表实现。  </p>
<h3 id="表的简单数组实现"><a href="#表的简单数组实现" class="headerlink" title="表的简单数组实现"></a>表的简单数组实现</h3><p>表的顺序存储是用一段地址连续的存储单元依次存储表中的数据元素。因此可以用数组来实现。虽然数组由固定容量所创建，但是<code>vector</code>类（其内部存储一个数组）在需要的时候可以使容量成倍的增长。这就解决了数组大小的弊端。<br>表有几种常见的操作。如依次输出整个表、清空整个表、查找某一个元素、插入元素、删除元素等等。用数组可以实现上面的所有操作。当遍历和查找时，数组实现花费时间很少，这正是我们所期望的，在常数时间就可完成。然后当插入和删除时，却潜藏着昂贵的开销。在最坏的情形下，从表的前端插入，需要将整个数组后移一个位置来空出空间，而删除第一个元素则需要将表中的所有元素前移一个位置，因此这两种操作的最坏情况为O(n)。如果插入和删除操作发生在表的尾端，则只需要花费O(1)的时间。<br>存在许多情形，表是通过在尾端进行插入操作建成的，此后只发生访问操作。在这种情况下，数组是表的一种恰当的实现。然而，如果插入和删除操作遍及整个实现的表，特别是在表的前端，那么数组就不是一种好的选择。此时需要另一种实现：链表。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>为了避免插入和删除的线性开销，我们需要保证表可以不连续存储，即链式存储。<br><img src="https://i.loli.net/2020/02/28/JbE5rBc2Rkh8jMo.png" alt=""><br>链表由一系列结点组成，这些结点不必在内存中相连。一个结点包括两部分：数据域和指针域。结点中只包含一个指针域叫做单链表。规定最后一个结点指针为空。<br>当链表用来查找时，必须从头开始一个个往后找，因此时间复杂度为O(n)，比较耗费时间。插入和删除时的时间复杂度也是O(n)，因为需要先找到第i个结点，再进行插入和删除。但是当频繁的插入删除时，显然效率更高。<br>删除操作通过修改一个next指针来实现。如图：<br><img src="https://i.loli.net/2020/02/28/MV4WreUJCmEbk7o.png" alt=""><br>而插入操作则需要生成一个新结点，然后修改两个指针来实现，如图：<br><img src="https://i.loli.net/2020/02/28/CRwTNfOPGzY1SpA.png" alt=""><br>可以看到，如果知道变动将要的地方，那么插入或从链表中删除一项的操作不需要移动很多的项。现在的链表中每一项有它自身的数据以及指针指向下一项，但却没有跟它的上一项有关的东西。因此我们可以对指针域进行修改，使每个结点有两个指针域，一个指向前驱，一个指向后继。这种链表叫双向链表。<br><img src="https://i.loli.net/2020/02/28/EYMfZ9JdFhVmG5w.png" alt="">  </p>
<h2 id="C-中表的实现"><a href="#C-中表的实现" class="headerlink" title="C++中表的实现"></a>C++中表的实现</h2><p>在C++知识学习中讲过STL，STL中实现了很多常用的数据结构。本篇所将的表ADT就对应着STL中的<code>vector</code>和<code>list</code>类模板。<code>vector</code>提供表ADT的一种可增长数组实现。<code>list</code>则提供表ADT的双向链表实现。关于<code>vector</code>和<code>list</code>以及它们所包含的成员函数这里就不再介绍，在STL那几篇博客中都已经列出。当然我们也可以不用标准模板库中的<code>vector</code>和<code>list</code>，自己去写一个新的<code>vector</code>和<code>list</code>来实现上述的种种操作。根据不同的需求有不同的选择。<br>在下篇中将会讲另外两种数据结构栈ADT、队列ADT，它们的一部分知识也在STL中有过介绍，因此很多地方就不再详细说明。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法分析相关概念</title>
    <url>/2020/02/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>摘要：本篇将介绍一下在分析算法时所用到的一些知识。例如如何判断一个算法的好坏？怎么去计算算法的时间复杂度等等。通过本篇的介绍，能够更好的让我们对一个算法进行分析。</p>
<a id="more"></a>
<p>算法（algorithm)是为求解一个问题需要遵循的、被清楚的指定的简单指令的集合。对于一个问题，一旦某种算法给定并且被确定是正确的，那么重要的一步就是确定该算法将需要多少诸如时间或空间等的资源量的问题。一个程序的运行时间，依赖于算法的好坏和问题的输入规模。同一个问题的不同解决方法会花费的时间，内存各不相同。即使计算机在不停进步，有些算法依然需要花费大量时间，因此需要找到最优效率的算法。因此，一个算法的好坏或者性能由它的时间复杂度和空间复杂度决定。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的公式为S(n)，n为问题的规模。通常的复杂度指的都是时间复杂度。因此这里不再对空间复杂度过多解释，只简单说一下，在以后遇到时会具体介绍。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>算法的时间复杂度的分析就是针对每个输入规模值，计算基本运算的执行次数。某些情况下，基本运算的执行次数不仅取决于输入规模，还与输入值有关。简而言之，就是一个算法要花多长时间执行。即一个算法所有指令被执行的次数为T(n)。最佳情况时间复杂度称为B(n)，最差情况时间复杂度称为W(n)，平均情况时间复杂度为A(n), 对于一般的排序，讨论平均情况下的时间复杂度即可，但是对于电厂检测这种，就必须要考虑最差情况时间复杂度，因为出了差错是灾难性的。具体问题具体分析讨论哪种情况的时间复杂度。一般情况下，一个算法必须是O(nlogn)或者更佳时，我们才能假定它可以在可容忍时间内处理极大实例。一般在没有特殊说明的情况下，都是指最坏时间复杂度。<br>时间复杂度常用大O符号表示，T(n)是一个具体的函数，而大O表示则相当于时间复杂度的分级，常见的为:<br>O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)、O(n^3)、O(2^n)、O(n!)<br>为什么要分这几类呢？，举个例子，对于时间复杂度为n和n^2的两种算法，显然当n足够大时，第一种的效率总是高于第二种。那么100n和0.01n^2呢？若只比较一些数，如100以内的，第一种花费的时间大于第二种，但只要n&gt;10000,第一种还是效率高于第二种，只是需要n的值更大了而已。所以我们需要比较的是它们的相对增长率。因此看最终结果，引入了阶的概念。低阶的效率最终都是高于高阶的。我们只需要按阶次划分时间复杂度即可，不再考虑系数，以T(n)的最高阶作为O(n)。<br>如何计算时间复杂度？分析算法的复杂度，关键是分析循环结构的运行情况。</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>一个for循环的运行时间至多是该for循环内部那些语句（包括测试）的运行时间乘以迭代的次数。例如：</p>
<pre><code>for(int i=0;i&lt;n;i++)
{
    cout&lt;&lt;i;
}</code></pre><p>可以看到，输出语句执行了n次，还有一次判断语句(i=n)，总共执行了n+1次，复杂度为O(n)。</p>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>从里向外分析这些循环，在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积。 </p>
<pre><code>for(int i=0;i&lt;n;i++)
{
    for(int j=o;j&lt;n;j++)
    {
        cout&lt;&lt;i;
    }
}</code></pre><p>可以看到有两个for循环，复杂度为O(n^2)。</p>
<h3 id="顺序语句"><a href="#顺序语句" class="headerlink" title="顺序语句"></a>顺序语句</h3><p>将各个语句的运行时间求和即可。如将上面两个循环合并：</p>
<pre><code>for(int i=0;i&lt;n;i++)
{
    cout&lt;&lt;i;
}
for(int i=0;i&lt;n;i++)
{
    for(int j=o;j&lt;n;j++)
    {
        cout&lt;&lt;i;
    }
}</code></pre><p>因为取的是最高阶次，T(n)=n^2+n，复杂度仍为O(n^2)。</p>
<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if/else语句"></a>if/else语句</h3><p>对于if/else语句：</p>
<pre><code>if(condition)
    s1
else
    s2</code></pre><p>运行时间从不超过判断的运行时间再加上s1和s2中运行时间长者的总的运行时间。<br>对于其他情形的分析也是看执行次数，如递归等等。分析一个算法的时间复杂度是非常重要的，它能体现算法的性能。在后续对算法的学习当中，复杂度是必不可少的。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法初识</title>
    <url>/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<p>摘要:从本篇开始将进入到数据结构与算法的学习。前面已经讲解了C++的相关知识，使我们有了编写程序解决问题的能力。然而面对同一个问题，可能有很多种的解决方法，每种方法的效率也不相同。学会了数据结构与算法，才能使我们的程序更加健壮，更加具有效率。本篇将会对数据结构与算法进行一下简单介绍。</p>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。在计算机科学的发展过程中，数据结构也随之发展。程序设计中常用的数据结构包括如下几个：<br>数组(Array)、栈( Stack)、队列(Queue)、链表(List)、树(Tree)、图(Graph)、堆(Heap)、散列表(Hash)。<br>后续的学习中会对这些数据结构一一介绍。 </p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是用来操作数据结构的。举个例子，设有一组N个数而要确定其中的第k个最大者，这种问题为选择问题。我们编写一个程序来解决这个问题是很简单的。其中一个解法是将这N个数读进一个数组中，再通过某种简单的算法，比如冒泡排序法，以递减顺序将数组排序，然后返回位置k上的元素。<br>稍微好一点的算法可以先把前k个元素读入数组并(以递减的顺序)对其排序。然后，剩下的元素再逐个读入。当新元素被读到时，如果它小于数组中的第k个元素则忽略之，否则就将其放到数组中的正确位置上，同时将原数组中的最后一个元素挤出数组。当算法终止时，位十第k个位置上的元素作为答案返回。<br>那么哪个算法更好？两个算法都足够好吗？使用3000万个元素的随机文件和k=15000000进行模拟指出，两个算法在合理的时间量内均不能结束计算;每种算法都需要计算机处理若干天才能算完(不过最终还是给出了正确的答案)。在后面会讨论另一种算法，该算法将在1秒种左右给出问题的解。因此，虽然我们提出的两个算法都能算出结果，但是它们不能看作是好的算法，因为对于第三种算法能够在合理的时间内处理的输入数据量而言，这两种算法是完全不切实际的。<br>同一个问题的不同解决方法会花费的时间，内存各不相同。即使计算机在不停进步，有些算法依然需要花费大量时间，因此需要找到最优效率的算法。</p>
<h3 id="递归和迭代算法"><a href="#递归和迭代算法" class="headerlink" title="递归和迭代算法"></a>递归和迭代算法</h3><p>为了不使本篇全部都是概念理论上的内容，在这里我要讲一下递归和迭代算法。递归算法是非常有用的算法，在后续的学习中，它会被非常频繁的使用。递归算法在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。一个用其自身来定义的函数就称为递归的。递归的基本法则为：<br>1.基准情形。必须要有某些基准的情形，它们不用递归就能求解。<br>2.要有进展。对于那些要被递归求解的情形，递归调用必须总能够朝着一个基准情形进展。<br>3.设计法则。假设所有的递归调用都能运行。<br>4.合成效益法则。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。<br>举个例子，斐波那契数列，它的第n项等于第n-1和第n-2项的和。递归算法如下：  </p>
<pre><code>int q(int n)
{
    if(n==1)
    {
    return 1;
    }
    if(n==2)
    {
    return 1;
    }
    else
    {
    return (q(n-1)+q(n-2));
    }
}
int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;n+1;i++)
    cout&lt;&lt;q(i)&lt;&lt;&quot; &quot;;
    return 0;
}</code></pre><p>从代码中可以看到，基准情形就是n=1和n=2的情况，发展情形就是在n&gt;2时，会调用它的前两项，最终调用到基准情形。在函数当中调用了它本身。假设n=4，它会返回q(3)+q(2)的值，当运行到q(3)时，会调用函数自身，返回q(2)+q(1)的值，然后q(2)、q(1)又调用函数，返回1，最终求得q(3)为2，这时再去求解q(2)，最终q(4)为3。<br><strong>递归是重复调用函数本身，而迭代则是重复函数的一部分</strong>。上述斐波那契数列同样可以用迭代算法来写，如下：  </p>
<pre><code>int fib(int n)
{
    int i;
    vector&lt;int&gt; v(n);
    v[0]=0;
    v[1]=1;
    v[2]=1;
    i=3;
    while(i&lt;=n)
    {
        v[i]=v[i-1]+v[i-2];
        i++;
    }
    return v[n];    
}
int main()
{
    int n;
    cin&gt;&gt;n;
        cout&lt;&lt;fib(n);
    return 0;
}</code></pre><p>将斐波那契数列存放在数组中，通过while循环来迭代求解。一般情况下，迭代的执行速度比递归快。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>预处理器和多线程</title>
    <url>/2020/02/22/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>摘要：本篇将主要介绍C++中的预处理器和多线程。在预处理器里将讲解一些常用的预处理指令，而多线程也涉及到操作系统方面的知识，在这里只是简单介绍，后面会有更深入的学习。</p>
<a id="more"></a>
<p>前面已经写过很多的实例，虽然它们的作用各不相同，但它们都包含了同一句代码<code>#include&lt;iostream&gt;</code>，这个宏用于把头文件包含到源文件中。在这里就要讲一下这些以井号开头的指令。</p>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。所有的预处理器都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是C++语句，所以它们不会以分号（;）结尾。<br><code>#define</code>预处理指令用于创建符号常量，该符号常量通常称为宏，示例如下：  </p>
<pre><code>#define PI 3.14</code></pre><p>这样，在后面出现的所有PI都会被定义为3.14。也可以定义一个带有参数的宏，如：  </p>
<pre><code>#define min(a,b)(a&lt;b?a:b)</code></pre><p>有些指令可以用来有选择地对部分程序源代码进行编译，这个过程被称为条件编译。示例为：  </p>
<pre><code>#ifdef DEBUG 
cerr &lt;&lt; x &lt;&lt; endl; 
#endif</code></pre><p>如果在指令 <code>#ifdef DEBUG</code>之前已经定义了符号常量 <code>DEBUG</code>，则会对程序中的<code>cerr</code>语句进行编译。<code>#if</code>则表示非零时编译，为零时则不编译，相当于注释。  </p>
<pre><code>#if 0
cout&lt;&lt;a&lt;&lt;endl;
#endif  </code></pre><p>在C++程序中，把类接口与其实现分开是更为常见的。接口列出类和它的成员，而实现则提供函数的实现。接口放在以.h结尾的头文件中。需要接口知识的源代码必须要#include这个接口文件。为了防止一个接口被读两次。需要用到预处理指令。如下所示：  </p>
<pre><code>#ifndef IntCell_H
#define IntCell_H
...
...
#endif</code></pre><p>第一个指令判断是否定义过该文件，如果没有，定义并执行，如果已经定义过了，跳过转到endif。<br>C++中也定义了预定义宏，如下表所示：<br><img src="https://i.loli.net/2020/02/22/m9zS5rZtf8JIwXn.png" alt=""><br>最后以一个实例包含上述代码：  </p>
<pre><code>#define PI 3.14159
#define min(a,b)(a&lt;b?a:b)
int main ()
{
    int a,b;
    a=1;
    b=2;
    cout &lt;&lt; &quot;Value of PI :&quot; &lt;&lt; PI &lt;&lt; endl; 
    cout&lt;&lt;min(a,b)&lt;&lt;endl;    

#ifdef PI
    cout&lt;&lt;PI&lt;&lt;endl;
#endif

#if 0
    cout&lt;&lt;a&lt;&lt;endl;
#endif

     cout &lt;&lt; &quot;Value of __LINE__ : &quot; &lt;&lt; __LINE__ &lt;&lt; endl;
        cout &lt;&lt; &quot;Value of __FILE__ : &quot; &lt;&lt; __FILE__ &lt;&lt; endl;
       cout &lt;&lt; &quot;Value of __DATE__ : &quot; &lt;&lt; __DATE__ &lt;&lt; endl;
        cout &lt;&lt; &quot;Value of __TIME__ : &quot; &lt;&lt; __TIME__ &lt;&lt; endl;
        return 0;
} </code></pre><p>运行结果为：<br><img src="https://i.loli.net/2020/02/22/u8CkjlJyAvWT97Z.png" alt="">  </p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>说到多线程编程，那么就不得不提并行和并发，多线程是实现并发（并行）的一种手段。并行是指两个或多个独立的操作同时进行。注意这里是同时进行，区别于并发，在一个时间段内执行多个操作。在单核时代，多个线程是并发的，在一个时间段内轮流执行；在多核时代，多个线程可以实现真正的并行，在多核上真正独立的并行执行。例如现在常见的4核4线程可以并行4个线程；4核8线程则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。<br>通常，要实现并发有两种方法：多进程和多线程。使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出安全的代码。但这也造就了多进程并发的两个缺点：<br>1.在进程件的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。<br>2.运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。<br>由于多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发不是一个好的选择。<br>多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。<br>C++ 11的标准库中提供了多线程库，使用时需要<code>&lt;thread&gt;</code>头文件，该头文件主要包含了对线程的管理类<code>thread</code>以及其他管理线程相关的类。示例如下：  </p>
<pre><code>void print(int i)
{
    cout&lt;&lt;i&lt;&lt;endl;
}
int main()
{
    for(int i=0;i&lt;4;i++)
    {
        thread t(print,i);
        t.detach();
    }
    getchar();
    return 0;
}</code></pre><p>在一个for循环内，创建4个线程分别输出数字0、1、2、3，并且在每个数字的末尾输出换行符。语句<code>thread t(print, i)</code>创建一个线程<code>t</code>，该线程运行<code>print</code>函数，第二个参数<code>i</code>是传递给<code>print</code>的参数。<code>t</code>在创建完成后自动启动，<code>t.detach</code>表示该线程在后台允许，无需等待该线程完成，继续执行后面的语句。这段代码的功能是很简单的，如果是顺序执行的话，其结果很容易预测得到为0、1、2、3且每个数字都是单独一行。然后实际运行情况却不是这样，每次可能都不一样，其中一次为：<br><img src="https://i.loli.net/2020/02/22/RAcU94vnlKuqPSp.png" alt=""><br>可以看出，首先输出了0和换行符；紧接着却连续输出了213。不是说好的并行么，同时执行，怎么还有先后的顺序？这就涉及到多线程编程最核心的问题了资源竞争。CPU有4核，可以同时执行4个线程这是没有问题了，但是控制台却只有一个，同时只能有一个线程拥有这个唯一的控制台，将数字输出。将上面代码创建的四个线程进行编号：t0,t1,t2,t3，分别输出的数字：0,1,2,3。参照上图的执行结果，控制台的拥有权的转移如下：<br>t0拥有控制台，输出了数字0和换行符，t0线程完成，控制的拥有权转移到了t2；(0\n)<br>t2输出了数字2，但是其没有来的及输出换行符，控制的拥有权却转移到了t3（2）<br>t1输出了数字1，但是其没有来的及输出换行符，控制的拥有权却转移到了t2 （1）<br>t3输出了数字3，但是其没有来的及输出换行符，控制的拥有权却转移到了t1 （3)<br>最后它们再把换行符输出。<br>由于控制台是系统资源，这里控制台拥有权的管理是操作系统完成的。但是，假如是多个线程共享进程空间的数据，这就需要自己写代码控制，每个线程何时能够拥有共享数据进行操作。共享数据的管理以及线程间的通信，是多线程编程的两大核心。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>强制类型转换和异常处理</title>
    <url>/2020/02/20/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>摘要：本篇要讲解的内容是强制类型转换和异常处理。在程序运行过程中会出现很多问题，有些特殊情况被称为异常，我们需要捕捉到异常并处理。在前面C语言中已经讲过强制类型转换，在本篇中将更进一步讲解C++中的各种强制类型转换。</p>
<a id="more"></a>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>在C++中的强制类型转换有四种，分别是：<code>static_cast</code>， <code>reinterpret_cast</code>， <code>const_cast</code>，  <code>dynamic_cast</code>。下面将对这四种分别进行讲解。  </p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>前面在C语言的强制类型转换中讲过，转换是有风险的，而C语言的强制类型转换无法反映风险。在C++中，<code>static_cast</code>用来进行比较“自然”和低风险的转换，比如整型和实数型、字符型之间互相转换。它不能在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，也不能用于不同类型的引用之间的转换。例如：  </p>
<pre><code>int n;
char *p=&quot;hello&quot;;
n=static_cast&lt;int&gt;(3.14);  //n的值变为3
n=static_cast&lt;int&gt;(p);     //编译错误，static_cast不能将指针转换成整型</code></pre><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p><code>reinterpret_cast</code>用于进行各种不同类型的指针之间的转换、不同类型引用之间转换、以及指针和能容纳下指针的整数类型之间的转换。转换的时候，执行的是逐个比特拷贝的操作。举例如下：  </p>
<pre><code>class A
{
    public:
        int i;
        int j;
        A(int n):i(n),j(n){}
};
int main()
{
    A a(100);
    int &amp;r=reinterpret_cast&lt;int&amp;&gt;(a);  //强行让r引用a
    r=200;                      //把a.i变成了200
    cout&lt;&lt;a.i&lt;&lt;&quot;,&quot;&lt;&lt;a.j&lt;&lt;endl;  //输出200，100
    return 0;
}</code></pre><p>在内存里面按顺序存放了i和j，这是强制让r引用a，r就只指向了i，令r等于200，相当于修改了i，j没有改变。</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>用来进行去除<code>const</code>属性的转换。将<code>const</code>引用转换成同类型的非<code>const</code>引用，将<code>const</code>指针转换为同类型的非<code>const</code>指针。示例如下：  </p>
<pre><code>const string s=&quot;Inception&quot;;         //本来只能赋给一个const的引用
string &amp;p=const_cast&lt;string &amp;&gt;(s); //去除const属性，且能通过p修改s
string *ps=const_cast&lt;string*&gt;(&amp;s);  </code></pre><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p><code>dynamic_cast</code>专门用于将多态基类的指针或引用，强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回NULL指针。<code>dynamic_cast</code>不能用于将非多态基类的指针或引用，强制转换为派生类的指针或引用（包含虚函数的基类是多态基类）。  </p>
<pre><code>Base *pb=&amp; d;
pd=dynamic_cast&lt;Derived*&gt;(pb);
if(pd==NULL)
{
    cout&lt;&lt;&quot;unsafe dynamic_cast&quot;&lt;&lt;endl;
}</code></pre><p>引用的强制转换不会为空，那该如何判断转换是否安全呢？不安全会抛出异常，因此需要进行异常处理。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>程序运行中难免发生错误，引起这些异常情况的原因很多，我们希望能够发现异常。需要一种手段，把异常与函数的接口分开，并且能够区分不同的异常。在函数体外捕获所发生的异常，并提供更多的异常信息。C++异常处理的3个关键字为：<code>try</code>、<code>catch</code>、<code>throw</code>。<br><code>throw</code>: 当问题出现时，程序会抛出一个异常。这是通过使用<code>throw</code>关键字来完成的。<br><code>catch</code>: 在您想要处理问题的地方，通过异常处理程序捕获异常。<code>catch</code>关键字用于捕获异常。<br><code>try</code>: <code>try</code>块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个<code>catch</code>块。<br>先在<code>try</code>块进行判断，是否抛出了异常，没有抛出，跳过<code>catch</code>块继续进行，抛出后直接转到<code>catch</code>块，<code>try</code>块不再运行。并且<code>catch</code>块以从上到下的顺序查找，只执行一次。<br>示例代码为：  </p>
<pre><code>int divide(int a,int b)
{
    if(b==0)
    {
        throw 1;
    }
    else if(a==0)
    {
        throw 1.5;
    }
    else
        return a/b;
 } 
 int main()
 {
     int m,n,p;
     for(int i=0;i&lt;3;i++)
     {
         cin&gt;&gt;m&gt;&gt;n;
         try{
             p=divide(m,n);
             cout&lt;&lt;p&lt;&lt;endl;
            cout&lt;&lt;&quot;正常运行&quot;&lt;&lt;endl;
         }
         catch(int j)
        {
            cout&lt;&lt;&quot;被除数为零&quot;&lt;&lt;endl;     
        }
        catch(double j)
        {
            cout&lt;&lt;&quot;除数为零&quot;&lt;&lt;endl;     
        }
    }
     return 0;
 }</code></pre><p>从代码中可以看到，定义了一个函数用于两个数相除，设置了两种异常情况，一种是除数为零，一种是被除数为零，当被除数为零时，抛出异常，抛出的是整型异常 1。当除数为零时，抛出异常，抛出的是double型异常 1.5。在主函数里去捕获异常，若捕获到整型异常，输出<code>被除数为零</code>。若捕获到double型异常，输出<code>除数为零</code>。运行结果如下：<br><img src="https://i.loli.net/2020/02/20/W8pFhzYoyvGOLXT.png" alt=""><br>从结果中可以看到，当除数和被除数都不为零时，正常运行，跳过<code>catch</code>块，而当发生异常时，由<code>try</code>块直接跳到了<code>catch</code>块。<br>如果异常只是抛出没有被处理，就会被抛给上一层的函数（异常再抛出）。在C++中也定义了标准异常类，C++标准库中有一些类代表异常，这些类都是从<code>exception</code>类派生而来。在这里就不再具体介绍，需要的可以自行了解。  </p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>C++11新特性2</title>
    <url>/2020/02/18/C++11%E6%96%B0%E7%89%B9%E6%80%A72/</url>
    <content><![CDATA[<p>摘要：本篇将继续对C++ 11的新特性进行讲解。主要内容有lambda表达式、右值引用和move语义，在讲解右值引用时也会对常见的左值引用、参数传递等方法做个总结。</p>
<a id="more"></a>
<p>C++ 11中还有许多的特性，在这里我将选择其中几个再讲解。</p>
<h2 id="右值引用和move语义"><a href="#右值引用和move语义" class="headerlink" title="右值引用和move语义"></a>右值引用和move语义</h2><p>前面已经讲过引用的概念，即相当于给对象一个别名。这里出现左值和右值。左值相当于一个标识非临时性对象的表达式。右值则是标识临时性对象的表达式，或者是一个不与任何对象相联系的值（如字面值常数1，2，3等）。举例如下：  </p>
<pre><code>vector&lt;string&gt; arr(3); 
const int x=2; 
int y;   
int z=x+y;  
string str=&quot;foo&quot;;  
vector&lt;string&gt; *ptr=&amp;arr;</code></pre><p>其中<code>arr</code>,<code>str</code>,<code>y</code>,<code>z</code>,<code>ptr</code>,<code>*ptr</code>都是左值，<code>x</code>也是左值，不过它是一个不可修改的左值。<strong>一般的法则是，如果程序中有一个变量名，那么它就是一个左值，而不管变量是否可修改</strong>。<br>其中<code>2</code>，<code>x+y</code>，<code>&quot;foo&quot;</code>, <code>str.sub(0,1)</code>都是右值，可以看到它们均为字面值，而不是变量名，<code>x+y</code>是一个右值，因为它的值是临时的，但是在被赋给<code>z</code>之前，它要被存放在某个地方。<strong>如果函数调用计算一个其值在调用前不存在并且一旦调用终止就不再存在的表达式，那么它很可能是一个右值，除非它在别处被复制</strong>。<br>在C++ 11中，左值引用是通过在某个类型后放置一个符号<code>&amp;</code>而被声明的，此时一个左值引用变成了它所引用对象的同义词（别名），如：</p>
<pre><code>string  str=&quot;hell&quot;;  
string &amp;rstr=str;</code></pre><p><code>rstr</code>是<code>str</code>的另一个名字，此时它们表示的是同一对象，<code>rstr==str</code>。<br>右值引用是通过在某个类型后放置一个符号<code>&amp;&amp;</code>而被声明的。右值引用与左值引用具有相同的特征，但右值引用也可以引用一个右值（即一个临时量），如：</p>
<pre><code>string  str=&quot;hello&quot;;  
string &amp;&amp;bad1=&quot;hello&quot;; 
string &amp;&amp;bad2=str+&quot; &quot;;
string &amp;&amp;sub=str.substr(0,4);</code></pre><p>在介绍了什么是左值引用和右值引用后，再来说一下它们的用途。左值引用用途：<br>1.给结构复杂的名称起别名，减少书写麻烦。<br>2.范围for循环。<br>若让一个vector对象的所有值都加1，for循环如下：  </p>
<pre><code>for(int i=0;i&lt;arr.size();++i)
{  
    ++arr[i];
}</code></pre><p>使用范围for循环更方便，但直接写是不行的，因为这样x是每一个值的拷贝，而不是本身：  </p>
<pre><code>for( auto x : arr)
{
    ++x;
}</code></pre><p>这时就需要用到引用，引用的范围for循环如下：<br>    for( auto &amp;x : arr)<br>    {<br>        ++x;<br>    }<br>3.避免赋值<br>这是最重要的一点，当我们用引用时，传递的不再是一个复制品，而是本体。<br>许多语言，包括C和Java，都是用传值调用传递所有参数的：把实参复制到形参。但是，C++中的参数可能是些大的复杂的对象，这些对象复制起来效率很低，而且有时候我们也希望能够改变传递过来的值。于是有了C++中的3种参数传递机制，而C++ 11又添加了第四种：传右值引用。首先讲讲前3种参数传递机制，示例如下：  </p>
<pre><code>double average(double a,double b);  
void swap(double a,double b);
string randomItem(vector&lt;string&gt; arr);//返回arr中的一个随机项</code></pre><p> 第一个可以用传值调用，比如求<code>x</code>和<code>y</code>的平均值，只需要<code>x</code>复制给<code>a</code>，<code>y</code>复制给<code>b</code>，返回平均值即可。<code>x</code>和<code>y</code>不需要改变。<br>但在第二个就不能用传值调用，而需要传引用。因为若传值调用，传的是<code>x</code>和<code>y</code>的复制，不论怎么样<code>x</code>，<code>y</code>都不会改变。<strong>我们希望的是通过函数交换<code>x</code>和<code>y</code>，而不是交换它们的复制品</strong>。<br>第三个只是想要查找而不改变，因此是传常量引用。<br>传值、传引用、传常量引用是C++的3种参数传递机制（这里都指的左值），它们有各自的用途，接下来说C++ 11添加的第四种，传右值引用。<br>传右值引用的核心概念在于右值中存储的是要销毁的临时量，像<code>x=rval</code>这样的表达式（<code>rval</code>是一个右值）可以通过移动（<code>move</code>）而不是复制来实现。移动一个对象的状态常常比复制它要容易的多。<br>在C++ 11中，如果赋值运算符的右边（或构造函数）是一个右值，那么当对象支持移动操作时我们能够自动的避免复制。vector是支持移动操作的。<br>但是很多情况下我们所见到的都是左值，那么应该怎么移动呢？这里需要讲一个函数<code>std::move</code>，<strong>它能将任何左值转换成右值。它是不移动数据的，只是使一个值易于移动</strong>。这样，我们可以重新编写交换函数，以右值引用的方式移动交换，如下：  </p>
<pre><code>void swap(vector&lt;string&gt; &amp;x,vector&lt;string&gt; &amp;x)
{
    vector&lt;string&gt; tmp=std::move( x );
    x=std::move( y );
    y=std::move( tmp );
}</code></pre><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>前面已经讲过STL里<code>sort()</code>算法的定义如下：  </p>
<pre><code>template&lt;class Ranlt,class Pred&gt;
void sort(Ranlt first,Ranlt last,Pred pr);</code></pre><p>默认按升序排列，判断x是否应该比y靠前，就看pr(x,y)是否为true。假如我们要让容器中元素按从小到大排列，就要修改<code>pr()</code>函数的定义。可以看出还是比较麻烦的，那么有没有什么简单的办法来实现自定义比较呢？<br>C++ 11新特性中添加了lambda表达式，它本质上是一个函数，但是使我们可以不再去定义类和传统的函数那样麻烦，使得变的简化。lambda表达式的定义如下：  </p>
<pre><code>[外部变量访问方式说明符]（参数表）-&gt;返回值类型{ 语句组}</code></pre><p>外部变量访问方式说明符表示了不同的含义：<br>[=] 以传值的形式使用所有外部变量<br>[&amp;] 以引用形式使用所有外部变量<br>[x,&amp;y] x以传值形式使用，y以引用形式使用<br>[=,&amp;x,&amp;y] x，y以引用形式，其他以传值形式使用<br>[&amp;,x,y] x，y以传值形式，其他以引用形式使用<br><code>-&gt;返回值类型</code> 也可以没有，没有则编译器自动判断返回值类型。举个例子：  </p>
<pre><code>auto ff=[=,&amp;y,&amp;z](int n){
cout&lt;&lt;x&lt;&lt;endl; y++;z++;return n*n;};</code></pre><p>x以传值形式，y,z以引用形式，如果输出ff(15)，则结果为225，且y，z都加1。接下来说一下它的应用，以上面的<code>sort()</code>函数为例，若想要实现数组元素按个位数从小到大排列，该怎么定义？代码如下：  </p>
<pre><code>int main()
{
    auto m=[](double a,double b){return a+b;};
    cout&lt;&lt;m(1.2,2.5)&lt;&lt;endl;
    int a[4]{11,2,24,33};
    sort(a,a+4);
    for(int i=0;i&lt;4;i++)
    {
        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    sort(a,a+4,[](int x,int y)-&gt;bool{return x%10&lt;y%10;});
    for_each(a,a+4,[](int x){cout&lt;&lt;x&lt;&lt;&quot; &quot;;});
    return 0;
}</code></pre><p>可以看到代码中共定义了3个lambda表达式，第一个是将两个变量相加。然后定义了一个数组<code>a[4]</code>，其中元素为11，2，24，33，然后调用<code>sort()</code>函数默认从小到大排序再输出，结果应该为2，11，24，33。接下来使用lambda表达式，使排序规则变为比较个位数的大小。可以看到返回值类型为布尔型，若x的个位数比y的个位数小则返回true。当排完序以后用<code>for_each()</code>函数操作输出，本身<code>for_each()</code>函数是不输出数据的，但我们定义lambda表达式，将其数据输出。最后运行结果为：<br><img src="https://i.loli.net/2020/02/18/u8cf5729DLpxM4T.png" alt=""><br>上面虽然只是简单的运用了lambda表达式，但是还是可以感觉到它比传统的再去定义类和函数要方便许多，lambda表达式也不仅限于在这些特定的算法中使用，因此它是非常好用的一个新特性。<br>到此就简单的介绍完了C++ 11的新特性，虽然只介绍了其中的一小部分，但可以看到C++ 11的变化还是很大的，它使得C++更加的全面，也提高了效率，正是不断的对C++进行更新，才使得C++经久不衰。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 11新特性1</title>
    <url>/2020/02/15/C++11%E6%96%B0%E7%89%B9%E6%80%A71/</url>
    <content><![CDATA[<p>摘要：本篇将介绍C++ 11的新特性。这里的11指的是一个版号。C++是在不断更新的，使得程序更加稳定安全，功能也更加强大。因为要介绍的新特性有许多，所以将会分为两篇介绍，本篇将主要介绍统一初始化、auto关键字、decltype关键字、智能指针和空指针等。其他部分将会在下一篇中进行讲解。</p>
<a id="more"></a>
<p>1998年是C++标准委员会成立的第一年，以后每五年视实际需要更新一次标准，它开发于1998年并于2003年更新，统称为C++ 98或者C++ 03，国际标准化组织于2011年9月1号出版发布ISO/IEC 14882:2011，称为C++ 11。相比于C++98/03，C++ 11则带来了数量可观的变化，其中包含了约140个新特性，以及对C++03标准中约600个缺陷的修正，这使得C++ 11更像是从C++ 98/03中孕育出的一种新语言。相比较而言，C++ 11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率。   </p>
<h2 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h2><p>初始化是程序必不可少的，不管是一个简单的数组，还是一个对象，我们都需要对其建立时进行初始化。而在以前的定义中，若要定义一个动态数组v，其中的元素为1 2 3 4 5，定义如下：  </p>
<pre><code>vector&lt;int&gt; v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
v.push_back(4);
v.push_back(4);</code></pre><p>可以看到是很麻烦的，而在C++ 11中，我们可以像初始化普通数组一样去初始化自定义类型，用<code>{}</code>进行初始化，如：</p>
<pre><code>vector&lt;int&gt; v{1,2,3,4,5};
int arr[3]{1,2,3};
string s{&quot;hello&quot;};
int *p=new int[20]{1,2,3};</code></pre><p>即使在类里面也可以省略构造函数，对成员变量默认初始值：  </p>
<pre><code>class B
{
    public:
        int m=20;
        int n;
};</code></pre><p>对类的对象实例进行初始化：</p>
<pre><code>A obj1;
A obj2{5};
A obj3{};</code></pre><p>当中A是一个类，设其有多个构造函数，则obj1和obj3调用的就是无参构造函数，obj2调用的是单参数构造函数。以前我们也用圆括号来定义，如<code>A obj(2)</code>虽然这样也可以，但是括号里必须有参数，不然就变成了函数对象。<strong>所以统一的初始化解决了这种混乱现象</strong>。用统一的初始化方法使得语法更加简单，提高了效率，非常的实用。</p>
<h2 id="auto和decltype关键字"><a href="#auto和decltype关键字" class="headerlink" title="auto和decltype关键字"></a>auto和decltype关键字</h2><p>在C语言中也有auto关键字，使用auto关键字的变量，称为自动变量，是具有自动存储器的局部变量。而在C++ 11中，它被赋予了新的含义，作为一个新的类型指示符来指示编译器，编译器可以自动判断变量的类型。示例如下：  </p>
<pre><code>auto i=100;         // i是int
auto p= new A();    //p是A*
auto k=34343LL;    //k是long long
map&lt;string,int,greater&lt;string&gt;&gt; mp;
for(auto i=mp.begin;i!=map.end();++i)
cout&lt;&lt;i-&gt;first&lt;&lt;”,”&lt;&lt;i-&gt;second;  </code></pre><p>迭代器i的类型是<code>map&lt;string,int,greater&lt;string&gt;&gt;::iterator</code>，使用auto自动定义类型就可以不用再写这么长的代码来定义了。当然这只是auto的简单用法，它还有更大的作用。</p>
<pre><code>class A
{
};
A operator+(int n,A &amp;a)
{
    return a;
}
template&lt;class T1,class T2&gt;
auto add(T1 x,T2 y)-&gt;decltype(x+y)
{
    return x+y;
 } 
int main()
{ 
    auto d=add(100,0.5);        
    auto k=add(100,A());       
    return 0;
}</code></pre><p>代码中定义了一个类A，然后重载了<code>+</code>运算符，重载为普通函数，使得<code>n+A的对象</code>返回值为A的对象，又定义了一个函数模板，函数为<code>add</code>，使两个T1和T2类型的变量相加，由于并不知道相加后返回值是什么类型，所以使用auto关键字。<code>-&gt;decltype(x+y)</code>表示的也是返回值类型，decltype关键字会在下面介绍。在主函数里使用<code>add</code>函数将100和0.5加起来，显然结果是100.5，所以d应该是double型的变量。然后将100与A对象加起来，由于前面重载了<code>+</code>运算符，所以结果为A的对象，k是A类型。通过这段代码可以看到auto关键字在函数编写上有很大的作用，在很多情况下我们是无法确定返回值类型的，尤其在遇到模板相关时，这时，使用auto关键字就会带来很大的方便。<br>decltype关键字的作用是求表达式的类型。示例如下：  </p>
<pre><code>int i;
double t; 
structA{double x;}; 
const A* a=new A();

decltype(a) x1; //x1是A*类型
decltype(i) x2; //x2是int类型
decltype(a-&gt;X) x3; //x3是double类型</code></pre><p>x2的类型由<code>decltype(i)</code>决定，i是int型，所以x2是int类型，其他同理。</p>
<h2 id="智能指针和空指针"><a href="#智能指针和空指针" class="headerlink" title="智能指针和空指针"></a>智能指针和空指针</h2><p>首先介绍一下空指针，平常定义指针为空时：</p>
<pre><code>int *p=NULL;</code></pre><p>在C++ 11新特性里增加了空指针nullptr，定义时：</p>
<pre><code>int *p=nullptr;</code></pre><p>其实这里的两个指针p是相等的，而空指针的作用是使得更能体现指针的特征。同时空指针可以转换成布尔变量，输出的结果为false。</p>
<pre><code>bool b=nullptr;  //b=false</code></pre><p>智能指针shared_ptr的头文件为<code>&lt;memory&gt;</code>，通过shared_ptr的构造函数，可以让shared_ptr对象托管一个new运算符返回的指针。写法如下：</p>
<pre><code>shared_ptr&lt;T&gt; ptr(new T);</code></pre><p>其中T可以是int，char，类名等各种类型。此后ptr就可以像<code>T*</code>类型的指针一样来使用，即*ptr就是用new动态分配的那个对象，而且不必操心释放内存的事。多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时，delete该指针。shared_ptr对象不能托管指向动态分配的数组的指针，否则程序运行会出错。具体示例如下：  </p>
<pre><code>struct A
{
    int n;
    A(int m=0):n(m)
    {
    }
    ~A()
    {
        cout&lt;&lt;n&lt;&lt;&quot;  ~A&quot;&lt;&lt;endl;
    }
 } ;
 int main()
 {
     A* p=new A(2);
     shared_ptr&lt;A&gt; ptr1(p);    //ptr1托管A(2) 
     cout&lt;&lt;ptr1-&gt;n&lt;&lt;endl;
     shared_ptr&lt;A&gt; ptr2(ptr1);  //ptr2也托管A(2)
     cout&lt;&lt;(*ptr2).n&lt;&lt;endl;
     A* p1=new A(3);
     shared_ptr&lt;A&gt; ptr3(p1);   //ptr3托管A(3)
     cout&lt;&lt;ptr3-&gt;n&lt;&lt;endl;
     ptr2.reset();            //ptr2放弃托管A(2)
    if(!ptr2)
    {
        cout&lt;&lt;&quot;ptr2 is null&quot;&lt;&lt;endl;
     } 
    ptr2=ptr3;               //ptr2托管A(3)
    cout&lt;&lt;ptr2-&gt;n&lt;&lt;endl;
    shared_ptr&lt;A&gt; ptr4;
 //    ptr4.reset(p);            // 不增加托管计数，会使得释放2次，出错 
     cout&lt;&lt;&quot;end&quot;&lt;&lt;endl;
     return 0;
 }</code></pre><p>定义了一个类A，成员变量n，然后构造函数和析构函数。在主函数里定义指针p指向new出的A(2)，然后用智能指针定义ptr1托管p，即ptr1指向A(2)，输出n值验证。然后定义了智能指针ptr2，也托管A(2)，这是A(2)的托管计数为2。又定义了一个指针p1指向A(3)，智能指针ptr3托管A(3)，这是令ptr2放弃托管A(2)，判断一下它为空指针，再令其托管A(3)。这样到最后相当于ptr1托管A(2)，ptr2和ptr3托管A(3)。因此最后结束的时候删除A(2)和A(3)。运行结果为：<br><img src="https://i.loli.net/2020/02/15/Ut9judkxXmWCTYn.png" alt=""><br>智能指针中需要注意一点，可以看到上面代码中的被注释掉的一句<code>ptr4.reset(p);</code>，这句的意思是使ptr4托管p即ptr4指向A(2)，但是编译器却认为这个p与ptr1托管的p是不同的，即不增加托管次数，将它们当作两个指针。所以当结束的时候，A(2)就会被删除2次，因此出错。</p>
<p>在下篇中将会继续对C++ 11新特性进行介绍，比如右值引用、move语义、Lambda表达式等，它们也都有着很大的作用。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>STL算法</title>
    <url>/2020/02/13/STL%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>摘要：本篇将介绍STL的最后一个部分：算法。算法对于程序是非常重要的，在STL中，我们需要用容器来实现需求，而作用在这些容器上的算法则必须要求了解才行。本篇博客会介绍STL中算法的种类以及它们的功能。</p>
<a id="more"></a>
<p>STL算法就是一个个函数模板，它们大多数在头文件<code>&lt;algorithm&gt;</code>中定义。STL中提供能在各种容器中通用的算法，比如查找、排序等。<br>算法通过迭代器来操纵容器中的元素，许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如排序、查找等算法。<br>有些算法是返回一个迭代器，比如<code>find()</code>算法：在容器中查找一个元素，并返回一个指向该元素的迭代器。<br>前面已经说过，算法并不是STL特有的，算法可以处理容器，也可以处理普通数组。  </p>
<h2 id="不变序列算法"><a href="#不变序列算法" class="headerlink" title="不变序列算法"></a>不变序列算法</h2><p>该类算法不会修改算法所作用的容器或对象，适用于顺序容器和关联容器，时间复杂度都是O(n)。<br><code>min</code> :求两个对象中较小的<br><code>max</code> :求两个对象中较大的<br><code>min_element</code> :求区间中的最小值<br><code>max_element</code> :求区间中的最大值<br><code>count</code> :计算区间中等于某值的区间个数<br><code>find</code> :在区间中查找等于某值的元素<br><code>search</code> :在区间中查找另一个区间第一次出现的位置<br><code>equal</code> :判断两区间是否相等<br><code>mismatch</code> :逐个比较两个区间中的元素，返回第一次发生不相等的元素的位置<br>上面只是列举了一部分，在这里选择<code>find()</code>算法简单介绍，因为查找算法是非常常用的。<code>find()</code>算法的定义为：</p>
<pre><code>template&lt;class InIt,class T&gt;
InIt find(InIt first,InIt last,const T&amp; val);</code></pre><p>first和last这两个参数都是容器的迭代器，它们给出了容器中的查找区间起点和终点[first，last）。区间的起点是位于查找范围之中的，而终点不是。find在[first,last）查找等于val的元素。<br>函数返回值是一个迭代器。如果找到，则该迭代器指向被找到的元素。如果找不到，则该迭代器等于last。示例如下：  </p>
<pre><code>p=find(v.begin(),v.end(),3)；  //查找v中等于3的元素的迭代器
if(p!=v.end())
{
    cout&lt;&lt;*p;
}
if(p==v.end())
{
     cout&lt;&lt;”not find”;
}</code></pre><p>在容器v中查找等于3的元素的迭代器，然后赋值给迭代器p，如果查找不到，则把v中最后一个元素的迭代器赋值给p，判断p是否为最后一个元素的迭代器，不是则说明v中有等于3的元素，输出。否则则输出找不到。</p>
<h2 id="变值算法"><a href="#变值算法" class="headerlink" title="变值算法"></a>变值算法</h2><p>此类算法会修改源区间或目标区间元素的值。<strong>值被修改的那个区间，不可以是属于关联容器的</strong>。<br><code>for_each</code> :对区间中的每个元素都做某种操作<br><code>copy</code> :赋值一个区间到别处<br><code>transform</code> :将一个区间的元素变形后拷贝到另一个区间<br><code>fill</code> :用某个值填充区间<br><code>generate</code> :用某个操作的结果填充区间<br><code>replace</code> :将区间中的某个值替换成另一个值<br>这里说一下<code>copy()</code>算法，定义为：</p>
<pre><code>ostream_iterator&lt;int&gt; output(cout,&quot;&quot;);
copy(v.begin(),v.end(),output);</code></pre><p>定义了一个<code>ostream_iterator&lt;int&gt;</code>对象，可以通过cout输出以“”（空格）分割的一个个整数。然后在<code>copy()</code>里调用output，导致v的内容在cout上输出。</p>
<h2 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h2><p>删除算法用于删除一个容器中的某些元素。但是需要说明的是，<strong>删除不会使容器中的元素减少</strong>。将所有应该被删除的元素看成空位子，用留下的元素从后往前移，依次去填空位子，元素往前移后，它原来的位置也是空位子，由后面的元素补上，最后没有被填上的空位子，维持其原来的值不变。删除算法不应作用于关联容器。<br><code>remove</code> :删除区间中等于某个值的元素<br><code>remove_if</code> :删除区间中满足某种条件的元素<br><code>unique</code> :删除区间中连续相等的元素，只留下一个<br><code>unique_copy</code> :拷贝区间到另一个区间，连续相等的元素只拷贝一个<br>算法复杂度都是O(n)。</p>
<h2 id="变序算法"><a href="#变序算法" class="headerlink" title="变序算法"></a>变序算法</h2><p>变序算法改变容器中元素的顺序，但是不改变元素的值。变序算法不适用关联容器，算法复杂度都是O(n)。<br><code>reverse</code> :颠倒区间的前后次序<br><code>reverse_copy</code> :把一个区间颠倒后的结果拷贝到另一个区间，源区间不变<br><code>ratate</code> :将区间进行循环左移<br><code>random_shuffle</code> :随机打乱区间中的元素<br><code>next_permumation</code> :对区间中的元素进行全排列<br>这里说明一个<code>random_shuffle</code>算法，定义为：</p>
<pre><code>template&lt;class Ranlt&gt;
void random_shuffle(Ranlt first,Ranlt last);</code></pre><p>随机打乱[first,last)中的元素，适用于能随机访问的容器。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>比上面的变序算法复杂度更高，一般是O(nlong(n))。排序算法需要随机访问迭代器的支持，不适用关联容器和<code>list</code>。<br><code>sort</code> :将区间从小到大排列<br><code>stable_sort</code> :将区间从小到大排列，并保持相等元素间的相对次序<br><code>partial_sort</code> :对区间部分排序，直到最小的n个元素就位<br><code>partial_sort_copy</code> :将区间前n个元素的排序结果拷贝到别处<br><code>nth_element</code> :对区间部分排序，使得第n小的元素就位，而且比它小的都在它前面，比它大的都在它后面<br>显然<code>sort()</code>算法是最常用的，若定义为：</p>
<pre><code>template&lt;class Ranlt&gt;
void sort(Ranlt first,Ranlt last);</code></pre><p>表示的是按升序排列，判断x是否应该比y靠前，就看<code>x&lt;y</code>是否为true。若定义为：  </p>
<pre><code>template&lt;class Ranlt,class Pred&gt;
void sort(Ranlt first,Ranlt last,Pred pr);</code></pre><p>则按升序排列，判断x是否应该比y靠前，就看pr(x,y)是否为true。前面讲容器的时候已经举例过<code>sort()</code>算法，这里就不再过多说明。 </p>
<h2 id="有序区间算法"><a href="#有序区间算法" class="headerlink" title="有序区间算法"></a>有序区间算法</h2><p>要求所操纵的区间是已经从小到大排好序的，需要随机访问迭代器的支持，因此有序区间算法不能用于关联容器和<code>list</code>。<br><code>binary_search</code> :判断区间中是否包含某个元素<br><code>includes</code> :判断是否一个区间中的每个元素，都在另一个区间中<br><code>lower_bound</code> :查找最后一个不小于某值的元素的位置<br><code>upper_bound</code> :查找第一个大于某值的元素的位置<br><code>equal_range</code> :同时获取<code>lower_bound</code>和<code>upper_bound</code><br><code>merge</code> :合并两个有序区间到第三个区间  </p>
<p>本篇大概介绍了STL中常见的一些算法以及它们所适用的容器，算法非常重要，STL中的算法都是已经编写好的函数模板，直接调用即可，但有时很多算法根据需求的不同需要我们自己去写，关于算法后续的学习会在数据结构与算法中再介绍。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>STL之迭代器</title>
    <url>/2020/02/11/STL%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>摘要：上两篇介绍了STL的容器相关的知识，本篇将会讲解迭代器。不同的容器用到不同的迭代器，因此需要了解各种容器的特征以及它们所适用的迭代器的用法。</p>
<a id="more"></a>
<p>迭代器用于指向顺序容器和关联容器中的元素，它的用法和指针类似。迭代器有<code>const</code>和非<code>const</code>两种，这两种都能读取它指向的元素，其中非<code>const</code>迭代器还可以修改其指向的元素，这也与指针相似。定义一个容器类的迭代器的方法是：<br><code>容器类名::iterator 变量名;</code> 或 <code>容器类名::const_iterator 变量名;</code><br>例如：<br><code>vector&lt;int&gt;::iterator i;</code>    </p>
<p><code>set&lt;double&gt;::const_iterator j;</code><br>而当访问一个迭代器所指向的元素时，与指针相同， <code>*迭代器变量名</code></p>
<h2 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h2><p>顺序容器中的<code>vector</code>、<code>deque</code>用的迭代器是随机访问迭代器，随机访问迭代器的意思即可以直接访问想要位置的元素。示例如下：  </p>
<pre><code>int main()
{
    vector&lt;int&gt; v;
    vector&lt;int&gt;::const_iterator i;                   //const迭代器 
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    i=v.begin()+2;
    cout&lt;&lt;*i&lt;&lt;endl;
    for(i=v.begin();i&lt;v.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }  
    vector&lt;int&gt;::iterator j;                     //非const迭代器  修改元素的值 
    for(j=v.begin();j&lt;v.end();j++)
    {
        *j=5;
    }
    for(i=v.begin();i&lt;v.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>从代码中可以看到，定义了一个空的动态数组v，输入数据变成1 2 3 4，还定义了一个指向动态数组的迭代器，因为<code>vector</code>用的是随机访问迭代器，可以直接访问想要位置的元素，所以当想要访问v中第3个元素时，令<code>i=v.begin()+2;cout&lt;&lt;*i&lt;&lt;endl;</code>即可。只有<strong>随机访问迭代器</strong>可以这样，其他的迭代器是不能用<code>+</code>运算符的。若想修改v中元素的值，定义了非const迭代器，使得v中元素全部变成5，再输出，运行结果如下：<br><img src="https://i.loli.net/2020/02/11/oLCZQ3MUJ4adjwh.png" alt=""><br>这里再介绍以下反向迭代器，从名字可知，迭代器的顺序进行了反向，即默认迭代器是从头到尾，而方向迭代器是从尾到头。对上面代码进行添加：  </p>
<pre><code>vector&lt;int&gt;::reverse_iterator r;                //反向迭代器 
for(r=v.rbegin();r!=v.rend();r++)
{
    cout&lt;&lt;*r&lt;&lt;&quot; &quot;;
}</code></pre><p>输出的结果就为4 3 2 1。</p>
<h2 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h2><p>上面已经说到顺序容器中的<code>vector</code>、<code>deque</code>使用的是随机访问迭代器，而顺序容器中还有一个链表<code>list</code>，它和关联容器都使用的是双向迭代器。双向迭代器便不能直接访问第i个元素，而只能从头到后逐个访问。将上篇中<code>set</code>容器的部分代码拿出来如下：</p>
<pre><code>int a[4]={3,2,1,5};
set&lt;int&gt; st(a,a+4);
set&lt;int&gt;::iterator i;   //双向迭代器
for(i=st.begin();i!=st.end();i++)
{
    cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
}</code></pre><p>虽然定义的形式是相同的，但是这里的迭代器是双向迭代器，在for循环的条件可以看到，是<code>i!=st.end()</code>，这里只能这么定义，而不能用<code>i&lt;st.end()</code>，随机访问迭代器两种形式都可以。</p>
<p>顺序容器和关联容器的迭代器都已经讲了，而容器适配器是不支持迭代器的。同样的，因为容器迭代器的限制，某些算法例如排序（sort）、二分查找（binary_search）需要通过随机访问迭代器来访问容器中的元素，那么<code>list</code>和关联容器就不支持该算法。前面讲<code>list</code>的时候讲过，它有自己定义的排序（sort）算法，就是来解决这个问题的。<br>本篇主要介绍了STL中的迭代器，在下篇将会介绍STL算法，算法是非常复杂的一部分，后面数据结构与算法的学习中还会对算法进行更深入的研究，在这里只简单介绍STL中的部分算法。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>STL之关联容器和容器适配器</title>
    <url>/2020/02/09/STL%E4%B9%8B%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<p>摘要：本篇继续上一篇的学习，将会对STL的容器中的关联容器和容器适配器进行介绍。容器具有非常强大的功能，熟练使用它们能给我们提供很大的方便。</p>
<a id="more"></a>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>上篇中已经介绍过顺序容器，即元素的插入位置同元素的值无关，而是由元素的添加到容器中的次序决定的。而关联容器却跟顺序容器不同，关联容器中，元素是排序的。插入任何元素，都按相应的<strong>排序规则</strong>来确定其位置。在查找时具有非常好的性能，通常以平衡二叉树方式实现，插入和检索的时间都是O（log（N））(折半查找)。关联容器包括<code>set</code>， <code>multiset</code>，<code>map</code>，<code>multimap</code>。<br>关联容器中除了各容器都有的函数外，还支持以下成员函数：<br><img src="https://i.loli.net/2020/02/09/SQMOUGPrt98XAcD.png" alt="">  </p>
<h2 id="set和multiset"><a href="#set和multiset" class="headerlink" title="set和multiset"></a>set和multiset</h2><p><code>set</code>和<code>multiset</code>的头文件都是<code>&lt;set&gt;</code>，表示的意思为集合。它们的区别在于<code>set</code>中不允许有相同元素，而<code>multiset</code>允许有相同元素。所以当在set中插入已有的元素时，忽略插入。示例代码如下：  </p>
<pre><code>int main()
{
    int a[4]={3,2,1,5};
    set&lt;int&gt; st(a,a+4);
    set&lt;int&gt;::iterator i;
    for(i=st.begin();i!=st.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    st.insert(4);
    st.insert(3);
    for(i=st.begin();i!=st.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    return 0;
 } </code></pre><p>定义了一个<code>set</code>对象st，一个数组为3 2 1 5，然后将数组输入到st中，然后将st中的元素输出。由下面的结果可以看到，<code>set</code>会自动对数据进行排序（默认为从小到大），变成了1 2 3 5。然后再插入4和3，将插入后的st输出，结果为1 2 3 4 5.可以看出对插入的数据4进行了排序，而3是已有的元素，忽略插入。<br><img src="https://i.loli.net/2020/02/09/6zetijN2WykparA.png" alt="">  </p>
<h2 id="map和multimap"><a href="#map和multimap" class="headerlink" title="map和multimap"></a>map和multimap</h2><p><code>map</code>和<code>multimap</code>的头文件都是<code>&lt;map&gt;</code>。<code>map</code>与<code>set</code>的不同在于<code>map</code>中只能存放对象，而且<code>map</code>中存放的元素有且仅有两个成员变量，一个为<code>first</code>，一个为<code>second</code>，<code>map</code>根据<code>first</code>的值对元素进行从小到大排序，并可快速的根据<code>first</code>来检索元素。<code>map</code>同<code>multimap</code>的不同在于是否允许相同<code>first</code>值的元素。示例代码如下：  </p>
<pre><code>template&lt;class Key,class Value&gt;
ostream &amp; operator&lt;&lt;(ostream &amp; o,const pair&lt;Key,Value&gt; &amp;p)
{
    o&lt;&lt;&quot;(&quot;&lt;&lt;p.first&lt;&lt;&quot;,&quot;&lt;&lt;p.second&lt;&lt;&quot;)&quot;;
    return o;
}
int main()
{
    typedef map&lt;int,double,less&lt;int&gt; &gt; mmid;
    mmid pairs;
    pairs.insert(make_pair(15,99.3));
    pairs.insert(mmid::value_type(20,20.5));
    mmid::iterator i;
    cout&lt;&lt;pairs.count(15)&lt;&lt;endl;
    cout&lt;&lt;pairs.count(10)&lt;&lt;endl;
    for(i=pairs.begin();i!=pairs.end();i++)
    {
        cout&lt;&lt; *i;
    }
    return 0;
}</code></pre><p>这里先介绍以下<code>pair</code>模板类，<code>pair</code>模板定义了两个公共成员变量，<code>first</code>和<code>second</code>，<code>map</code>和<code>multimap</code>容器里放着的都是<code>pair</code>模板类的对象。因此在输入数据的时候用<code>make_pair()</code>来输入，定义的<code>map</code>中第一个成员变量为<code>int</code>型，第二个为<code>double</code>型。输入了两组数据15 99.3和20 20.5，当查询15的数量时，看的是<code>first</code>的值，有一个。当查询10的数量时，没有。因为<code>map</code>中存放的是对象，而对象是不能直接输出的，所以重载了<code>&lt;&lt;</code>运算符，使得输出对象的<code>first</code>和<code>second</code>值。运行结果为：<br><img src="https://i.loli.net/2020/02/09/vCdkzUaDNOWuf1q.png" alt="">  </p>
<h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>容器适配器包括<code>stack</code>，<code>queue</code>，<code>priority_queue</code>3种。<code>stack</code>和<code>queue</code>基于<code>deque</code>实现，<code>priority_queue</code>基于<code>vector</code>实现。为什么叫容器适配器？举个例子，手机充电的时候需要电源适配器来把220v的交流电转换成较低电压的直流电以供手机充电使用，220v的电压太高了，我们不需要那么高的电压，而且高电压还有可能产生其他很多不良后果。基础的容器类型就相当于那220v的电压，经过适配器转换后才成为了我们需要的低电压（<code>stack</code>，<code>queue</code>，<code>priority_queue</code>）。你完全可以在<code>deque</code>上按照<code>stack</code>的方式工作，但是<code>deque</code>太强大了，它提供了远超过<code>stack</code>操作（<code>empty</code>, <code>size</code>,<code>pop</code>,<code>top</code>,<code>push</code>）所需的各种接口，你可以小心翼翼地在<code>deque</code>上只使用那几种操作来模拟一个栈，但是你很有可能一失误来个<code>push_front()</code>之类的操作，你小心翼翼模拟的栈就毁了。所以，我们需要适配器来做一下转换，只保留基础类型提供的接口中的一部分，保留的这部分操作对于你所需要的数据结构来说已经足够了。</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><code>stack</code>即栈，头文件为<code>&lt;stack&gt;</code>。栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的项）。栈是后进先出结构，Last in first out，简称LIFO。<br><img src="https://i.loli.net/2020/02/09/Xaqpeg9xKARtMTS.png" alt=""> </p>
<p>栈的成员函数有：<br>成员函数<code>push</code>：用于将一个新的整数插入到top<br>成员函数<code>pop</code>：用于移出top的整数<br>成员函数<code>empty</code>：用于判断是否为空<br>成员函数<code>top</code>：输出栈顶的整数<br>成员函数<code>size</code>：返回栈中元素的个数<br>示例代码如下：  </p>
<pre><code>int main()
{
    stack&lt;int&gt; s;
    cout&lt;&lt;s.empty()&lt;&lt;endl;
    s.push(3);s.push(2);s.push(5);s.push(1);s.push(4);
    cout&lt;&lt;s.empty()&lt;&lt;endl;
    cout&lt;&lt;s.size()&lt;&lt;endl;
    cout&lt;&lt;s.top()&lt;&lt;endl;
    s.pop();
    cout&lt;&lt;s.top();
    return 0;
}</code></pre><p>定义了一个空栈s，判断其是否为空，显然是空栈，所以会输出1。输入数据3 2 5 1 4，再判断栈是否为空，此时不为空，输出0，输出栈中元素的个数5，将栈顶的元素移去，次数栈中变为3 2 5 1，再输出栈顶的元素1。</p>
<h2 id="queue和priority-queue"><a href="#queue和priority-queue" class="headerlink" title="queue和priority_queue"></a>queue和priority_queue</h2><p><code>queue</code>和<code>priority_queue</code>表示的是队列和优先级队列，头文件都是<code>&lt;queue&gt;</code>。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。队列是先进先出的，First in first out，简称FIFO。优先级队列中最高优先级元素总是第一个出列，相当于对输入的数据进行了排序。<br><img src="https://i.loli.net/2020/02/09/gRUsCp3MmioBHvS.png" alt=""><br>示例代码如下：  </p>
<pre><code>int main()
{
    priority_queue&lt;double&gt; pq;
    pq.push(3.2);
    pq.push(9.8);
    pq.push(5.4);
    cout&lt;&lt;pq.top()&lt;&lt;endl;
    pq.pop();
    cout&lt;&lt;pq.top();
    return 0;
}</code></pre><p>定义了一个<code>double</code>型优先级队列pq，向队列输入数据3.2，9.8，5.4。因为是优先级队列，默认按从大到小的优先级排序。所以当输出队头时为9.8，这时候移去队头元素，再输出新的队头为5.4。结果如下：<br><img src="https://i.loli.net/2020/02/09/uLXciGyRxzp67Dq.png" alt="">  </p>
<p>至此就简单的介绍完了STL中容器的相关知识，在下一篇博客中将会开始进入到迭代器的学习，不同的容器有不同的迭代器，熟练掌握迭代器对于使用容器是非常重要的。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>标准模板库（STL)</title>
    <url>/2020/02/07/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89/</url>
    <content><![CDATA[<p>摘要：本篇将开始进入到标准模板库（STL）的学习。STL是非常实用的模板库，我将会从标准模板库的概念、组成、应用等方面对其进行介绍。由于STL中的知识很多，因此本篇将会只介绍其中的一部分。</p>
<a id="more"></a>
<p>前面已经学习过模板的知识。而标准模板库（STL）就是一些常用数据结构和算法的模板的集合。STL由容器、算法和迭代器三部分组成。其中<br>容器：可容纳各种数据类型的通用数据结构，是类模板；<br>迭代器：可用于依次存取容器中元素，类似于指针；<br>算法：用来操作容器中的元素的函数模板。<br><strong>算法本身与他们操作的数据的类型无关，因此他们可以从简单数组到高度复杂容器的任何数据结构上使用</strong>。  </p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器包括三部分，顺序容器、关联容器和容器适配器。</p>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><p>顺序容器包括<code>vector</code>、<code>deque</code>、<code>list</code>三种。为什么叫顺序容器，因为容器并非是排好序的，元素的插入位置同元素的值无关，而是由元素的添加到容器中的次序决定的。<br><code>vector</code>表示的是动态数组，元素在内存连续存放，随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。<br><img src="https://i.loli.net/2020/02/07/cdN9ojTvuqCgEaP.png" alt=""><br>它的特点是在<strong>尾部</strong>添加速度很快，在中间插入慢。所有STL算法都能对<code>vector</code>操作。在以前的学习中，当我们定义数组时，必须要给定它的内存大小。然而很多情况下，我们是不知道数组的大小的，而且数组大小也会变化。在动态数组<code>vector</code>中，它的大小会自动变化，不需要我们再去设定。<br>构造函数初始化的成员函数有：<br><img src="https://i.loli.net/2020/02/07/AzSLRPmyqF5Iphc.png" alt=""><br>其他常见的成员函数有：<br><img src="https://i.loli.net/2020/02/07/OcPkAtCRiJxqEj4.png" alt=""><br>下面以简单的代码为例说明动态数组的用法：  </p>
<pre><code>int main()
{
    vector&lt;int&gt; v;
    v.push_back(2);
    v.push_back(0);
    v.push_back(2);
    v.push_back(0);
    v.push_back(5);
    v.pop_back();
    cout&lt;&lt;v.size()&lt;&lt;endl;
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>可以看到，创建一个空的int型动态数组v，依次向里面输入2、0、2、0、5，然后删除末尾元素5，返回容器中元素的个数，再依次将各个元素输出。  </p>
<p><code>deque</code>表示的是双向队列，元素在内存连续存放。随机存取任何元素都能在常数时间完成（但次于<code>vector</code>）。在<strong>两端增删元素</strong>具有较佳的性能。（大部分情况下是常数时间，但在需要重新增加内存时时间会增加，vector同理）。<br><img src="https://i.loli.net/2020/02/07/Dnz3vmBUWFSHOCh.png" alt=""><br>所有适用于<code>vector</code>上的操作，都适用于<code>deque</code>。除此之外，<code>deque</code>还有<code>push_front()</code>(将元素插入到队列的头部）和<code>pop_front()</code>（删除头部的元素）操作。  </p>
<p><code>list</code>即熟悉的双向链表，元素在内存不连续存放。因为是链表，所以不支持随机存取。但是在任何位置增删元素都能在时间常数完成。前面两个的迭代器是随机访问迭代器，而<code>list</code>的是双向迭代器。<br><img src="https://i.loli.net/2020/02/07/LWIPCDex7bHdVKt.png" alt=""><br><code>list</code>的成员函数有：<br><img src="https://i.loli.net/2020/02/07/EWhcaYkCbe4nxHm.png" alt=""><br>可以看到它的成员函数与前面的<code>vector</code>、<code>deque</code>还是有些区别的。其中第三个<code>sort()</code>函数是<code>list</code>自己定义的排序函数。举例代码如下：  </p>
<pre><code>int main()
{
    list&lt;int&gt; l1,l2;
    l1.push_back(1);l1.push_back(5);l1.push_back(3);
    l1.push_front(2);l1.push_front(4);
    l2.push_back(10);l2.push_back(20);l2.push_back(30);
    list&lt;int&gt;::iterator i;
    for(i=l1.begin();i!=l1.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    l1.sort();
    for(i=l1.begin();i!=l1.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    l1.merge(l2);
    l1.reverse();
    for(i=l1.begin();i!=l1.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>其中有关迭代器的知识会在接下来介绍，在这里只需将其当成指针即可。可见定义了两个链表l1和l2，<br>输入数据使l1变为1 5 3 2 4，l2变为10 20 30。将l1输出，然后调用<code>sort()</code>函数对l1进行排序并输出。将两个链表合并，再将其翻转输出。最后运行结果为：<br><img src="https://i.loli.net/2020/02/07/E28fB5buUdjcHGO.png" alt="">  </p>
<p>在本篇中讲解了标准模板库的概念以及容器中的顺序容器这一部分，在下篇中将会继续进入关联容器和容器适配器的学习。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>模板类之string类</title>
    <url>/2020/02/05/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B9%8Bstring%E7%B1%BB/</url>
    <content><![CDATA[<p>摘要：在数据结构里有一个部分为串（或字符串），它是非常常用的一个数据类型。C++中，string类对应的就是实现字符串相关的各种功能。通过对string类的学习，使得解决字符串有关问题时更加方便快捷。</p>
<a id="more"></a>
<p>上篇中已经学习过类模板有关的知识，在本篇将就string类举例进行介绍。<code>&lt;string&gt;</code>是C++标准程序库中的一个头文件，定义了C++标准中的字符串的基本模板类<code>std::basic_string</code>及相关的模板类实例。string是以char作为模板参数的模板类实例，把字符串的内存管理责任由string负责而不是由编程者负责，大大减轻了C语言风格的字符串的麻烦。<code>std::basic_string</code>提供了大量的字符串操作函数，如比较、连接、搜索、替换、获得子串等。并可与C语言风格字符串双向转换。<code>std::basic_string</code>属于C++ STL容器类，用户自定义的类也可以作为它的模板参数，因此也适用C++ STL Algorithm库。<br>string类的成员函数如下：<br><img src="https://i.loli.net/2020/02/05/nDozMjdgFTuX4Vy.png" alt=""><br>这里只介绍一些常用的成员函数。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>按照以前所学的对类的对象赋值，string类的格式如下：  </p>
<pre><code>string s1(&quot;hello&quot;);</code></pre><p>即令字符串s1的内容为hello，但在string类里还有其他的赋值方式，比如：  </p>
<pre><code>string s1=&quot;hello&quot;;
string s2(8,&apos;x&apos;);</code></pre><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>如果要访问字符串中的字符，需要用到的成员函数为<code>at()</code>，例如逐个访问并输出string对象中的字符代码为：  </p>
<pre><code>for(int i=0;i&lt;s1.length();i++)
{
    cout&lt;&lt;s1.at(i)&lt;&lt;&quot; &quot;;
}</code></pre><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>用<code>+</code>运算符或者<code>append()</code>函数可以实现字符串之间的拼接。例如若将字符串s1和字符串s2拼在一起：  </p>
<pre><code>string s1,s2;
s1=&quot;hello&quot;;
s2=&quot; world&quot;;
s1=s1+s2; //用+运算符实现
s1.append(s2);  //用append函数</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>若要删除字符串中的某些字符，需要用到<code>erase()</code>函数，函数输入的参数为下标，表示去掉该下标及以后的字符。例如我们要使hello world字符串只剩下hello，则：  </p>
<pre><code>string s1=&quot;hello world&quot;;
s1.erase(5);</code></pre><p>需要说明的是该函数只能实现删除字符串后面一部分的功能。</p>
<h2 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h2><p>由上面所述，假如要求得到的不是hello而是world，这样不能用删除函数，应该怎么办？有一个成员函数名字为<code>substr()</code>，它的作用是得到字符串中的一部分，即子串。需要输入两个参数，第一个参数表示下标，第二个参数表示从该下标开始，你想要往后得到的字符个数。</p>
<pre><code>string s1=&quot;hello world&quot;;
s1.substr(6,5);</code></pre><p>这样就能得到子串world。</p>
<h2 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h2><p>若需要在字符串中找到需要的字符的位置，应该怎么办？这个问题是很常见的，需要用到的成员函数为<code>find()</code>，输入参数为想要查询的字符或字符串，返回结果为该字符或字符串在给定的字符串中第一次出现的位置。它是从前往后找的，第一次找到即返回。若要求从后往前找，则成员函数为<code>rfind()</code>。例如若要查到ll在hello world中第一次出现的位置：  </p>
<pre><code>string s1=&quot;hello world&quot;;
s1.find(&quot;ll&quot;);</code></pre><p>除此之外，<code>find_first_of(&quot;abc&quot;)</code>函数表示的是查找abc中任意一个字符第一次出现的位置。<code>find_first_not_of(&quot;abc&quot;)</code>表示的是查找不是abc这3个字符的其他字符第一次出现的位置。</p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>假如字符串中某些地方需要替换，这时候就需要用到成员函数<code>replace()</code>，例如将字符串heloo world变成hello world。</p>
<pre><code>string s1=&quot;heloo world&quot;;
s1.replace(3,1,&quot;l&quot;);</code></pre><p>表示的意思为将字符串s1中下标3开始后的一个字符替换为字符l。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>若要在字符串中插入字符则需要用到成员函数<code>insert()</code>，输入参数为插入位置的下标和要插入的字符。就用上面连接里面的例子：</p>
<pre><code>string s1,s2;
s1=&quot;hello&quot;;
s2=&quot; world&quot;;
s1.insert(5,s2);</code></pre><p>这样将s2插入到s1后面，实现了连接，当然也可以插入到中间和前面，由我们自己定义。</p>
<p>最后将上面所将的成员函数进行一下汇总，放在代码中为： </p>
<pre><code>#include&lt;string&gt;
using namespace std;
int main()
{
    string s1,s2;
    s1=&quot;Hell0 world&quot;;
    for(int i=0;i&lt;s1.length();i++)
    {
        cout&lt;&lt;s1.at(i)&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    cout&lt;&lt;s1.find(&quot;ll&quot;)&lt;&lt;endl;
    s2=s1.substr(6,5);
    cout&lt;&lt;s2&lt;&lt;endl;
    cout&lt;&lt;s1.append(s2)&lt;&lt;endl;
    cout&lt;&lt;s1.erase(11,5)&lt;&lt;endl;
    cout&lt;&lt;s1.replace(6,5,&quot;ZPL&quot;)&lt;&lt;endl;
    cout&lt;&lt;s1.insert(9,&quot;HHH&quot;)&lt;&lt;endl;
    return 0; 
 } </code></pre><p>运行结果为：<br><img src="https://i.loli.net/2020/02/05/1jSoqHuXc2fEpNO.png" alt=""><br>string类是非常实用的一个模板类，掌握并能运用它的常用的成员函数是很有必要的。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>函数模板、类模板和模板类</title>
    <url>/2020/02/03/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB/</url>
    <content><![CDATA[<p>摘要：本篇将进入有关泛型编程相关知识的介绍，泛型程序设计可以减少很多重复的代码，而模板又是泛型编程的基础。通过函数模板、类模板和模板类的学习能够更好的了解泛型程序的概念，也为后面将要学习的标准模板库（STL）打下基础。</p>
<a id="more"></a>
<p>假如编写一个程序实现两个整数的交换，这是很简单的，定义一个中间变量，然后交换两个整数即可。现在要求对程序进行修改，使得既能实现整数的交换，又能实现小数的交换，那应该怎么办？是不是必须要对上面的交换函数进行重载，使得输入参数为小数也可以，若要求再实现字符的交换呢？能不能一个函数实现上面的所有要求，而不能根据每一个要求写一个函数？这就是泛型编程所要实现的，<strong>编写一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同</strong>。泛型即是指具有在多种数据类型上皆可操作的含义。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>模板是创建泛型类或函数的蓝图或公式。模板有类模板和函数模板。针对上面问题，可以用函数模板来解决。</p>
<pre><code>template&lt;class 类型参数1，class 类型参数2  ...&gt;
返回值类型 模板名（形参表）
{
    函数体
}</code></pre><p>其中类型参数是自定义的，比如实现上述要求的交换，只有一个类型参数，用T表示即可。具体实现代码如下：  </p>
<pre><code>template&lt;class T&gt;
void Swap(T&amp;x,T&amp;y)
{
    T tem;
    tem=x;
    x=y;
    y=tem;
 } 
 int main()
 {
     int a=2,b=3;
     Swap(a,b);
     cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;
     double c=2.1,d=3.1;
     Swap(c,d);
     cout&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;
    string s1,s2;
     s1=&quot;hello&quot;;
     s2=&quot;world&quot;;
     Swap(s1,s2);
     cout&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;endl;
     return 0;
 }</code></pre><p>可以看到上面利用一个函数模板就实现了多种数据结构的交换。这大大减少了重复代码的编写，提高程序效率。若有两个类型参数，只需要多定义一个即可，如下：  </p>
<pre><code>using namespace std;
print(int a,int b)
{
    cout&lt;&lt;&quot;普通函数优先级最高&quot;&lt;&lt;endl; 
}
template&lt;class T&gt;
void print(T a,T b)
{
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;    
}
template&lt;class T1,class T2&gt;
void print(T1 a,T2 b)
{
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;    
}
int main()
{
    int x=1,y=2;
    double z1=3.1,z2=5.2;
    string s=&quot;hello&quot;;
    print(x,y);
    print(z1,z2);
    print(x,z1);
    print(s,x);
    return 0;
}</code></pre><p>由上面的代码可以看出，<strong>函数模板可以重载，只要他们的形参表不同即可</strong>。代码中重载了<code>print</code>函数，使它能实现同类型数据的打印和不同数据类型的打印。那么函数调用的顺序是什么样的呢？运行结果如下：<br><img src="https://i.loli.net/2020/02/03/aECSeydDQn3NPU9.png" alt=""><br>从结果也能看出，函数的调用顺序为：<br>1.普通函数<br>2.参数完全匹配的模板函数<br>3.实参经过类型转换后能够匹配的普通函数<br>若经过上面3个顺序还找不到则报错。  </p>
<h2 id="类模板和模板类"><a href="#类模板和模板类" class="headerlink" title="类模板和模板类"></a>类模板和模板类</h2><p>正如定义函数模板一样，也可以定义类模板。在定义类的时候给它一个或多个参数，这些参数表示不同的数据类型，在调用类模板时指定参数，由编译系统根据参数提供的数据类型自动产生相应的模板类。编译器由类模板生成类的过程叫做类模板的实例化。由实例化得到的类叫模板类。函数模板可以作为类模板成员。  </p>
<pre><code>template&lt;class T&gt;
class A
{
      public:
        T a,b;
      void change();
      template&lt;class T1&gt;
      void func(T1 t)
      {
          cout&lt;&lt;t&lt;&lt;endl;
       } 
};    
template&lt;class T&gt;
void A&lt;T&gt;::change()
{
    T &amp;x=a;
    T &amp;y=b;
    T tem;
    tem=x;
    x=y;
    y=tem;
}
int main()
{
    A&lt;double&gt;a;
    a.func(&apos;Z&apos;);
    a.a=3.2;
    a.b=5.1;
    a.change();
    cout&lt;&lt;a.a&lt;&lt;&quot; &quot;&lt;&lt;a.b&lt;&lt;endl;
    return 0;
}</code></pre><p>上面代码中定义了一个类模板A，它的成员中有一个函数模板，用来交换两个数，当在类模板外定义函数时，需要加上<code>template</code>。<strong>类模板使得类的实现不关注数据元素的具体类型，而只关注类所需要实现的功能</strong>。在主函数里，实例化了一个类模板的double对象，模板类a，然后定义它的成员变量。当需要进行整型的功能时，只需要改变类模板A的参数即可。<br>本篇讲的函数模板和类模板都是C++很重要的一部分，在下篇中将会讲解一下string类。string类就是一个模板类，它具有很广泛的应用。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>文件和流</title>
    <url>/2020/01/31/%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/</url>
    <content><![CDATA[<p>摘要：今天将介绍如何从文件读取流和写入流。需要用到的类有iostream和fstream，通过对文件流的学习能更清楚的理解C++是如何读取信息和写入信息的。</p>
<a id="more"></a>
<p>根据前面的学习，在编写代码的时候头文件里都包含了iostream标准库，它提供了cin和cout方法分别用于从标准输入读取流和向标准输出写入流。在C++标准库中，ifstream、ofstream和fstream三个类用于文件操作，统称为文件流类。它们之间的关系如下：<br><img src="https://i.loli.net/2020/01/31/8cfetyEaNqAUnF1.png" alt=""><br>ifstream、ofstream和iostream类由istream和ostream类派生而来，iostream类又派生出fstream类。这三个类的作用如下：<br><img src="https://i.loli.net/2020/01/31/JziZ4H9XpfOasVn.png" alt=""><br>要在C++中进行文件处理，必须在C++源代码文件中包含头文件iostream类和fstream类。  </p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream和fstream对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用ifstream对象。<br>下面是<code>open()</code>函数的标准语法，<code>open()</code>函数是fstream、ifstream和ofstream对象的一个成员。</p>
<pre><code>void open(const char *filename, ios::openmode mode);</code></pre><p><code>open()</code>成员函数的第一个参数为要打开的文件的名称和位置，第二个参数定义文件被打开的模式。例如定义一个用二进制写入的操作。代码为：  </p>
<pre><code>ofstream b;
b.open(&quot;test.out&quot;,ios::out|ios::binary);</code></pre><p>若是定义为读写：</p>
<pre><code>b.open(&quot;test.out&quot;,ios::out|ios::in);  </code></pre><p>同时需要判断是否打开文件成功：  </p>
<pre><code>if(!b){cerr&lt;&lt;”File open error!”&lt;&lt;endl;}</code></pre><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。下面是<code>close()</code>函数的标准语法，<code>close()</code>函数是fstream、ifstream和ofstream对象的一个成员。</p>
<pre><code>void close();</code></pre><h2 id="写入和读取"><a href="#写入和读取" class="headerlink" title="写入和读取"></a>写入和读取</h2><p>在写入和读取时我介绍一个函数，<code>freopen()</code>函数。这个函数是用于C++重定向标准输入输出。什么是重定向？所谓重定向输出，就是可以把原本只是输出在控制台的字符，输出到你指定的路径文件中。(输入类似，就是从指定的文件中读取，而不是读取在控制台中的输入。)重定向函数可以在任何时候开启、关闭。这样我们利用<code>freopen()</code>函数就可以实现对文件的写入和读取。用法如下：  </p>
<pre><code>freopen(&quot;文件名.in&quot;,&quot;r&quot;,stdin);
freopen(&quot;文件名.out&quot;,&quot;w&quot;,stdout);</code></pre><p>r表示读，w表示写。stdin是标准输入流，默认为键盘，<strong>重定向以后变成从文本读取数据</strong>；stdout是标准输出流，默认为屏幕，<strong>重定向以后变为向文本写入数据</strong>。举例如下：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;fstream&gt;
using namespace std;
int main()
{
    int x=5,y=6,a,b;
    freopen(&quot;ceshi.txt&quot;,&quot;r&quot;,stdin);    
    cin&gt;&gt;a&gt;&gt;b;
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b;
    freopen(&quot;ceshi.txt&quot;,&quot;w&quot;,stdout);
    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y;
    fclose(stdin);
    fclose(stdout);
    return 0; 
}</code></pre><p>建立一个名字为ceshi的txt文本，在里面预设两个数为1 2。当重定向以后从本文读取a、b然后输出,此时输出没有重定向因此显示在屏幕上为1 2，实现了从文件中读取的操作。再对输出重定向将x、y写入文本中，关闭文本。因此最终文本中的内容变为5 6。</p>
<p>本篇主要讲解了文件有关的操作和函数，在下篇博客中，将会进入C++的又一重要方面学习：泛型程序设计。将会了解到有关函数模板和类模板等等有关的内容，它们对于程序设计是非常有用的。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>虚析构函数、纯虚函数和抽象类</title>
    <url>/2020/01/28/%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p>摘要：本篇将会对上篇所讲得虚函数再做介绍，主要讲解了虚析构函数和纯虚函数的概念以及为什么要使用它们，通过虚析构函数的学习也能更好的理解内存泄漏的知识。而纯虚函数则能让我们更好的理解多态和使用多态。</p>
<a id="more"></a>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>根据上篇博客中的知识可以明白虚析构函数就是将析构函数定义为虚函数，即在析构函数前面加上<code>virtual</code>关键字，那么为什么要将析构函数定义为虚析构函数呢？首先以下面代码为例：  </p>
<pre><code>class base                                //定义基类 
{
    public:
        int a;
        base(int i);
         ~base();
};
base::base(int i=0)
{
    a=i;
    cout&lt;&lt;&quot;基类构造函数&quot;&lt;&lt;endl;
}
base::~base()
{
    cout&lt;&lt;&quot;基类析构函数&quot;&lt;&lt;endl;
}
class derive:public base                    //定义派生类 
{
    public:
      int b;
      derive(int i=0,int j=0);
       ~derive();
};
derive::derive(int i,int j):base(i)
{
    b=j;
    cout&lt;&lt;&quot;派生类构造函数&quot;&lt;&lt;endl;
}
derive::~derive()
{
    cout&lt;&lt;&quot;派生类析构函数&quot;&lt;&lt;endl;
}
int main()
{ 
    base *p2;      
    p2=new derive;                 //基类指针 
    delete p2;                      //释放 
    return 0;
}</code></pre><p>猜一下上面代码运行的结果是什么？定义了一个基类指针，指向派生类对象，然后再用基类的指针删除派生类的对象。运行结果如下：<br><img src="https://i.loli.net/2020/01/28/pbCiPWYJXxGKTFe.png" alt=""><br>可以看到在删除派生类对象时，没有调用派生类的析构函数，只调用了基类的析构函数，这说明内存并没有完全释放。这是因为定义的是基类指针，当删除时只调用了基类里的析构函数。那该怎么解决这个问题？这就需要虚析构函数了。当我们修改上述代码，将基类和派生类的析构函数定义为虚析构函数时结果为：<br><img src="https://i.loli.net/2020/01/28/7uOWnfCpGPVQwvU.png" alt=""><br>这样就成功了对内存资源完全释放了。虚析构函数主要是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象这一情形的。<br>如果某个类不包含虚函数，那一般是表示它将不作为一个基类来使用。当一个类不准备作为基类使用时，使析构函数为虚一般是个坏主意。因为它会为类增加一个虚函数表，使得对象的体积翻倍，还有可能降低其可移植性。但是虚函数又是很重要的，因此我们常常定义为：当且仅当类里包含至少一个虚函数的时候去声明虚析构函数。</p>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>假如一个虚函数是没有函数体的，那么就叫它纯虚函数。纯虚函数是一种特殊的虚函数，为什么要定义纯虚函数呢？<br>举个例子，我们知道动物类可以作为一个基类派生出老虎类、狮子类等，但是动物类本身是不生成对象的。在很多情况下，基类本身生成对象是不合理的，但是我们又要使用多态这一特性，需要在基类里定义虚函数，而这些虚函数在基类中是没有意义的，它们的实现主要在派生类中进行。因此为了解决这种情况，我们在基类中把虚函数定义为纯虚函数。纯虚函数的定义格式为：<br><code>virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;</code><br>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。抽象类里的成员函数可以调用纯虚函数。以下面代码为例：  </p>
<pre><code>class base                                  //抽象类 
{
    public:
        int a;
        virtual void change()=0;            //纯虚函数 
        void print()
        {
            this-&gt;change();
        }
};
class derive:public base                 //派生类 
{
    public:
        int b;
        virtual void change();        
};
void derive::change()
{
    cout&lt;&lt;&quot;b=2&quot;;
}
int main()
{
    derive d;
    d.print();                  
    return 0;
}</code></pre><p>在代码中定义了一个基类，它有一个纯虚函数的成员函数，因此它是抽象类。抽象类派生出一个类，在派生类里对纯虚函数进行具体实现。同时抽象类还有一个成员函数<code>print()</code>，它的作用是调用对象的虚函数<code>change()</code>，这也是因为抽象类的成员函数可以调用纯虚函数。在主函数里我们创建了一个派生类对象，当它调用<code>print()</code>函数时，因为this指针指向的对象为派生类，因此调用的是派生类的虚函数<code>change()</code>，即输出结果为<code>b=2</code>。  </p>
<p>虚析构函数的作用是解决基类指针指向派生类对象删除时不完全的情况，纯虚函数和抽象类则更好的完善了基类和多态，这些特殊的虚函数都有着很大的作用，它们也使得程序变的更加准确可靠。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>虚函数和多态</title>
    <url>/2020/01/26/%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>摘要：多态，是面向对象的程序设计语言最核心的特征。多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法。多态是通过虚函数实现的，本篇博客将主要介绍虚函数和多态的概念、定义以及如何使用。</p>
<a id="more"></a>
<p>多态是继封装、继承之后，面向对象的第三大特性。现实事物经常会体现出多种形态，例如一个人叫张三，他是学生，但他也是人，因此他有两种形态学生（student）和人（person）。而学生类又可以是人类继承而来的。这种情形就叫做多态。  </p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>什么是虚函数？在类的定义中，前面有<code>virtual</code>关键字的成员函数就是虚函数。例如：  </p>
<pre><code>virtual int get();</code></pre><p><code>virtual</code>需要在声明时表现出来，但当对函数进行定义时可以省略。<strong>构造函数和静态成员函数不能是虚函数</strong>。这是因为若将构造函数定义为虚函数，在调用构造函数时直接可以确定它的类，而静态成员函数本质上是全局函数，只定义一次。虚函数能参与多态，普通函数不能。</p>
<h2 id="多态的表现形式之一"><a href="#多态的表现形式之一" class="headerlink" title="多态的表现形式之一"></a>多态的表现形式之一</h2><p>我们想要实现的是根据实际的对象类型决定函数调用的具体目标。派生类的指针可以赋给基类指针，当我们通过基类指针调用基类和派生类中的同名虚函数时：<br>1.若该指针指向一个基类的对象，那么被调用的是基类的虚函数。<br>2.若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。<br><strong>即调用哪个虚函数取决于指针指向哪种类型的对象。</strong></p>
<pre><code>derive d;
base *p=&amp;d;
p-&gt;somevirtualfunction();</code></pre><p>可以看到基类指针p指向派生类对象d，因此它调用的虚函数为派生类中的虚函数。</p>
<h2 id="多态的表现形式之二"><a href="#多态的表现形式之二" class="headerlink" title="多态的表现形式之二"></a>多态的表现形式之二</h2><p>前面已经讲过引用的概念。派生类对象同样可以赋给基类引用。通过基类引用调用同名虚函数时取决于引用的对象类型，这种也叫做多态。</p>
<pre><code>derive d;
base &amp;r=d;
r.somevirtualfunction();</code></pre><p>可以看到基类引用引用的对象类型为派生类的对象d，因此它调用的虚函数为派生类中的虚函数。<br>在基类的非构造、非析构函数的成员函数中调用虚函数，就是多态。相当于调用的时候省略了this指针，this是基类指针，指向的对象为主函数里定义的指针指向的对象。若是指向派生类对象，就跳转到派生类的虚函数里执行。</p>
<h2 id="多态实现原理"><a href="#多态实现原理" class="headerlink" title="多态实现原理"></a>多态实现原理</h2><p>前面说到多态时通过虚函数实现的，为什么虚函数能够实现多态呢？这是因为每一个有虚函数的类（或者它的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。若查看带有虚函数的类的内存大小，发现多出来4个字节，多出来的4个字节就是用来放虚函数表的地址的。有地址就可以调用虚函数。<br>我们对上篇博客中的代码做下扩充来讲述多态的具体实现：</p>
<pre><code>class base
{
    protected:
    int a;
    public:
    base(int i=0)
    {
        a=i;
        cout&lt;&lt;&quot;基类构造&quot;&lt;&lt;endl;
    } 
    ~base()
    {
        cout&lt;&lt;&quot;基类析构&quot;&lt;&lt;endl;
    }
    virtual int change();
};
int base::change()
{
    a=a+1;
    return a;
}
class derive:public base
{
    public:
        int b;
        derive(int i,int j);
        ~derive()
        {
           cout&lt;&lt;&quot;派生类析构&quot;&lt;&lt;endl;    
        }
        virtual int change();
};
derive::derive(int i,int j):base(i)
{
    b=j;
    cout&lt;&lt;&quot;派生类构造&quot;&lt;&lt;endl;
}
int derive::change()
{
    b=b+a;
    return b;
}
int main()
{
    base b(3);
    derive d(2,5);
    base *p=&amp;d;                     //基类指针指向派生类对象 
    base &amp;r=b;                                        //基类引用引用基类对象 
    cout&lt;&lt;b.change()&lt;&lt;endl;
    cout&lt;&lt;d.change()&lt;&lt;endl;
    cout&lt;&lt;p-&gt;change()&lt;&lt;endl;        //调用派生类的虚函数 
    cout&lt;&lt;r.change()&lt;&lt;endl;                          //调用基类的虚函数 
    return 0;
}</code></pre><p>可以看到，基类中虚函数的作用是加1，派生类中虚函数的作用是使两个数相加。在主函数里，定义了一个基类指针p指向派生类对象d，定义了一个基类引用引用基类对象b，这样指针p调用的是派生类的虚函数，引用调用的是基类的对象b，运行结果为:<br><img src="https://i.loli.net/2020/01/26/smyXV46wLrdTuce.png" alt="">  </p>
<h2 id="多态和重载"><a href="#多态和重载" class="headerlink" title="多态和重载"></a>多态和重载</h2><p>多态的概念很容易想到相似的重载。前面讲过函数重载的概念，重载也可以使得函数有不同的功能，但是多态和重载还是有很大区别的。<br>多态中用的是同名虚函数，函数名和函数参数都完全相同，通过指针指向或引用的对象类型判断需要执行的虚函数。而重载只是函数名相同，参数却不同，通过输入的参数个数或形式来判断调用的函数。重载中，编译器根据函数不同的参数表，对同名函数的名称做修饰。对于编译器而言，这些同名函数就成了不同的函数。它们的调用地址在编译期就绑定了。多态中，虚函数调用在编译期间是无法确定的。<br>不难看出，两者的区别在于编译器何时去寻找所要调用的具体函数，对于重载而言，在函数调用之前，编译器就已经确定了所要调用的函数，这称为“静态绑定”；而对于多态，只有等到函数调用的那一刻，编译器才会确定所要调用的具体函数，这称为“动态绑定”。  </p>
<p>上面就简单介绍了多态的概念，在下一篇博客中，将会对虚函数再进一步学习，学习虚函数中的虚析构函数、纯虚函数以及抽象类的概念。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>继承和派生</title>
    <url>/2020/01/24/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/</url>
    <content><![CDATA[<p>摘要：在前面已经讲了类的有关概念，而不同的类之间是有关系的。相关的关系有继承和复合关系等。在本篇中将会介绍以下继承和派生的相关概念。这也是面向对象中很重要的一个概念，通过继承和派生可以提高代码执行效率。</p>
<a id="more"></a>

<p>类并不是孤立的存在的，不同的类之间有着不同的关系，正如前面所讲过的友元类。假如已经定义了一个动物类，里面有动物的成员变量和成员函数，此时若要再定义一个哺乳动物类该怎么办？可以看出，哺乳动物属于动物，它也具有动物类的所有特性。因此只需要继承动物类即可。<br>继承：在定义一个新的类B时，如果该类与某个已有的类A相似（B拥有A的全部特点），那么就可以把A作为一个基类，而把B作为基类的一个派生类。派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。派生类一经定义后，可以独立使用，不依赖于基类。继承代表了 is a 关系。<strong>派生类成员函数不能访问基类的私有成员</strong>。<br>根据上面的概念可知，派生类是由基类派生而来，因此基类的成员变量和成员函数在派生类也有。一般情况下，在派生类里的指的是派生类定义的成员，若要访问基类的（公共的）同名成员变量和成员函数，需要加上基类名，即<code>base::I</code>、<code>base::func()</code>。<br>派生类的定义格式为：<br><code>class 派生类名：public 基类名</code><br>这里的<code>public</code>也可以换为<code>protected</code>和<code>private</code>，它们表示了继承类型，但我们通常使用的都是<code>public</code>继承。一个基类可以派生出多个派生类。<br>前面讲过公有成员和私有成员，这里讲一下保护成员（protected）。它与私有成员不同的地方在于它可以被派生类的成员函数访问。其他访问方式与私有成员相同。  </p>
<h2 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h2><p>派生类的其他成员函数如前面所讲的定义即可，但构造函数略有不同，因为派生类是继承基类而来，所以在派生类的构造函数中要先去调用基类的构造函数。如果不调用基类构造函数，因为派生类成员函数不能调用基类私有成员，无法实现初始化。派生类的构造函数定义为：<br><code>派生类名（成员变量1，2，3...）：基类构造函数（成员变量1，2...）</code><br>成员变量1，2，3为形参名，以下面代码为例：</p>
<pre><code>class base
{
    private:
        int n;
    public:
        base(int i=0):n(i)
        {
            cout&lt;&lt;&quot;基类构造&quot;&lt;&lt;endl&lt;&lt;n&lt;&lt;endl;
        }
        ~base()
        {
            cout&lt;&lt;&quot;基类析构&quot;&lt;&lt;endl;
        }
        void print();
};
void base::print()
{
    cout&lt;&lt;n&lt;&lt;endl;
}
class derive:public base
{
    public:
        int a;
        derive(int i=0,int j=0);
        ~derive()
        {
            cout&lt;&lt;&quot;继承类析构&quot;&lt;&lt;endl;
        }
};
derive::derive(int i,int j):base(i)
{
    a=j;
    cout&lt;&lt;&quot;继承类构造&quot;&lt;&lt;endl&lt;&lt;a&lt;&lt;endl;
}
int main()
{
  derive b(2,1);
  b.print();
  return 0;
}</code></pre><p>可以看到，在代码的构造函数和析构函数中，都输出是属于哪个类的。在派生类的构造函数中，定义了两个形参i和j，第一形参i是基类构造函数中的参数，派生类新增加的成员变量a用形参j赋值，这样就实现了派生类的构造函数。而派生类也有基类的成员函数，因此派生类对象b可以调用<code>print()</code>函数输出。运行结果为:<br><img src="https://i.loli.net/2020/01/24/ABGCPKpOb9ZjNed.png" alt=""><br>在结果中我们也可以看到构造函数和析构函数的调用顺序，<strong>先构造的后析构，先基类构造再派生类构造</strong>。<br>假如我们定义基类对象为b，派生类对象为d：  </p>
<pre><code>base b;
derive d;</code></pre><p>1.派生类对象可以赋值给基类对象，即<code>b=d</code>。而反过来不行，这也是反映了前面所说的 is a 关系。<br>2.派生类对象可以初始化基类引用，即<code>base &amp;br=d</code>。<br>3.派生类对象的地址可以赋值给基类指针，即<code>base *pd=d</code>。  </p>
<h2 id="直接基类和间接基类"><a href="#直接基类和间接基类" class="headerlink" title="直接基类和间接基类"></a>直接基类和间接基类</h2><p>上面所讲一个类可以派生出多个类。而派生类也可以作为基类再派生。如动物类可以派生出哺乳动物类，而哺乳动物类又可以派生出人类。这样，动物类和哺乳动物类都是人类的基类。哺乳动物类是直接基类，动物类是间接基类。声明派生类时，只需列出它的直接基类。但是派生类的成员包括自己定义、直接基类、间接基类的所有成员。<br>上面介绍了继承和派生的概念，类与类之间可能是继承关系，但如果一个类的对象是另一个类的成员呢？这属于什么关系？以圆类为例，圆有两个重要的成员，圆心和半径。而圆心是一个点，它属于点类的一个对象。此时定义圆类和点类为复合关系，<strong>复合关系一般把大的类声明为另一个类的友元</strong>。<br>面向对象的三个特征：封装、继承、多态。在下篇中将会进入到多态的学习，多态使得C++变的非常灵活，大大提高效率，是非常重要的一部分。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/2020/01/21/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>摘要：上一篇博客当中已经讲了什么是运算符重载，并且介绍了加减乘除等运算符如何重载及它们的用法。在本篇博客当中将会继续就运算符重载进行深入介绍，主要有赋值运算符的重载、流插入和流提取运算符、自加自减运算符以及函数调用<code>（）</code>运算符的重载。</p>
<a id="more"></a>

<p>在众多的运算符当中，不是所有的都可以被重载，只有一部分可以，下面是可以被重载的运算符列表：<br><img src="https://i.loli.net/2020/01/21/kVxI5OW4FAGDiY3.png" alt=""><br>可以看到，上篇博客中讲的是双目算术运算符的重载，本篇将会讲解其他类型的运算符重载，比如赋值运算符等。不同的运算符重载具有不同的功能。</p>
<h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>在赋值运算符重载中，我将会讲解<code>=</code>这个运算符，从名字就可以看出来，重载的功能主要是赋值，但特殊的地方在于它两边的类型可以不匹配。例如将一个<code>int</code>类型变量赋值给一个<code>complex</code>对象，将一个<code>char*</code>类型的字符串赋值给一个字符串对象或者将一个对象赋值给另一个对象等。需要注意的一点是，赋值运算符<code>=</code>只能重载为成员函数。继续以上篇博客中的代码为例，添加赋值运算符<code>=</code>的重载代码如下：</p>
<pre><code>complex&amp; complex::operator=(const complex &amp;s3)
 {
     real=s3.real;
     image=s3.image;
     return *this;
 }</code></pre><p>主函数：</p>
<pre><code>int main()
{
    complex s1(2,3);
    complex s2(3,4);
    complex s3,s4;
    s3=s1+s2;
    s3.showcomplex();
    s4=s3-s2;
    s4.showcomplex();
    s4=s2;
    s4.showcomplex();
    return 0;
} </code></pre><p>运行结果为：<br><img src="https://i.loli.net/2020/01/21/qrTbeNRiX8tMdlx.png" alt=""><br>可见将对象s2成功赋值给了s4。若是想要将数据赋给对象只需要修改参数即可。</p>
<h2 id="流插入和流提取运算符重载"><a href="#流插入和流提取运算符重载" class="headerlink" title="流插入和流提取运算符重载"></a>流插入和流提取运算符重载</h2><p>在介绍这部分知识之前，先提出一个问题，为什么<code>cout&lt;&lt;5</code>、<code>cin&gt;&gt;a</code>能够成立，能够在编译器里运行？按照C语言当中学习的知识，我们想要输出一个东西时，会用<code>printf</code>关键字，要输入一个东西时，会用<code>scanf</code>关键字。在C++中为什么用<code>cout&lt;&lt;</code>、<code>cin&gt;&gt;</code>可以实现上述功能呢？<br><code>cout</code>是在<code>iostream</code>中定义的，<code>ostream</code>类的对象。<code>&lt;&lt;</code>能用在<code>cout</code>上是因为在<code>iostream</code>里对<code>&lt;&lt;</code>进行了重载。</p>
<pre><code>ostream&amp; ostream::operator&lt;&lt;(int n)
{
    ....//输出n的代码
    return *this;
}</code></pre><p>为什么返回值类型为<code>ostream&amp;</code>？这是因为这样可以实现连续输出，如<code>cout&lt;&lt;5&lt;&lt;4</code>。当然只有这个重载是不够的，因为这样只能实现输出数字，而<code>cout&lt;&lt;&quot;hello&quot;</code>是也成立的，因此还要有：</p>
<pre><code>ostream&amp; ostream::operator&lt;&lt;(const char* s)
{
    ....//输出s的代码
    return *this;
}</code></pre><p>等等适用于各种情况的代码。当然我们自己也是可以继续对<code>&lt;&lt;</code>进行重载的，使得它能够满足我们输出的需要。</p>
<h2 id="自加自减运算符的重载"><a href="#自加自减运算符的重载" class="headerlink" title="自加自减运算符的重载"></a>自加自减运算符的重载</h2><p>递增运算符<code>++</code>和递减运算符<code>--</code>是C++语言中两个重要的一元运算符。它们有前缀和后缀两种用法。继续上面的例子，演示如何使用递增运算符重载。</p>
<pre><code>complex&amp; complex::operator++()
 {
     real=real+1;
     return *this;
 }</code></pre><p>我重载<code>++</code>运算符的作用为使复数的实部加1。仔细观察代码，我们可以发现与其他运算符的重载不同，因为不涉及其他对象，所以无参数。当重载为后缀的时候有一个参数，但是是无意义的，只是用来说明为后缀运算符而已。</p>
<h2 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h2><p>函数调用运算符<code>()</code>可以被重载用于类的对象。如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。继续以上面代码为例：</p>
<pre><code>complex&amp; complex::operator()(int a,int b,int c)
 {
     real=a+b+c;
     image=a-b-c;
     return *this;
 }</code></pre><p>主函数里：</p>
<pre><code>s4=s4(3,2,1);
s4.showcomplex();</code></pre><p>输出结果为：<br><img src="https://i.loli.net/2020/01/21/TvjEFWsxKgYHlbV.png" alt=""><br>可以看到，以调用函数的方式调用了对象，调用对象实际上是在运行重载的调用运算符。函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。如果类定义了调用运算符，则该类的对象称作函数对象。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。在后面会讲到有关函数对象的知识。  </p>
<p>还有很多的运算符可以进行重载，它们的功能也各不相同，在此就不一一介绍，运算符重载是很重要的一个部分，对程序的编写有很大帮助。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>类及类的成员3</title>
    <url>/2020/01/19/%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%983/</url>
    <content><![CDATA[<p>摘要：本篇博客中将主要介绍this指针、常量对象及常量成员函数、运算符重载方面的知识。其中运算符重载是应用很广泛的，也是C++中很重要的一个知识，对运算符重载进行掌握是很有必要的。</p>
<a id="more"></a>

<p>C++是从C发展而来的，而在C语言中是没有类的概念的，C语言中的函数都是全局函数，C++中则有成员函数，所以问题来了，成员函数在C中该如何表达？C中用<code>struct</code>结构体可以将类表示出来，而成员函数则需要借助this指针。</p>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>this指针指向了成员函数作用的对象，在成员函数执行的过程中，正是通过this指针才能找到对象所在的地址，因而也就能找到对象的所有非静态成员变量的地址。<br>C++ 规定，在非静态成员函数内部可以直接使用<code>this</code>关键字，<code>this</code>就代表指向该函数所作用的对象的指针。我们以下面运算符重载的代码中的一部分为例：</p>
<pre><code>complex&amp; complex::operator+(const complex &amp;s1)
{
    real=real+s1.real;
    image=image+s1.image;
    return *this ;
 } </code></pre><p>return应该返回的是函数的返回值类型<code>complex&amp;</code>，所以此时this指针指向的对象就是<code>complex</code>的一个对象的引用（返回对象同理）。这里的<code>this-&gt;real</code>和<code>real</code>是等价的。</p>
<h2 id="常量对象和常量成员函数"><a href="#常量对象和常量成员函数" class="headerlink" title="常量对象和常量成员函数"></a>常量对象和常量成员函数</h2><p>假如不希望某些东西被修改，可以使用<code>const</code>关键字进行限定。C++中，<code>const</code>可以用来修饰对象、成员变量和成员函数。<br>在类的成员函数说明后面加<code>const</code>，const成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const成员函数也称为常量成员函数。需要强调的是，必须在成员函数的声明和定义处同时加上<code>const</code>关键字。</p>
<pre><code>class sample
{
    public:
        int value;
        void getvalue() const;    
};
void sample::getvalue() const
{
    value=0;  //出错，不能改变变量的值 
}</code></pre><p><code>const</code>的位置不同，表示的含义也不同，函数开头的<code>const</code>用来修饰函数的返回值，表示返回值是<code>const</code>类型，也就是不能被修改。函数头部的结尾加上<code>const</code>表示常量成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值。<br>定义对象时同样可以定义为常量对象，这样对象初始化以后就不会再改变。<br>常量成员变量就和普通的const变量相似。</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>前面我们已经学过函数重载的概念，一个类中可以有多个构造函数，它们也是通过重载实现的。函数重载可以让一个函数有多种功能，在不同情况下实现不同的操作。运算符重载也是相同的道理，使运算符具有不同的功能。<br>C++本身已经对运算符进行了重载，比如我们进行<code>int</code>型数据相加时，直接调用加号就行。但是当我们使两个对象相加时，该怎么办呢？例如我们定义了复数类的两个对象，使它们相加，只用加号是无法实现的。这时候就需要我们自己对运算符重载，使得复数的实部和实部相加，虚部和虚部相加。<br>运算符重载可以重载为成员函数，普通函数和友元函数。声明格式一般为：</p>
<p><code>返回值类型 operator 运算符 (形参表)</code><br>以下面的代码为例，可知运算符重载的方法和作用：</p>
<pre><code>class complex
{
    public:
        int real,image;
        complex(int,int);
        ~complex();
        complex&amp; operator+(const complex&amp;);
        complex&amp; operator-(const complex&amp;);
        void showcomplex();
};
complex::complex(int a=0,int b=0)
{
    real=a;
    image=b;
}
complex::~complex()
{
}
complex&amp; complex::operator+(const complex &amp;s1)
{
    real=real+s1.real;
    image=image+s1.image;
    return *this ;
 } 
 complex&amp; complex::operator-(const complex &amp;s2)
 {
     real=real-s2.real;
     image=image-s2.image;
     return *this;
 }
 void complex::showcomplex()
 {
     cout&lt;&lt;real&lt;&lt;&quot;+j&quot;&lt;&lt;image&lt;&lt;endl;
 }
int main()
{
    complex s1(2,3);
    complex s2(3,4);
    complex s3,s4;
    s3=s1+s2;
    s3.showcomplex();
    s4=s3-s2;
    s4.showcomplex();
    return 0;
} </code></pre><p>代码的运行结果为:<br><img src="https://i.loli.net/2020/01/19/Y2ki3ZNgez7ElKX.png" alt=""><br>可见通过运算符重载，实现了复数类对象的运算。上面讲的只是简单的加减乘除运算符的重载。在下篇博客里，将会针对运算符重载深入研究，讲解赋值运算符、流插入和流提取运算符等其他运算符重载的用法。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>类及类的成员2</title>
    <url>/2020/01/15/%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%982/</url>
    <content><![CDATA[<p>摘要：本篇博客接着上一篇的向下学习，将对静态成员、成员对象和封闭类、友元以及this指针进行介绍并说明它们的用法。</p>
<a id="more"></a>

<p>在上一篇中已经讲过了类的概念，知道类包括成员变量和成员函数两部分，而在C的知识学习中，也学习过静态变量这一概念。同样的，当在定义类时，根据需求的不同，我们可以定义为静态成员变量和静态成员函数。</p>
<h2 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h2><p>静态成员的关键字为<code>static</code>，静态成员变量就是在定义时前面加了 <code>static</code>关键字的成员变量；静态成员函数就是在声明时前面加了<code>static</code>关键字的成员函数。<br>普通成员变量为每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。普通成员函数必须作用于某个对象(例如在上一篇时钟代码中的设置时间函数，访问方式为<code>r.settime()</code>)，而静态成员函数并不具体作用于某个对象。因此静态成员不需要通过对象就能访问，可以直接<code>clock::settime()</code>访问，通过类名而不需要通过对象。它的本质上是全局变量和全局函数，<strong>因此必须在定义类的文件中静态成员变量进行一次声明，否则不行</strong>。静态成员函数内部不能访问非静态成员变量，设置静态成员的目的，是为了将和某些类紧密相关的全局变量和全局函数写到类里面，形式上成为一个整体。</p>
<h2 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h2><p>成员对象指的是一个类的成员变量是另一个类的对象。包含成员对象的类叫封闭类。比如封闭类汽车的成员变量有类轮胎的一个实例化对象和类引擎的一个实例化对象，这两个成员对象。封闭类需要自定义构造函数，不能再用默认构造函数，因为有些成员对象无法默认初始化。在定义封闭类的构造函数时，添加初始化列表：</p>
<p><code>类名：：构造函数（参数表）：成员变量1（参数表），成员变量2（参数表）,…{     }</code></p>
<p>当封闭类对象生成时，先执行所有成员对象的构造函数，再执行封闭类的构造函数。成员对象的构造函数调用顺序和成员对象在类中的声明顺序一致与在初始化列表中出现的顺序无关。当封闭类的对象消亡时，先执行封闭类的析构函数，再执行成员对象的析构函数。析构函数调用顺序和构造函数调用顺序相反。</p>
<pre><code>class Engine
{
    private:
        int price;
    public:
        Engine(int p)
       {
           price = p;
           cout &lt;&lt; &quot;Engine constructor is called&quot; &lt;&lt; endl;
        }
        ~Engine()
        {
            cout &lt;&lt; &quot;Engine deconstructor is called&quot; &lt;&lt; endl;
        }
};
class tyer
{
    private :
        int width, length;
    public:
        tyer(int w, int l) :width(w), length(l)
        {
            cout &lt;&lt; &quot;tyer constructor is called&quot; &lt;&lt; endl;
        };
        ~tyer()
        {
            cout &lt;&lt; &quot;tyer destructor is called&quot; &lt;&lt; endl;
        }
};
class car
{
    private :
        tyer ty;
        Engine en;
        int color;
    public:
        car(int col, int p, int w, int l);
        ~car()
        {
            cout &lt;&lt; &quot;car deconstructor is called&quot; &lt;&lt; endl;
        }
};
car::car(int col, int p, int w, int l) :color(col), en(p), ty(w, l)
{
    cout &lt;&lt; &quot;car constructor is called&quot; &lt;&lt; endl;
}
int main()
{
    car car1(2, 1, 4, 5);
    return 0;
}</code></pre><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在C++中，一个类中可以有<code>public、protected、private</code>三种属性的成员，通过对象可以访问<code>public</code>成员，只有本类中的函数可以访问本类的 <code>private</code>成员。现在，我们来介绍一种例外情况——友元（<code>friend</code>）。借助友元（<code>friend</code>），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的<code>private</code>成员。就相当于我是你的朋友，有些你的东西我也可以借用。<br>友元包括友元函数和友元类。一个类的友元函数可以访问该类的私有成员。若A是B的友元类，则A的所有成员函数都可以访问B的私有成员。</p>
<pre><code>class A
{
    private:
        int a;
    public:
        A(int);
        void show();
        friend void add(A); 
 } ;
 A::A(int b)
 {
     a=b;
 }
 void A::show()
 {
     cout&lt;&lt;a;
 }
 void add(A A1)
 {
     int b;
     b=A1.a+1;
     cout&lt;&lt;b&lt;&lt;endl;
 }
 int main()
 {
     A A1(4);
     add(A1);
     A1.show();
     return 0;
 }</code></pre><p>如上面代码所示，我定义了一个类A，又定义了一个友元函数<code>add()</code>，使得它可以访问A的私有成员。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>类及类的成员1</title>
    <url>/2020/01/13/%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%981/</url>
    <content><![CDATA[<p>摘要：在本篇博客里主要讲了C++的一些基础知识，主要有类的概念、类的成员、构造函数和析构函数等。并用代码举例说明构造函数和析构函数的调用顺序。</p>
<a id="more"></a>

<p>C++是完全包容C的，它与C的不同之处在于C++是面向对象的语言，而C是面向过程的。什么是面向过程？即分析出实现需求所需要的步骤，通过函数一步步实现这些步骤，依次调用函数即可。什么是面向对象？我们将繁琐的步骤，通过行为、功能模块化。创建了对象这一概念。而要体现面向对象这一思想，类是很关键的一个部分。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>将一类事物的共同特性抽象出来，包括了数据结构和算法，数据结构表示了共同属性，算法即函数表示了它们的行为。将它们封装构成了一个类。这有点类似于C语言中的<code>struct</code>结构，但是又是不一样的，<code>struct</code>只包括了数据结构即成员变量，而类还包含了成员函数。</p>
<h3 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h3><p>类的成员包括成员变量和成员函数。成员又包括私有成员和公共成员。私有成员只能通过成员函数内部访问，但是不能在该类之外通过其他函数对私有成员进行访问。公共成员都可以进行访问。<br>一般在类中只定义成员变量和成员函数以及它们的类型（公共还是私有），数据一般定义为私有，函数定义为公共的。<br>创建类的关键字为<code>class</code>或<code>struct</code>,<code>class</code>中未说明的成员类型为私有，<code>struct</code>中未说明的成员类型为公共。</p>
<pre><code>class student
{
    string sname;
    public:
    void showname();
}</code></pre><p>如上面代码所示，我们定义了函数<code>showname()</code>为公共类型，而对数据变量<code>sname</code>并没有说明，此时默认它是私有的，只能由内部的成员函数访问。而在<code>struct</code>中则正好相反，未说明则为公共的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在类的成员函数中，首先就要先学习构造函数。构造函数用于当类创建一个对象时，对该对象进行初始化。构造函数是没有返回值类型的。如果不自定义构造函数，编译器生成一个默认构造函数（无参数）。它不做任何操作，无作用。</p>
<pre><code>class clock
{
    public:
     clock(int newh,int newm,int news);
     void settime(int newh,int newm,int news);
     void showtime();
    private:
     int hour,minute,second;
};
clock::clock(int newh,int newm,int news)
{
    hour=newh;
    minute=newm;
    second=news;
}
void clock::settime(int newh,int newm,int news)
{
    hour=newh;
    minute=newm;
    second=news;
}
void clock::showtime()
{
    cout&lt;&lt;hour&lt;&lt;&quot;:&quot;&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;second;
}
int main()
{
    int a,b,c;
    clock r(0,0,0);
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
    r.settime(a,b,c);
    r.showtime();
    return 0;
}</code></pre><p>在上面所示的代码中，我定义了一个时钟类，构造函数传入了3个参数，用于初始化时间。成员变量为时、分、秒，定义为私有的，成员函数有构造函数、设置时间函数、显示时间函数，定义为公共的，这样我们对其调用。<br><strong>一个类里可以有多个构造函数，根据需求自定义和调用</strong>。复制构造函数是一种特殊的构造函数，它由编译器调用来完成一些基于同一类的其他对象的构建及初始化。例如在上面的代码中，如果我们再创建一个clock对象r1，就可以调用默认的复制构造函数，使它与r相同：</p>
<pre><code>clock r1(r);</code></pre><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>名字与类名相同，但在前面多了一个~符号，没有返回值类型。<strong>一个类只能有一个析构函数，且没有参数</strong>。若定义类时不写析构函数，则编译器生成缺省析构函数。当对数组进行析构函数定义时，数组的每个元素都会调用一次析构函数，构造函数同理。先被构造的函数最后被释放，每生成一个对象的同时必会调用构造函数，在作用域结束时会调用析构函数。</p>
<pre><code>class student
{
    public:
        student();
        ~student();
        void setnameage(string,int);
        void showname();
        void showage();
    private:    
        int age;
        string s;
};
student::student()
{
    cout&lt;&lt;&quot;构造函数调用了&quot;&lt;&lt;endl;
}
student::~student()
{
    cout&lt;&lt;&quot;析构函数调用了&quot;&lt;&lt;endl;
}
void student::setnameage(string ss,int newage)
{
    s=ss;
    age=newage;
}
void student::showname()
{
    cout&lt;&lt;s&lt;&lt;endl;
}
void student::showage()
{
    cout&lt;&lt;age&lt;&lt;endl;
}
int main()
{
    string s;
    int a;
    student s1;
    cin&gt;&gt;s&gt;&gt;a;
    s1.setnameage(s,a);
    s1.showname();
    s1.showage();
    return 0;
}</code></pre><p>上面代码的运行结果如下：<br><img src="https://i.loli.net/2020/01/13/RfKcNU1atTCdPnG.png" alt=""></p>
<p>由结果可知，当创建了对象s1的那一刻，就已经调用了构造函数，然后才是输入，输出，当运行到<code>return 0</code>时，对象s1消失，因此调用了析构函数，程序结束。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>C语言知识强化</title>
    <url>/2020/01/11/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BC%BA%E5%8C%96/</url>
    <content><![CDATA[<p>摘要：对已经学习过的C语言知识中一些比较特殊的地方进行强化记忆，主要有强制转换、全局变量、指针函数和函数指针、静态局部变量以及结构体等方面。</p>
<a id="more"></a>

<p>在本篇博客里我将会对C语言中的一些知识进行再次介绍，这些知识对以后的学习也很有帮助。</p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>C语言中的强制转换即在变量前面用括号声明你想要转换成的类型，这种方法简单实用，但是却无法说明转换的安全性。举例如下（将float类型的变量c转换为int型）：</p>
<pre><code>float c=2.5;
cout&lt;&lt;(int)c;</code></pre><p>这种情况下输出的值为2，也可以看出在编译器里不是四舍五入的。前面提到过转换的安全性，即强制类型转换是有风险的不是想转换就能随便转换的，在后面C++知识的学习中，将会有一节专门讲强制类型转换，依靠<code>static_cast</code>、<code>interpret_cast</code>、<code>const_cast</code>、 <code>dynamic_cast</code>四种，它们比C语言的这种更加安全和功能具体。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>变量分为局部与全局，局部变量又可称之为内部变量。由某对象或某个函数所创建的变量通常都是局部变量，只能被内部引用，而无法被其它对象或函数引用。<br>全局变量既可以是某对象函数创建，也可以是在本程序任何地方创建。全局变量是可以被本程序所有对象或函数引用。只有定义为全局变量，void子函数作用的值才会传递到main函数里。定义完全局变量后，函数里就不再定义。</p>
<pre><code>void exchange(int m,int n)
{
    int p=0;
    p=m;m=n;n=p;
}
int main()
{
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    exchange(a,b);
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b;
    return 0;
}</code></pre><p>在上面的例子中，a、b的值并不会被交换，这是因为a、b并没有真的被传递到exchange函数中，且函数并没有返回值，也不会改变主函数中的a、b。如果我们定义a、b为全局变量，如下则可实现功能：</p>
<pre><code>int a,b;
void exchange()
{
    int p=0;
    p=a;a=b;b=p;
}
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    exchange();
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b;
    return 0;
}</code></pre><p>这时，主函数以及exchange函数中的a、b都为全局变量定义的a、b，会随之改变。需要强调的一点是，当一个变量既是局部变量又是全局变量时，局部变量会屏蔽作用范围的全局变量。由于在C++中引入了类的概念，变量被封装在类中，对别的类不可见，相当于抛弃了全局变量。</p>
<h2 id="指针函数和函数指针"><a href="#指针函数和函数指针" class="headerlink" title="指针函数和函数指针"></a>指针函数和函数指针</h2><p>指针是指向变量的地址。指针一般与数组用在一起。数组名也相当于指向数组第一个元素的指针，但是它不能被改变。指针函数的意思是函数传入的参数为指针变量。如<code>void change(int *p)</code>，当我们调用指针函数时直接把指针当参数输入即可<code>change(p)</code>。函数指针指的是一个函数它的返回值是指针类型的。即<code>int *p(int x,int y)</code>。下面是一个指针函数的例子，与上面的比较可知，它能避免定义全局变量的同时使交换起作用：</p>
<pre><code>void change(int *q1,int *q2)
{
    int temp;
    temp=*q1;
    *q1=*q2;
    *q2=temp;
}
int main()
{
    int a,b,*p1,*p2;
    cin&gt;&gt;a&gt;&gt;b;
    p1=&amp;a;
    p2=&amp;b;
    change(p1,p2);
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b;
    return 0;
 } </code></pre><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><p>静态局部变量的关键字为<code>static</code>，静态局部变量在函数里定义，但是它跟局部变量不同，局部变量会随着函数的结束而释放，当静态局部变量不会，它只定义一次，而且不会被重新赋值和消失直到整个程序结束。</p>
<pre><code>void a()
{
    int a=0;
    static int b=0;
    a=a+1;
    b=b+1;
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl;
}
int main()
{
    int i=0;
    for(i=0;i&lt;4;i++)
    {
        a();
    }
    return 0;
}</code></pre><p>a的输出结果为1、1、1、1，b的输出结果为1、2、3、4。产生这种差别的原因就是a不是静态局部变量，当a函数结束，a也消失，而b不会消失，依然保持着自己的值。当再次调用a函数时，a重新被赋值为0，但b却不在赋值，它只会在第一次调用时赋值一次，因此b随着循环每次加1，而a总是变成0再加1。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体的关键字是<code>struct</code>，需要注意的是在C++中也有这个关键字，但是不再表示结构体，而是类，会在以后的学习中介绍。C语言中的结构体主要是把多个有关系的变量写在一个结构里，便于调用和赋值。如下所示：    </p>
<pre><code>struct student
{ 
    int id-num;
    Int name[10];
}; </code></pre><p>定义了一个学生的结构体，其中有学生的名字和学号，当调用时：</p>
<pre><code>student  mike；  
mike.id-num=123;
mike.name[10]=mike;</code></pre><p>C语言中还有很多的知识和技巧，这里就不再一一列述。在接下来会进入到C++基础知识的学习。加油！</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>博客初识</title>
    <url>/2020/01/10/%E5%8D%9A%E5%AE%A2%E5%88%9D%E5%A7%8B/</url>
    <content><![CDATA[<p>开始尝试写博客啦</p>
<a id="more"></a>

<h2 id="很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced-road-，希望我的水平不断提高。"><a href="#很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced-road-，希望我的水平不断提高。" class="headerlink" title="很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced road)，希望我的水平不断提高。"></a>很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced road)，希望我的水平不断提高。</h2><pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;&quot;Hello,world!&quot;;
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/09/hello-world/</url>
    <content><![CDATA[<p>Welcome!</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
