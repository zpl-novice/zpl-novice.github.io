<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>继承和派生</title>
    <url>/2020/01/24/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/</url>
    <content><![CDATA[<p>摘要：在前面已经讲了类的有关概念，而不同的类之间是有关系的。相关的关系有继承和复合关系等。在本篇中将会介绍以下继承和派生的相关概念。这也是面向对象中很重要的一个概念，通过继承和派生可以提高代码执行效率。</p>
<a id="more"></a>

<p>类并不是孤立的存在的，不同的类之间有着不同的关系，正如前面所讲过的友元类。假如已经定义了一个动物类，里面有动物的成员变量和成员函数，此时若要再定义一个哺乳动物类该怎么办？可以看出，哺乳动物属于动物，它也具有动物类的所有特性。因此只需要继承动物类即可。<br>继承：在定义一个新的类B时，如果该类与某个已有的类A相似（B拥有A的全部特点），那么就可以把A作为一个基类，而把B作为基类的一个派生类。派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。派生类一经定义后，可以独立使用，不依赖于基类。继承代表了 is a 关系。<strong>派生类成员函数不能访问基类的私有成员</strong>。<br>根据上面的概念可知，派生类是由基类派生而来，因此基类的成员变量和成员函数在派生类也有。一般情况下，在派生类里的指的是派生类定义的成员，若要访问基类的（公共的）同名成员变量和成员函数，需要加上基类名，即<code>base::I</code>、<code>base::func()</code>。<br>派生类的定义格式为：<br><code>class 派生类名：public 基类名</code><br>这里的<code>public</code>也可以换为<code>protected</code>和<code>private</code>，它们表示了继承类型，但我们通常使用的都是<code>public</code>继承。一个基类可以派生出多个派生类。<br>前面讲过公有成员和私有成员，这里讲一下保护成员（protected）。它与私有成员不同的地方在于它可以被派生类的成员函数访问。其他访问方式与私有成员相同。  </p>
<h2 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h2><p>派生类的其他成员函数如前面所讲的定义即可，但构造函数略有不同，因为派生类是继承基类而来，所以在派生类的构造函数中要先去调用基类的构造函数。如果不调用基类构造函数，因为派生类成员函数不能调用基类私有成员，无法实现初始化。派生类的构造函数定义为：<br><code>派生类名（成员变量1，2，3...）：基类构造函数（成员变量1，2...）</code><br>成员变量1，2，3为形参名，以下面代码为例：</p>
<pre><code>class base
{
    private:
        int n;
    public:
        base(int i=0):n(i)
        {
            cout&lt;&lt;&quot;基类构造&quot;&lt;&lt;endl&lt;&lt;n&lt;&lt;endl;
        }
        ~base()
        {
            cout&lt;&lt;&quot;基类析构&quot;&lt;&lt;endl;
        }
        void print();
};
void base::print()
{
    cout&lt;&lt;n&lt;&lt;endl;
}
class derive:public base
{
    public:
        int a;
        derive(int i=0,int j=0);
        ~derive()
        {
            cout&lt;&lt;&quot;继承类析构&quot;&lt;&lt;endl;
        }
};
derive::derive(int i,int j):base(i)
{
    a=j;
    cout&lt;&lt;&quot;继承类构造&quot;&lt;&lt;endl&lt;&lt;a&lt;&lt;endl;
}
int main()
{
  derive b(2,1);
  b.print();
  return 0;
}</code></pre><p>可以看到，在代码的构造函数和析构函数中，都输出是属于哪个类的。在派生类的构造函数中，定义了两个形参i和j，第一形参i是基类构造函数中的参数，派生类新增加的成员变量a用形参j赋值，这样就实现了派生类的构造函数。而派生类也有基类的成员函数，因此派生类对象b可以调用<code>print()</code>函数输出。运行结果为:<br><img src="https://i.loli.net/2020/01/24/ABGCPKpOb9ZjNed.png" alt=""><br>在结果中我们也可以看到构造函数和析构函数的调用顺序，<strong>先构造的后析构，先基类构造再派生类构造</strong>。<br>假如我们定义基类对象为b，派生类对象为d：  </p>
<pre><code>base b;
derive d;</code></pre><p>1.派生类对象可以赋值给基类对象，即<code>b=d</code>。而反过来不行，这也是反映了前面所说的 is a 关系。<br>2.派生类对象可以初始化基类引用，即<code>base &amp;br=d</code>。<br>3.派生类对象的地址可以赋值给基类指针，即<code>base *pd=d</code>。  </p>
<h2 id="直接基类和间接基类"><a href="#直接基类和间接基类" class="headerlink" title="直接基类和间接基类"></a>直接基类和间接基类</h2><p>上面所讲一个类可以派生出多个类。而派生类也可以作为基类再派生。如动物类可以派生出哺乳动物类，而哺乳动物类又可以派生出人类。这样，动物类和哺乳动物类都是人类的基类。哺乳动物类是直接基类，动物类是间接基类。声明派生类时，只需列出它的直接基类。但是派生类的成员包括自己定义、直接基类、间接基类的所有成员。<br>上面介绍了继承和派生的概念，类与类之间可能是继承关系，但如果一个类的对象是另一个类的成员呢？这属于什么关系？以圆类为例，圆有两个重要的成员，圆心和半径。而圆心是一个点，它属于点类的一个对象。此时定义圆类和点类为复合关系，<strong>复合关系一般把大的类声明为另一个类的友元</strong>。<br>面向对象的三个特征：封装、继承、多态。在下篇中将会进入到多态的学习，多态使得C++变的非常灵活，大大提高效率，是非常重要的一部分。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/2020/01/21/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>摘要：上一篇博客当中已经讲了什么是运算符重载，并且介绍了加减乘除等运算符如何重载及它们的用法。在本篇博客当中将会继续就运算符重载进行深入介绍，主要有赋值运算符的重载、流插入和流提取运算符、自加自减运算符以及函数调用<code>（）</code>运算符的重载。</p>
<a id="more"></a>

<p>在众多的运算符当中，不是所有的都可以被重载，只有一部分可以，下面是可以被重载的运算符列表：<br><img src="https://i.loli.net/2020/01/21/kVxI5OW4FAGDiY3.png" alt=""><br>可以看到，上篇博客中讲的是双目算术运算符的重载，本篇将会讲解其他类型的运算符重载，比如赋值运算符等。不同的运算符重载具有不同的功能。</p>
<h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>在赋值运算符重载中，我将会讲解<code>=</code>这个运算符，从名字就可以看出来，重载的功能主要是赋值，但特殊的地方在于它两边的类型可以不匹配。例如将一个<code>int</code>类型变量赋值给一个<code>complex</code>对象，将一个<code>char*</code>类型的字符串赋值给一个字符串对象或者将一个对象赋值给另一个对象等。需要注意的一点是，赋值运算符<code>=</code>只能重载为成员函数。继续以上篇博客中的代码为例，添加赋值运算符<code>=</code>的重载代码如下：</p>
<pre><code>complex&amp; complex::operator=(const complex &amp;s3)
 {
     real=s3.real;
     image=s3.image;
     return *this;
 }</code></pre><p>主函数：</p>
<pre><code>int main()
{
    complex s1(2,3);
    complex s2(3,4);
    complex s3,s4;
    s3=s1+s2;
    s3.showcomplex();
    s4=s3-s2;
    s4.showcomplex();
    s4=s2;
    s4.showcomplex();
    return 0;
} </code></pre><p>运行结果为：<br><img src="https://i.loli.net/2020/01/21/qrTbeNRiX8tMdlx.png" alt=""><br>可见将对象s2成功赋值给了s4。若是想要将数据赋给对象只需要修改参数即可。</p>
<h2 id="流插入和流提取运算符重载"><a href="#流插入和流提取运算符重载" class="headerlink" title="流插入和流提取运算符重载"></a>流插入和流提取运算符重载</h2><p>在介绍这部分知识之前，先提出一个问题，为什么<code>cout&lt;&lt;5</code>、<code>cin&gt;&gt;a</code>能够成立，能够在编译器里运行？按照C语言当中学习的知识，我们想要输出一个东西时，会用<code>printf</code>关键字，要输入一个东西时，会用<code>scanf</code>关键字。在C++中为什么用<code>cout&lt;&lt;</code>、<code>cin&gt;&gt;</code>可以实现上述功能呢？<br><code>cout</code>是在<code>iostream</code>中定义的，<code>ostream</code>类的对象。<code>&lt;&lt;</code>能用在<code>cout</code>上是因为在<code>iostream</code>里对<code>&lt;&lt;</code>进行了重载。</p>
<pre><code>ostream&amp; ostream::operator&lt;&lt;(int n)
{
    ....//输出n的代码
    return *this;
}</code></pre><p>为什么返回值类型为<code>ostream&amp;</code>？这是因为这样可以实现连续输出，如<code>cout&lt;&lt;5&lt;&lt;4</code>。当然只有这个重载是不够的，因为这样只能实现输出数字，而<code>cout&lt;&lt;&quot;hello&quot;</code>是也成立的，因此还要有：</p>
<pre><code>ostream&amp; ostream::operator&lt;&lt;(const char* s)
{
    ....//输出s的代码
    return *this;
}</code></pre><p>等等适用于各种情况的代码。当然我们自己也是可以继续对<code>&lt;&lt;</code>进行重载的，使得它能够满足我们输出的需要。</p>
<h2 id="自加自减运算符的重载"><a href="#自加自减运算符的重载" class="headerlink" title="自加自减运算符的重载"></a>自加自减运算符的重载</h2><p>递增运算符<code>++</code>和递减运算符<code>--</code>是C++语言中两个重要的一元运算符。它们有前缀和后缀两种用法。继续上面的例子，演示如何使用递增运算符重载。</p>
<pre><code>complex&amp; complex::operator++()
 {
     real=real+1;
     return *this;
 }</code></pre><p>我重载<code>++</code>运算符的作用为使复数的实部加1。仔细观察代码，我们可以发现与其他运算符的重载不同，因为不涉及其他对象，所以无参数。当重载为后缀的时候有一个参数，但是是无意义的，只是用来说明为后缀运算符而已。</p>
<h2 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h2><p>函数调用运算符<code>()</code>可以被重载用于类的对象。如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。继续以上面代码为例：</p>
<pre><code>complex&amp; complex::operator()(int a,int b,int c)
 {
     real=a+b+c;
     image=a-b-c;
     return *this;
 }</code></pre><p>主函数里：</p>
<pre><code>s4=s4(3,2,1);
s4.showcomplex();</code></pre><p>输出结果为：<br><img src="https://i.loli.net/2020/01/21/TvjEFWsxKgYHlbV.png" alt=""><br>可以看到，以调用函数的方式调用了对象，调用对象实际上是在运行重载的调用运算符。函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。如果类定义了调用运算符，则该类的对象称作函数对象。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。在后面会讲到有关函数对象的知识。  </p>
<p>还有很多的运算符可以进行重载，它们的功能也各不相同，在此就不一一介绍，运算符重载是很重要的一个部分，对程序的编写有很大帮助。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>类及类的成员3</title>
    <url>/2020/01/19/%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%983/</url>
    <content><![CDATA[<p>摘要：本篇博客中将主要介绍this指针、常量对象及常量成员函数、运算符重载方面的知识。其中运算符重载是应用很广泛的，也是C++中很重要的一个知识，对运算符重载进行掌握是很有必要的。</p>
<a id="more"></a>

<p>C++是从C发展而来的，而在C语言中是没有类的概念的，C语言中的函数都是全局函数，C++中则有成员函数，所以问题来了，成员函数在C中该如何表达？C中用<code>struct</code>结构体可以将类表示出来，而成员函数则需要借助this指针。</p>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>this指针指向了成员函数作用的对象，在成员函数执行的过程中，正是通过this指针才能找到对象所在的地址，因而也就能找到对象的所有非静态成员变量的地址。<br>C++ 规定，在非静态成员函数内部可以直接使用<code>this</code>关键字，<code>this</code>就代表指向该函数所作用的对象的指针。我们以下面运算符重载的代码中的一部分为例：</p>
<pre><code>complex&amp; complex::operator+(const complex &amp;s1)
{
    real=real+s1.real;
    image=image+s1.image;
    return *this ;
 } </code></pre><p>return应该返回的是函数的返回值类型<code>complex&amp;</code>，所以此时this指针指向的对象就是<code>complex</code>的一个对象的引用（返回对象同理）。这里的<code>this-&gt;real</code>和<code>real</code>是等价的。</p>
<h2 id="常量对象和常量成员函数"><a href="#常量对象和常量成员函数" class="headerlink" title="常量对象和常量成员函数"></a>常量对象和常量成员函数</h2><p>假如不希望某些东西被修改，可以使用<code>const</code>关键字进行限定。C++中，<code>const</code>可以用来修饰对象、成员变量和成员函数。<br>在类的成员函数说明后面加<code>const</code>，const成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const成员函数也称为常量成员函数。需要强调的是，必须在成员函数的声明和定义处同时加上<code>const</code>关键字。</p>
<pre><code>class sample
{
    public:
        int value;
        void getvalue() const;    
};
void sample::getvalue() const
{
    value=0;  //出错，不能改变变量的值 
}</code></pre><p><code>const</code>的位置不同，表示的含义也不同，函数开头的<code>const</code>用来修饰函数的返回值，表示返回值是<code>const</code>类型，也就是不能被修改。函数头部的结尾加上<code>const</code>表示常量成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值。<br>定义对象时同样可以定义为常量对象，这样对象初始化以后就不会再改变。<br>常量成员变量就和普通的const变量相似。</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>前面我们已经学过函数重载的概念，一个类中可以有多个构造函数，它们也是通过重载实现的。函数重载可以让一个函数有多种功能，在不同情况下实现不同的操作。运算符重载也是相同的道理，使运算符具有不同的功能。<br>C++本身已经对运算符进行了重载，比如我们进行<code>int</code>型数据相加时，直接调用加号就行。但是当我们使两个对象相加时，该怎么办呢？例如我们定义了复数类的两个对象，使它们相加，只用加号是无法实现的。这时候就需要我们自己对运算符重载，使得复数的实部和实部相加，虚部和虚部相加。<br>运算符重载可以重载为成员函数，普通函数和友元函数。声明格式一般为：</p>
<p><code>返回值类型 operator 运算符 (形参表)</code><br>以下面的代码为例，可知运算符重载的方法和作用：</p>
<pre><code>class complex
{
    public:
        int real,image;
        complex(int,int);
        ~complex();
        complex&amp; operator+(const complex&amp;);
        complex&amp; operator-(const complex&amp;);
        void showcomplex();
};
complex::complex(int a=0,int b=0)
{
    real=a;
    image=b;
}
complex::~complex()
{
}
complex&amp; complex::operator+(const complex &amp;s1)
{
    real=real+s1.real;
    image=image+s1.image;
    return *this ;
 } 
 complex&amp; complex::operator-(const complex &amp;s2)
 {
     real=real-s2.real;
     image=image-s2.image;
     return *this;
 }
 void complex::showcomplex()
 {
     cout&lt;&lt;real&lt;&lt;&quot;+j&quot;&lt;&lt;image&lt;&lt;endl;
 }
int main()
{
    complex s1(2,3);
    complex s2(3,4);
    complex s3,s4;
    s3=s1+s2;
    s3.showcomplex();
    s4=s3-s2;
    s4.showcomplex();
    return 0;
} </code></pre><p>代码的运行结果为:<br><img src="https://i.loli.net/2020/01/19/Y2ki3ZNgez7ElKX.png" alt=""><br>可见通过运算符重载，实现了复数类对象的运算。上面讲的只是简单的加减乘除运算符的重载。在下篇博客里，将会针对运算符重载深入研究，讲解赋值运算符、流插入和流提取运算符等其他运算符重载的用法。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>类及类的成员2</title>
    <url>/2020/01/15/%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%982/</url>
    <content><![CDATA[<p>摘要：本篇博客接着上一篇的向下学习，将对静态成员、成员对象和封闭类、友元以及this指针进行介绍并说明它们的用法。</p>
<a id="more"></a>

<p>在上一篇中已经讲过了类的概念，知道类包括成员变量和成员函数两部分，而在C的知识学习中，也学习过静态变量这一概念。同样的，当在定义类时，根据需求的不同，我们可以定义为静态成员变量和静态成员函数。</p>
<h2 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h2><p>静态成员的关键字为<code>static</code>，静态成员变量就是在定义时前面加了 <code>static</code>关键字的成员变量；静态成员函数就是在声明时前面加了<code>static</code>关键字的成员函数。<br>普通成员变量为每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。普通成员函数必须作用于某个对象(例如在上一篇时钟代码中的设置时间函数，访问方式为<code>r.settime()</code>)，而静态成员函数并不具体作用于某个对象。因此静态成员不需要通过对象就能访问，可以直接<code>clock::settime()</code>访问，通过类名而不需要通过对象。它的本质上是全局变量和全局函数，<strong>因此必须在定义类的文件中静态成员变量进行一次声明，否则不行</strong>。静态成员函数内部不能访问非静态成员变量，设置静态成员的目的，是为了将和某些类紧密相关的全局变量和全局函数写到类里面，形式上成为一个整体。</p>
<h2 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h2><p>成员对象指的是一个类的成员变量是另一个类的对象。包含成员对象的类叫封闭类。比如封闭类汽车的成员变量有类轮胎的一个实例化对象和类引擎的一个实例化对象，这两个成员对象。封闭类需要自定义构造函数，不能再用默认构造函数，因为有些成员对象无法默认初始化。在定义封闭类的构造函数时，添加初始化列表：</p>
<p><code>类名：：构造函数（参数表）：成员变量1（参数表），成员变量2（参数表）,…{     }</code></p>
<p>当封闭类对象生成时，先执行所有成员对象的构造函数，再执行封闭类的构造函数。成员对象的构造函数调用顺序和成员对象在类中的声明顺序一致与在初始化列表中出现的顺序无关。当封闭类的对象消亡时，先执行封闭类的析构函数，再执行成员对象的析构函数。析构函数调用顺序和构造函数调用顺序相反。</p>
<pre><code>class Engine
{
    private:
        int price;
    public:
        Engine(int p)
       {
           price = p;
           cout &lt;&lt; &quot;Engine constructor is called&quot; &lt;&lt; endl;
        }
        ~Engine()
        {
            cout &lt;&lt; &quot;Engine deconstructor is called&quot; &lt;&lt; endl;
        }
};
class tyer
{
    private :
        int width, length;
    public:
        tyer(int w, int l) :width(w), length(l)
        {
            cout &lt;&lt; &quot;tyer constructor is called&quot; &lt;&lt; endl;
        };
        ~tyer()
        {
            cout &lt;&lt; &quot;tyer destructor is called&quot; &lt;&lt; endl;
        }
};
class car
{
    private :
        tyer ty;
        Engine en;
        int color;
    public:
        car(int col, int p, int w, int l);
        ~car()
        {
            cout &lt;&lt; &quot;car deconstructor is called&quot; &lt;&lt; endl;
        }
};
car::car(int col, int p, int w, int l) :color(col), en(p), ty(w, l)
{
    cout &lt;&lt; &quot;car constructor is called&quot; &lt;&lt; endl;
}
int main()
{
    car car1(2, 1, 4, 5);
    return 0;
}</code></pre><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在C++中，一个类中可以有<code>public、protected、private</code>三种属性的成员，通过对象可以访问<code>public</code>成员，只有本类中的函数可以访问本类的 <code>private</code>成员。现在，我们来介绍一种例外情况——友元（<code>friend</code>）。借助友元（<code>friend</code>），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的<code>private</code>成员。就相当于我是你的朋友，有些你的东西我也可以借用。<br>友元包括友元函数和友元类。一个类的友元函数可以访问该类的私有成员。若A是B的友元类，则A的所有成员函数都可以访问B的私有成员。</p>
<pre><code>class A
{
    private:
        int a;
    public:
        A(int);
        void show();
        friend void add(A); 
 } ;
 A::A(int b)
 {
     a=b;
 }
 void A::show()
 {
     cout&lt;&lt;a;
 }
 void add(A A1)
 {
     int b;
     b=A1.a+1;
     cout&lt;&lt;b&lt;&lt;endl;
 }
 int main()
 {
     A A1(4);
     add(A1);
     A1.show();
     return 0;
 }</code></pre><p>如上面代码所示，我定义了一个类A，又定义了一个友元函数<code>add()</code>，使得它可以访问A的私有成员。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>类及类的成员1</title>
    <url>/2020/01/13/%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%981/</url>
    <content><![CDATA[<p>摘要：在本篇博客里主要讲了C++的一些基础知识，主要有类的概念、类的成员、构造函数和析构函数等。并用代码举例说明构造函数和析构函数的调用顺序。</p>
<a id="more"></a>

<p>C++是完全包容C的，它与C的不同之处在于C++是面向对象的语言，而C是面向过程的。什么是面向过程？即分析出实现需求所需要的步骤，通过函数一步步实现这些步骤，依次调用函数即可。什么是面向对象？我们将繁琐的步骤，通过行为、功能模块化。创建了对象这一概念。而要体现面向对象这一思想，类是很关键的一个部分。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>将一类事物的共同特性抽象出来，包括了数据结构和算法，数据结构表示了共同属性，算法即函数表示了它们的行为。将它们封装构成了一个类。这有点类似于C语言中的<code>struct</code>结构，但是又是不一样的，<code>struct</code>只包括了数据结构即成员变量，而类还包含了成员函数。</p>
<h3 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h3><p>类的成员包括成员变量和成员函数。成员又包括私有成员和公共成员。私有成员只能通过成员函数内部访问，但是不能在该类之外通过其他函数对私有成员进行访问。公共成员都可以进行访问。<br>一般在类中只定义成员变量和成员函数以及它们的类型（公共还是私有），数据一般定义为私有，函数定义为公共的。<br>创建类的关键字为<code>class</code>或<code>struct</code>,<code>class</code>中未说明的成员类型为私有，<code>struct</code>中未说明的成员类型为公共。</p>
<pre><code>class student
{
    string sname;
    public:
    void showname();
}</code></pre><p>如上面代码所示，我们定义了函数<code>showname()</code>为公共类型，而对数据变量<code>sname</code>并没有说明，此时默认它是私有的，只能由内部的成员函数访问。而在<code>struct</code>中则正好相反，未说明则为公共的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在类的成员函数中，首先就要先学习构造函数。构造函数用于当类创建一个对象时，对该对象进行初始化。构造函数是没有返回值类型的。如果不自定义构造函数，编译器生成一个默认构造函数（无参数）。它不做任何操作，无作用。</p>
<pre><code>class clock
{
    public:
     clock(int newh,int newm,int news);
     void settime(int newh,int newm,int news);
     void showtime();
    private:
     int hour,minute,second;
};
clock::clock(int newh,int newm,int news)
{
    hour=newh;
    minute=newm;
    second=news;
}
void clock::settime(int newh,int newm,int news)
{
    hour=newh;
    minute=newm;
    second=news;
}
void clock::showtime()
{
    cout&lt;&lt;hour&lt;&lt;&quot;:&quot;&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;second;
}
int main()
{
    int a,b,c;
    clock r(0,0,0);
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
    r.settime(a,b,c);
    r.showtime();
    return 0;
}</code></pre><p>在上面所示的代码中，我定义了一个时钟类，构造函数传入了3个参数，用于初始化时间。成员变量为时、分、秒，定义为私有的，成员函数有构造函数、设置时间函数、显示时间函数，定义为公共的，这样我们对其调用。<br><strong>一个类里可以有多个构造函数，根据需求自定义和调用</strong>。复制构造函数是一种特殊的构造函数，它由编译器调用来完成一些基于同一类的其他对象的构建及初始化。例如在上面的代码中，如果我们再创建一个clock对象r1，就可以调用默认的复制构造函数，使它与r相同：</p>
<pre><code>clock r1(r);</code></pre><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>名字与类名相同，但在前面多了一个~符号，没有返回值类型。<strong>一个类只能有一个析构函数，且没有参数</strong>。若定义类时不写析构函数，则编译器生成缺省析构函数。当对数组进行析构函数定义时，数组的每个元素都会调用一次析构函数，构造函数同理。先被构造的函数最后被释放，每生成一个对象的同时必会调用构造函数，在作用域结束时会调用析构函数。</p>
<pre><code>class student
{
    public:
        student();
        ~student();
        void setnameage(string,int);
        void showname();
        void showage();
    private:    
        int age;
        string s;
};
student::student()
{
    cout&lt;&lt;&quot;构造函数调用了&quot;&lt;&lt;endl;
}
student::~student()
{
    cout&lt;&lt;&quot;析构函数调用了&quot;&lt;&lt;endl;
}
void student::setnameage(string ss,int newage)
{
    s=ss;
    age=newage;
}
void student::showname()
{
    cout&lt;&lt;s&lt;&lt;endl;
}
void student::showage()
{
    cout&lt;&lt;age&lt;&lt;endl;
}
int main()
{
    string s;
    int a;
    student s1;
    cin&gt;&gt;s&gt;&gt;a;
    s1.setnameage(s,a);
    s1.showname();
    s1.showage();
    return 0;
}</code></pre><p>上面代码的运行结果如下：<br><img src="https://i.loli.net/2020/01/13/RfKcNU1atTCdPnG.png" alt=""></p>
<p>由结果可知，当创建了对象s1的那一刻，就已经调用了构造函数，然后才是输入，输出，当运行到<code>return 0</code>时，对象s1消失，因此调用了析构函数，程序结束。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>C语言知识强化</title>
    <url>/2020/01/11/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BC%BA%E5%8C%96/</url>
    <content><![CDATA[<p>摘要：对已经学习过的C语言知识中一些比较特殊的地方进行强化记忆，主要有强制转换、全局变量、指针函数和函数指针、静态局部变量以及结构体等方面。</p>
<a id="more"></a>

<p>在本篇博客里我将会对C语言中的一些知识进行再次介绍，这些知识对以后的学习也很有帮助。</p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>C语言中的强制转换即在变量前面用括号声明你想要转换成的类型，这种方法简单实用，但是却无法说明转换的安全性。举例如下（将float类型的变量c转换为int型）：</p>
<pre><code>float c=2.5;
cout&lt;&lt;(int)c;</code></pre><p>这种情况下输出的值为2，也可以看出在编译器里不是四舍五入的。前面提到过转换的安全性，即强制类型转换是有风险的不是想转换就能随便转换的，在后面C++知识的学习中，将会有一节专门讲强制类型转换，依靠<code>static_cast</code>、<code>interpret_cast</code>、<code>const_cast</code>、 <code>dynamic_cast</code>四种，它们比C语言的这种更加安全和功能具体。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>变量分为局部与全局，局部变量又可称之为内部变量。由某对象或某个函数所创建的变量通常都是局部变量，只能被内部引用，而无法被其它对象或函数引用。<br>全局变量既可以是某对象函数创建，也可以是在本程序任何地方创建。全局变量是可以被本程序所有对象或函数引用。只有定义为全局变量，void子函数作用的值才会传递到main函数里。定义完全局变量后，函数里就不再定义。</p>
<pre><code>void exchange(int m,int n)
{
    int p=0;
    p=m;m=n;n=p;
}
int main()
{
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    exchange(a,b);
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b;
    return 0;
}</code></pre><p>在上面的例子中，a、b的值并不会被交换，这是因为a、b并没有真的被传递到exchange函数中，且函数并没有返回值，也不会改变主函数中的a、b。如果我们定义a、b为全局变量，如下则可实现功能：</p>
<pre><code>int a,b;
void exchange()
{
    int p=0;
    p=a;a=b;b=p;
}
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    exchange();
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b;
    return 0;
}</code></pre><p>这时，主函数以及exchange函数中的a、b都为全局变量定义的a、b，会随之改变。需要强调的一点是，当一个变量既是局部变量又是全局变量时，局部变量会屏蔽作用范围的全局变量。由于在C++中引入了类的概念，变量被封装在类中，对别的类不可见，相当于抛弃了全局变量。</p>
<h2 id="指针函数和函数指针"><a href="#指针函数和函数指针" class="headerlink" title="指针函数和函数指针"></a>指针函数和函数指针</h2><p>指针是指向变量的地址。指针一般与数组用在一起。数组名也相当于指向数组第一个元素的指针，但是它不能被改变。指针函数的意思是函数传入的参数为指针变量。如<code>void change(int *p)</code>，当我们调用指针函数时直接把指针当参数输入即可<code>change(p)</code>。函数指针指的是一个函数它的返回值是指针类型的。即<code>int *p(int x,int y)</code>。下面是一个指针函数的例子，与上面的比较可知，它能避免定义全局变量的同时使交换起作用：</p>
<pre><code>void change(int *q1,int *q2)
{
    int temp;
    temp=*q1;
    *q1=*q2;
    *q2=temp;
}
int main()
{
    int a,b,*p1,*p2;
    cin&gt;&gt;a&gt;&gt;b;
    p1=&amp;a;
    p2=&amp;b;
    change(p1,p2);
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b;
    return 0;
 } </code></pre><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><p>静态局部变量的关键字为<code>static</code>，静态局部变量在函数里定义，但是它跟局部变量不同，局部变量会随着函数的结束而释放，当静态局部变量不会，它只定义一次，而且不会被重新赋值和消失直到整个程序结束。</p>
<pre><code>void a()
{
    int a=0;
    static int b=0;
    a=a+1;
    b=b+1;
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl;
}
int main()
{
    int i=0;
    for(i=0;i&lt;4;i++)
    {
        a();
    }
    return 0;
}</code></pre><p>a的输出结果为1、1、1、1，b的输出结果为1、2、3、4。产生这种差别的原因就是a不是静态局部变量，当a函数结束，a也消失，而b不会消失，依然保持着自己的值。当再次调用a函数时，a重新被赋值为0，但b却不在赋值，它只会在第一次调用时赋值一次，因此b随着循环每次加1，而a总是变成0再加1。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体的关键字是<code>struct</code>，需要注意的是在C++中也有这个关键字，但是不再表示结构体，而是类，会在以后的学习中介绍。C语言中的结构体主要是把多个有关系的变量写在一个结构里，便于调用和赋值。如下所示：    </p>
<pre><code>struct student
{ 
    int id-num;
    Int name[10];
}; </code></pre><p>定义了一个学生的结构体，其中有学生的名字和学号，当调用时：</p>
<pre><code>student  mike；  
mike.id-num=123;
mike.name[10]=mike;</code></pre><p>C语言中还有很多的知识和技巧，这里就不再一一列述。在接下来会进入到C++基础知识的学习。加油！</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>博客初识</title>
    <url>/2020/01/10/%E5%8D%9A%E5%AE%A2%E5%88%9D%E5%A7%8B/</url>
    <content><![CDATA[<p>开始尝试写博客啦</p>
<a id="more"></a>

<h2 id="很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced-road-，希望我的水平不断提高。"><a href="#很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced-road-，希望我的水平不断提高。" class="headerlink" title="很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced road)，希望我的水平不断提高。"></a>很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced road)，希望我的水平不断提高。</h2><pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;&quot;Hello,world!&quot;;
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/09/hello-world/</url>
    <content><![CDATA[<p>Welcome!</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
