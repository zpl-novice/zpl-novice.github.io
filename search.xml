<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>抽象数据类型和表ADT</title>
    <url>/2020/02/28/%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%A1%A8ADT/</url>
    <content><![CDATA[<p>摘要：本篇将开始对数据结构进行学习。首先介绍一下什么是抽象数据类型，以及表的抽象数据类型是什么样的。怎么对表进行实现？最后将通过前面C++ STL中的容器对表做进一步的介绍。</p>
<a id="more"></a>
<p>抽象数据类型（Abstract Data Type,ADT）是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象，在ADT的定义中没有地方提到关于这组操作是如何实现的任何解释。抽象数据类型不仅仅指那些已经定义并实现的数据类型，还可以是自定义的数据类型，比如我们定义一个<code>point</code>的抽象数据类型，它有<code>x,y,z</code>三个整型变量。抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。</p>
<h2 id="表ADT"><a href="#表ADT" class="headerlink" title="表ADT"></a>表ADT</h2><p>表是零个或多个数据元素的有限序列。元素是有顺序的，第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。表元素的个数n定义为表的长度，当n=0时，称为空表。在较复杂的表中，一个数据元素可以由若干个数据项组成。<br>根据表的特性，它有两种存储方式：顺序存储和链式存储。即用数组实现和链表实现。  </p>
<h3 id="表的简单数组实现"><a href="#表的简单数组实现" class="headerlink" title="表的简单数组实现"></a>表的简单数组实现</h3><p>表的顺序存储是用一段地址连续的存储单元依次存储表中的数据元素。因此可以用数组来实现。虽然数组由固定容量所创建，但是<code>vector</code>类（其内部存储一个数组）在需要的时候可以使容量成倍的增长。这就解决了数组大小的弊端。<br>表有几种常见的操作。如依次输出整个表、清空整个表、查找某一个元素、插入元素、删除元素等等。用数组可以实现上面的所有操作。当遍历和查找时，数组实现花费时间很少，这正是我们所期望的，在常数时间就可完成。然后当插入和删除时，却潜藏着昂贵的开销。在最坏的情形下，从表的前端插入，需要将整个数组后移一个位置来空出空间，而删除第一个元素则需要将表中的所有元素前移一个位置，因此这两种操作的最坏情况为O(n)。如果插入和删除操作发生在表的尾端，则只需要花费O(1)的时间。<br>存在许多情形，表是通过在尾端进行插入操作建成的，此后只发生访问操作。在这种情况下，数组是表的一种恰当的实现。然而，如果插入和删除操作遍及整个实现的表，特别是在表的前端，那么数组就不是一种好的选择。此时需要另一种实现：链表。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>为了避免插入和删除的线性开销，我们需要保证表可以不连续存储，即链式存储。<br><img src="https://i.loli.net/2020/02/28/JbE5rBc2Rkh8jMo.png" alt=""><br>链表由一系列结点组成，这些结点不必在内存中相连。一个结点包括两部分：数据域和指针域。结点中只包含一个指针域叫做单链表。规定最后一个结点指针为空。<br>当链表用来查找时，必须从头开始一个个往后找，因此时间复杂度为O(n)，比较耗费时间。插入和删除时的时间复杂度也是O(n)，因为需要先找到第i个结点，再进行插入和删除。但是当频繁的插入删除时，显然效率更高。<br>删除操作通过修改一个next指针来实现。如图：<br><img src="https://i.loli.net/2020/02/28/MV4WreUJCmEbk7o.png" alt=""><br>而插入操作则需要生成一个新结点，然后修改两个指针来实现，如图：<br><img src="https://i.loli.net/2020/02/28/CRwTNfOPGzY1SpA.png" alt=""><br>可以看到，如果知道变动将要的地方，那么插入或从链表中删除一项的操作不需要移动很多的项。现在的链表中每一项有它自身的数据以及指针指向下一项，但却没有跟它的上一项有关的东西。因此我们可以对指针域进行修改，使每个结点有两个指针域，一个指向前驱，一个指向后继。这种链表叫双向链表。<br><img src="https://i.loli.net/2020/02/28/EYMfZ9JdFhVmG5w.png" alt="">  </p>
<h2 id="C-中表的实现"><a href="#C-中表的实现" class="headerlink" title="C++中表的实现"></a>C++中表的实现</h2><p>在C++知识学习中讲过STL，STL中实现了很多常用的数据结构。本篇所将的表ADT就对应着STL中的<code>vector</code>和<code>list</code>类模板。<code>vector</code>提供表ADT的一种可增长数组实现。<code>list</code>则提供表ADT的双向链表实现。关于<code>vector</code>和<code>list</code>以及它们所包含的成员函数这里就不再介绍，在STL那几篇博客中都已经列出。当然我们也可以不用标准模板库中的<code>vector</code>和<code>list</code>，自己去写一个新的<code>vector</code>和<code>list</code>来实现上述的种种操作。根据不同的需求有不同的选择。<br>在下篇中将会讲另外两种数据结构栈ADT、队列ADT，它们的一部分知识也在STL中有过介绍，因此很多地方就不再详细说明。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法分析相关概念</title>
    <url>/2020/02/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>摘要：本篇将介绍一下在分析算法时所用到的一些知识。例如如何判断一个算法的好坏？怎么去计算算法的时间复杂度等等。通过本篇的介绍，能够更好的让我们对一个算法进行分析。</p>
<a id="more"></a>
<p>算法（algorithm)是为求解一个问题需要遵循的、被清楚的指定的简单指令的集合。对于一个问题，一旦某种算法给定并且被确定是正确的，那么重要的一步就是确定该算法将需要多少诸如时间或空间等的资源量的问题。一个程序的运行时间，依赖于算法的好坏和问题的输入规模。同一个问题的不同解决方法会花费的时间，内存各不相同。即使计算机在不停进步，有些算法依然需要花费大量时间，因此需要找到最优效率的算法。因此，一个算法的好坏或者性能由它的时间复杂度和空间复杂度决定。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的公式为S(n)，n为问题的规模。通常的复杂度指的都是时间复杂度。因此这里不再对空间复杂度过多解释，只简单说一下，在以后遇到时会具体介绍。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>算法的时间复杂度的分析就是针对每个输入规模值，计算基本运算的执行次数。某些情况下，基本运算的执行次数不仅取决于输入规模，还与输入值有关。简而言之，就是一个算法要花多长时间执行。即一个算法所有指令被执行的次数为T(n)。最佳情况时间复杂度称为B(n)，最差情况时间复杂度称为W(n)，平均情况时间复杂度为A(n), 对于一般的排序，讨论平均情况下的时间复杂度即可，但是对于电厂检测这种，就必须要考虑最差情况时间复杂度，因为出了差错是灾难性的。具体问题具体分析讨论哪种情况的时间复杂度。一般情况下，一个算法必须是O(nlogn)或者更佳时，我们才能假定它可以在可容忍时间内处理极大实例。一般在没有特殊说明的情况下，都是指最坏时间复杂度。<br>时间复杂度常用大O符号表示，T(n)是一个具体的函数，而大O表示则相当于时间复杂度的分级，常见的为:<br>O(1)、O(logn)、O(n)、O(nlogn)、O(n^2)、O(n^3)、O(2^n)、O(n!)<br>为什么要分这几类呢？，举个例子，对于时间复杂度为n和n^2的两种算法，显然当n足够大时，第一种的效率总是高于第二种。那么100n和0.01n^2呢？若只比较一些数，如100以内的，第一种花费的时间大于第二种，但只要n&gt;10000,第一种还是效率高于第二种，只是需要n的值更大了而已。所以我们需要比较的是它们的相对增长率。因此看最终结果，引入了阶的概念。低阶的效率最终都是高于高阶的。我们只需要按阶次划分时间复杂度即可，不再考虑系数，以T(n)的最高阶作为O(n)。<br>如何计算时间复杂度？分析算法的复杂度，关键是分析循环结构的运行情况。</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>一个for循环的运行时间至多是该for循环内部那些语句（包括测试）的运行时间乘以迭代的次数。例如：</p>
<pre><code>for(int i=0;i&lt;n;i++)
{
    cout&lt;&lt;i;
}</code></pre><p>可以看到，输出语句执行了n次，还有一次判断语句(i=n)，总共执行了n+1次，复杂度为O(n)。</p>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>从里向外分析这些循环，在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有的for循环的大小的乘积。 </p>
<pre><code>for(int i=0;i&lt;n;i++)
{
    for(int j=o;j&lt;n;j++)
    {
        cout&lt;&lt;i;
    }
}</code></pre><p>可以看到有两个for循环，复杂度为O(n^2)。</p>
<h3 id="顺序语句"><a href="#顺序语句" class="headerlink" title="顺序语句"></a>顺序语句</h3><p>将各个语句的运行时间求和即可。如将上面两个循环合并：</p>
<pre><code>for(int i=0;i&lt;n;i++)
{
    cout&lt;&lt;i;
}
for(int i=0;i&lt;n;i++)
{
    for(int j=o;j&lt;n;j++)
    {
        cout&lt;&lt;i;
    }
}</code></pre><p>因为取的是最高阶次，T(n)=n^2+n，复杂度仍为O(n^2)。</p>
<h3 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if/else语句"></a>if/else语句</h3><p>对于if/else语句：</p>
<pre><code>if(condition)
    s1
else
    s2</code></pre><p>运行时间从不超过判断的运行时间再加上s1和s2中运行时间长者的总的运行时间。<br>对于其他情形的分析也是看执行次数，如递归等等。分析一个算法的时间复杂度是非常重要的，它能体现算法的性能。在后续对算法的学习当中，复杂度是必不可少的。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法初识</title>
    <url>/2020/02/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<p>摘要:从本篇开始将进入到数据结构与算法的学习。前面已经讲解了C++的相关知识，使我们有了编写程序解决问题的能力。然而面对同一个问题，可能有很多种的解决方法，每种方法的效率也不相同。学会了数据结构与算法，才能使我们的程序更加健壮，更加具有效率。本篇将会对数据结构与算法进行一下简单介绍。</p>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。在计算机科学的发展过程中，数据结构也随之发展。程序设计中常用的数据结构包括如下几个：<br>数组(Array)、栈( Stack)、队列(Queue)、链表(List)、树(Tree)、图(Graph)、堆(Heap)、散列表(Hash)。<br>后续的学习中会对这些数据结构一一介绍。 </p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法是用来操作数据结构的。举个例子，设有一组N个数而要确定其中的第k个最大者，这种问题为选择问题。我们编写一个程序来解决这个问题是很简单的。其中一个解法是将这N个数读进一个数组中，再通过某种简单的算法，比如冒泡排序法，以递减顺序将数组排序，然后返回位置k上的元素。<br>稍微好一点的算法可以先把前k个元素读入数组并(以递减的顺序)对其排序。然后，剩下的元素再逐个读入。当新元素被读到时，如果它小于数组中的第k个元素则忽略之，否则就将其放到数组中的正确位置上，同时将原数组中的最后一个元素挤出数组。当算法终止时，位十第k个位置上的元素作为答案返回。<br>那么哪个算法更好？两个算法都足够好吗？使用3000万个元素的随机文件和k=15000000进行模拟指出，两个算法在合理的时间量内均不能结束计算;每种算法都需要计算机处理若干天才能算完(不过最终还是给出了正确的答案)。在后面会讨论另一种算法，该算法将在1秒种左右给出问题的解。因此，虽然我们提出的两个算法都能算出结果，但是它们不能看作是好的算法，因为对于第三种算法能够在合理的时间内处理的输入数据量而言，这两种算法是完全不切实际的。<br>同一个问题的不同解决方法会花费的时间，内存各不相同。即使计算机在不停进步，有些算法依然需要花费大量时间，因此需要找到最优效率的算法。</p>
<h3 id="递归和迭代算法"><a href="#递归和迭代算法" class="headerlink" title="递归和迭代算法"></a>递归和迭代算法</h3><p>为了不使本篇全部都是概念理论上的内容，在这里我要讲一下递归和迭代算法。递归算法是非常有用的算法，在后续的学习中，它会被非常频繁的使用。递归算法在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。一个用其自身来定义的函数就称为递归的。递归的基本法则为：<br>1.基准情形。必须要有某些基准的情形，它们不用递归就能求解。<br>2.要有进展。对于那些要被递归求解的情形，递归调用必须总能够朝着一个基准情形进展。<br>3.设计法则。假设所有的递归调用都能运行。<br>4.合成效益法则。在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。<br>举个例子，斐波那契数列，它的第n项等于第n-1和第n-2项的和。递归算法如下：  </p>
<pre><code>int q(int n)
{
    if(n==1)
    {
    return 1;
    }
    if(n==2)
    {
    return 1;
    }
    else
    {
    return (q(n-1)+q(n-2));
    }
}
int main()
{
    int n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;n+1;i++)
    cout&lt;&lt;q(i)&lt;&lt;&quot; &quot;;
    return 0;
}</code></pre><p>从代码中可以看到，基准情形就是n=1和n=2的情况，发展情形就是在n&gt;2时，会调用它的前两项，最终调用到基准情形。在函数当中调用了它本身。假设n=4，它会返回q(3)+q(2)的值，当运行到q(3)时，会调用函数自身，返回q(2)+q(1)的值，然后q(2)、q(1)又调用函数，返回1，最终求得q(3)为2，这时再去求解q(2)，最终q(4)为3。<br><strong>递归是重复调用函数本身，而迭代则是重复函数的一部分</strong>。上述斐波那契数列同样可以用迭代算法来写，如下：  </p>
<pre><code>int fib(int n)
{
    int i;
    vector&lt;int&gt; v(n);
    v[0]=0;
    v[1]=1;
    v[2]=1;
    i=3;
    while(i&lt;=n)
    {
        v[i]=v[i-1]+v[i-2];
        i++;
    }
    return v[n];    
}
int main()
{
    int n;
    cin&gt;&gt;n;
        cout&lt;&lt;fib(n);
    return 0;
}</code></pre><p>将斐波那契数列存放在数组中，通过while循环来迭代求解。一般情况下，迭代的执行速度比递归快。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>预处理器和多线程</title>
    <url>/2020/02/22/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>摘要：本篇将主要介绍C++中的预处理器和多线程。在预处理器里将讲解一些常用的预处理指令，而多线程也涉及到操作系统方面的知识，在这里只是简单介绍，后面会有更深入的学习。</p>
<a id="more"></a>
<p>前面已经写过很多的实例，虽然它们的作用各不相同，但它们都包含了同一句代码<code>#include&lt;iostream&gt;</code>，这个宏用于把头文件包含到源文件中。在这里就要讲一下这些以井号开头的指令。</p>
<h2 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h2><p>预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。所有的预处理器都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是C++语句，所以它们不会以分号（;）结尾。<br><code>#define</code>预处理指令用于创建符号常量，该符号常量通常称为宏，示例如下：  </p>
<pre><code>#define PI 3.14</code></pre><p>这样，在后面出现的所有PI都会被定义为3.14。也可以定义一个带有参数的宏，如：  </p>
<pre><code>#define min(a,b)(a&lt;b?a:b)</code></pre><p>有些指令可以用来有选择地对部分程序源代码进行编译，这个过程被称为条件编译。示例为：  </p>
<pre><code>#ifdef DEBUG 
cerr &lt;&lt; x &lt;&lt; endl; 
#endif</code></pre><p>如果在指令 <code>#ifdef DEBUG</code>之前已经定义了符号常量 <code>DEBUG</code>，则会对程序中的<code>cerr</code>语句进行编译。<code>#if</code>则表示非零时编译，为零时则不编译，相当于注释。  </p>
<pre><code>#if 0
cout&lt;&lt;a&lt;&lt;endl;
#endif  </code></pre><p>在C++程序中，把类接口与其实现分开是更为常见的。接口列出类和它的成员，而实现则提供函数的实现。接口放在以.h结尾的头文件中。需要接口知识的源代码必须要#include这个接口文件。为了防止一个接口被读两次。需要用到预处理指令。如下所示：  </p>
<pre><code>#ifndef IntCell_H
#define IntCell_H
...
...
#endif</code></pre><p>第一个指令判断是否定义过该文件，如果没有，定义并执行，如果已经定义过了，跳过转到endif。<br>C++中也定义了预定义宏，如下表所示：<br><img src="https://i.loli.net/2020/02/22/m9zS5rZtf8JIwXn.png" alt=""><br>最后以一个实例包含上述代码：  </p>
<pre><code>#define PI 3.14159
#define min(a,b)(a&lt;b?a:b)
int main ()
{
    int a,b;
    a=1;
    b=2;
    cout &lt;&lt; &quot;Value of PI :&quot; &lt;&lt; PI &lt;&lt; endl; 
    cout&lt;&lt;min(a,b)&lt;&lt;endl;    

#ifdef PI
    cout&lt;&lt;PI&lt;&lt;endl;
#endif

#if 0
    cout&lt;&lt;a&lt;&lt;endl;
#endif

     cout &lt;&lt; &quot;Value of __LINE__ : &quot; &lt;&lt; __LINE__ &lt;&lt; endl;
        cout &lt;&lt; &quot;Value of __FILE__ : &quot; &lt;&lt; __FILE__ &lt;&lt; endl;
       cout &lt;&lt; &quot;Value of __DATE__ : &quot; &lt;&lt; __DATE__ &lt;&lt; endl;
        cout &lt;&lt; &quot;Value of __TIME__ : &quot; &lt;&lt; __TIME__ &lt;&lt; endl;
        return 0;
} </code></pre><p>运行结果为：<br><img src="https://i.loli.net/2020/02/22/u8CkjlJyAvWT97Z.png" alt="">  </p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>说到多线程编程，那么就不得不提并行和并发，多线程是实现并发（并行）的一种手段。并行是指两个或多个独立的操作同时进行。注意这里是同时进行，区别于并发，在一个时间段内执行多个操作。在单核时代，多个线程是并发的，在一个时间段内轮流执行；在多核时代，多个线程可以实现真正的并行，在多核上真正独立的并行执行。例如现在常见的4核4线程可以并行4个线程；4核8线程则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。<br>通常，要实现并发有两种方法：多进程和多线程。使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统对进程提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比多线程更容易写出安全的代码。但这也造就了多进程并发的两个缺点：<br>1.在进程件的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼而有之。<br>2.运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。<br>由于多个进程并发完成同一个任务时，不可避免的是：操作同一个数据和进程间的相互通信，上述的两个缺点也就决定了多进程的并发不是一个好的选择。<br>多线程并发指的是在同一个进程中执行多个线程。有操作系统相关知识的应该知道，线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一进程内的多个线程能够很方便的进行数据共享以及通信，也就比进程更适用于并发操作。由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁(deadlock)。<br>C++ 11的标准库中提供了多线程库，使用时需要<code>&lt;thread&gt;</code>头文件，该头文件主要包含了对线程的管理类<code>thread</code>以及其他管理线程相关的类。示例如下：  </p>
<pre><code>void print(int i)
{
    cout&lt;&lt;i&lt;&lt;endl;
}
int main()
{
    for(int i=0;i&lt;4;i++)
    {
        thread t(print,i);
        t.detach();
    }
    getchar();
    return 0;
}</code></pre><p>在一个for循环内，创建4个线程分别输出数字0、1、2、3，并且在每个数字的末尾输出换行符。语句<code>thread t(print, i)</code>创建一个线程<code>t</code>，该线程运行<code>print</code>函数，第二个参数<code>i</code>是传递给<code>print</code>的参数。<code>t</code>在创建完成后自动启动，<code>t.detach</code>表示该线程在后台允许，无需等待该线程完成，继续执行后面的语句。这段代码的功能是很简单的，如果是顺序执行的话，其结果很容易预测得到为0、1、2、3且每个数字都是单独一行。然后实际运行情况却不是这样，每次可能都不一样，其中一次为：<br><img src="https://i.loli.net/2020/02/22/RAcU94vnlKuqPSp.png" alt=""><br>可以看出，首先输出了0和换行符；紧接着却连续输出了213。不是说好的并行么，同时执行，怎么还有先后的顺序？这就涉及到多线程编程最核心的问题了资源竞争。CPU有4核，可以同时执行4个线程这是没有问题了，但是控制台却只有一个，同时只能有一个线程拥有这个唯一的控制台，将数字输出。将上面代码创建的四个线程进行编号：t0,t1,t2,t3，分别输出的数字：0,1,2,3。参照上图的执行结果，控制台的拥有权的转移如下：<br>t0拥有控制台，输出了数字0和换行符，t0线程完成，控制的拥有权转移到了t2；(0\n)<br>t2输出了数字2，但是其没有来的及输出换行符，控制的拥有权却转移到了t3（2）<br>t1输出了数字1，但是其没有来的及输出换行符，控制的拥有权却转移到了t2 （1）<br>t3输出了数字3，但是其没有来的及输出换行符，控制的拥有权却转移到了t1 （3)<br>最后它们再把换行符输出。<br>由于控制台是系统资源，这里控制台拥有权的管理是操作系统完成的。但是，假如是多个线程共享进程空间的数据，这就需要自己写代码控制，每个线程何时能够拥有共享数据进行操作。共享数据的管理以及线程间的通信，是多线程编程的两大核心。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>强制类型转换和异常处理</title>
    <url>/2020/02/20/%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>摘要：本篇要讲解的内容是强制类型转换和异常处理。在程序运行过程中会出现很多问题，有些特殊情况被称为异常，我们需要捕捉到异常并处理。在前面C语言中已经讲过强制类型转换，在本篇中将更进一步讲解C++中的各种强制类型转换。</p>
<a id="more"></a>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>在C++中的强制类型转换有四种，分别是：<code>static_cast</code>， <code>reinterpret_cast</code>， <code>const_cast</code>，  <code>dynamic_cast</code>。下面将对这四种分别进行讲解。  </p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>前面在C语言的强制类型转换中讲过，转换是有风险的，而C语言的强制类型转换无法反映风险。在C++中，<code>static_cast</code>用来进行比较“自然”和低风险的转换，比如整型和实数型、字符型之间互相转换。它不能在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，也不能用于不同类型的引用之间的转换。例如：  </p>
<pre><code>int n;
char *p=&quot;hello&quot;;
n=static_cast&lt;int&gt;(3.14);  //n的值变为3
n=static_cast&lt;int&gt;(p);     //编译错误，static_cast不能将指针转换成整型</code></pre><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p><code>reinterpret_cast</code>用于进行各种不同类型的指针之间的转换、不同类型引用之间转换、以及指针和能容纳下指针的整数类型之间的转换。转换的时候，执行的是逐个比特拷贝的操作。举例如下：  </p>
<pre><code>class A
{
    public:
        int i;
        int j;
        A(int n):i(n),j(n){}
};
int main()
{
    A a(100);
    int &amp;r=reinterpret_cast&lt;int&amp;&gt;(a);  //强行让r引用a
    r=200;                      //把a.i变成了200
    cout&lt;&lt;a.i&lt;&lt;&quot;,&quot;&lt;&lt;a.j&lt;&lt;endl;  //输出200，100
    return 0;
}</code></pre><p>在内存里面按顺序存放了i和j，这是强制让r引用a，r就只指向了i，令r等于200，相当于修改了i，j没有改变。</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>用来进行去除<code>const</code>属性的转换。将<code>const</code>引用转换成同类型的非<code>const</code>引用，将<code>const</code>指针转换为同类型的非<code>const</code>指针。示例如下：  </p>
<pre><code>const string s=&quot;Inception&quot;;         //本来只能赋给一个const的引用
string &amp;p=const_cast&lt;string &amp;&gt;(s); //去除const属性，且能通过p修改s
string *ps=const_cast&lt;string*&gt;(&amp;s);  </code></pre><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p><code>dynamic_cast</code>专门用于将多态基类的指针或引用，强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回NULL指针。<code>dynamic_cast</code>不能用于将非多态基类的指针或引用，强制转换为派生类的指针或引用（包含虚函数的基类是多态基类）。  </p>
<pre><code>Base *pb=&amp; d;
pd=dynamic_cast&lt;Derived*&gt;(pb);
if(pd==NULL)
{
    cout&lt;&lt;&quot;unsafe dynamic_cast&quot;&lt;&lt;endl;
}</code></pre><p>引用的强制转换不会为空，那该如何判断转换是否安全呢？不安全会抛出异常，因此需要进行异常处理。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>程序运行中难免发生错误，引起这些异常情况的原因很多，我们希望能够发现异常。需要一种手段，把异常与函数的接口分开，并且能够区分不同的异常。在函数体外捕获所发生的异常，并提供更多的异常信息。C++异常处理的3个关键字为：<code>try</code>、<code>catch</code>、<code>throw</code>。<br><code>throw</code>: 当问题出现时，程序会抛出一个异常。这是通过使用<code>throw</code>关键字来完成的。<br><code>catch</code>: 在您想要处理问题的地方，通过异常处理程序捕获异常。<code>catch</code>关键字用于捕获异常。<br><code>try</code>: <code>try</code>块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个<code>catch</code>块。<br>先在<code>try</code>块进行判断，是否抛出了异常，没有抛出，跳过<code>catch</code>块继续进行，抛出后直接转到<code>catch</code>块，<code>try</code>块不再运行。并且<code>catch</code>块以从上到下的顺序查找，只执行一次。<br>示例代码为：  </p>
<pre><code>int divide(int a,int b)
{
    if(b==0)
    {
        throw 1;
    }
    else if(a==0)
    {
        throw 1.5;
    }
    else
        return a/b;
 } 
 int main()
 {
     int m,n,p;
     for(int i=0;i&lt;3;i++)
     {
         cin&gt;&gt;m&gt;&gt;n;
         try{
             p=divide(m,n);
             cout&lt;&lt;p&lt;&lt;endl;
            cout&lt;&lt;&quot;正常运行&quot;&lt;&lt;endl;
         }
         catch(int j)
        {
            cout&lt;&lt;&quot;被除数为零&quot;&lt;&lt;endl;     
        }
        catch(double j)
        {
            cout&lt;&lt;&quot;除数为零&quot;&lt;&lt;endl;     
        }
    }
     return 0;
 }</code></pre><p>从代码中可以看到，定义了一个函数用于两个数相除，设置了两种异常情况，一种是除数为零，一种是被除数为零，当被除数为零时，抛出异常，抛出的是整型异常 1。当除数为零时，抛出异常，抛出的是double型异常 1.5。在主函数里去捕获异常，若捕获到整型异常，输出<code>被除数为零</code>。若捕获到double型异常，输出<code>除数为零</code>。运行结果如下：<br><img src="https://i.loli.net/2020/02/20/W8pFhzYoyvGOLXT.png" alt=""><br>从结果中可以看到，当除数和被除数都不为零时，正常运行，跳过<code>catch</code>块，而当发生异常时，由<code>try</code>块直接跳到了<code>catch</code>块。<br>如果异常只是抛出没有被处理，就会被抛给上一层的函数（异常再抛出）。在C++中也定义了标准异常类，C++标准库中有一些类代表异常，这些类都是从<code>exception</code>类派生而来。在这里就不再具体介绍，需要的可以自行了解。  </p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>C++11新特性2</title>
    <url>/2020/02/18/C++11%E6%96%B0%E7%89%B9%E6%80%A72/</url>
    <content><![CDATA[<p>摘要：本篇将继续对C++ 11的新特性进行讲解。主要内容有lambda表达式、右值引用和move语义，在讲解右值引用时也会对常见的左值引用、参数传递等方法做个总结。</p>
<a id="more"></a>
<p>C++ 11中还有许多的特性，在这里我将选择其中几个再讲解。</p>
<h2 id="右值引用和move语义"><a href="#右值引用和move语义" class="headerlink" title="右值引用和move语义"></a>右值引用和move语义</h2><p>前面已经讲过引用的概念，即相当于给对象一个别名。这里出现左值和右值。左值相当于一个标识非临时性对象的表达式。右值则是标识临时性对象的表达式，或者是一个不与任何对象相联系的值（如字面值常数1，2，3等）。举例如下：  </p>
<pre><code>vector&lt;string&gt; arr(3); 
const int x=2; 
int y;   
int z=x+y;  
string str=&quot;foo&quot;;  
vector&lt;string&gt; *ptr=&amp;arr;</code></pre><p>其中<code>arr</code>,<code>str</code>,<code>y</code>,<code>z</code>,<code>ptr</code>,<code>*ptr</code>都是左值，<code>x</code>也是左值，不过它是一个不可修改的左值。<strong>一般的法则是，如果程序中有一个变量名，那么它就是一个左值，而不管变量是否可修改</strong>。<br>其中<code>2</code>，<code>x+y</code>，<code>&quot;foo&quot;</code>, <code>str.sub(0,1)</code>都是右值，可以看到它们均为字面值，而不是变量名，<code>x+y</code>是一个右值，因为它的值是临时的，但是在被赋给<code>z</code>之前，它要被存放在某个地方。<strong>如果函数调用计算一个其值在调用前不存在并且一旦调用终止就不再存在的表达式，那么它很可能是一个右值，除非它在别处被复制</strong>。<br>在C++ 11中，左值引用是通过在某个类型后放置一个符号<code>&amp;</code>而被声明的，此时一个左值引用变成了它所引用对象的同义词（别名），如：</p>
<pre><code>string  str=&quot;hell&quot;;  
string &amp;rstr=str;</code></pre><p><code>rstr</code>是<code>str</code>的另一个名字，此时它们表示的是同一对象，<code>rstr==str</code>。<br>右值引用是通过在某个类型后放置一个符号<code>&amp;&amp;</code>而被声明的。右值引用与左值引用具有相同的特征，但右值引用也可以引用一个右值（即一个临时量），如：</p>
<pre><code>string  str=&quot;hello&quot;;  
string &amp;&amp;bad1=&quot;hello&quot;; 
string &amp;&amp;bad2=str+&quot; &quot;;
string &amp;&amp;sub=str.substr(0,4);</code></pre><p>在介绍了什么是左值引用和右值引用后，再来说一下它们的用途。左值引用用途：<br>1.给结构复杂的名称起别名，减少书写麻烦。<br>2.范围for循环。<br>若让一个vector对象的所有值都加1，for循环如下：  </p>
<pre><code>for(int i=0;i&lt;arr.size();++i)
{  
    ++arr[i];
}</code></pre><p>使用范围for循环更方便，但直接写是不行的，因为这样x是每一个值的拷贝，而不是本身：  </p>
<pre><code>for( auto x : arr)
{
    ++x;
}</code></pre><p>这时就需要用到引用，引用的范围for循环如下：<br>    for( auto &amp;x : arr)<br>    {<br>        ++x;<br>    }<br>3.避免赋值<br>这是最重要的一点，当我们用引用时，传递的不再是一个复制品，而是本体。<br>许多语言，包括C和Java，都是用传值调用传递所有参数的：把实参复制到形参。但是，C++中的参数可能是些大的复杂的对象，这些对象复制起来效率很低，而且有时候我们也希望能够改变传递过来的值。于是有了C++中的3种参数传递机制，而C++ 11又添加了第四种：传右值引用。首先讲讲前3种参数传递机制，示例如下：  </p>
<pre><code>double average(double a,double b);  
void swap(double a,double b);
string randomItem(vector&lt;string&gt; arr);//返回arr中的一个随机项</code></pre><p> 第一个可以用传值调用，比如求<code>x</code>和<code>y</code>的平均值，只需要<code>x</code>复制给<code>a</code>，<code>y</code>复制给<code>b</code>，返回平均值即可。<code>x</code>和<code>y</code>不需要改变。<br>但在第二个就不能用传值调用，而需要传引用。因为若传值调用，传的是<code>x</code>和<code>y</code>的复制，不论怎么样<code>x</code>，<code>y</code>都不会改变。<strong>我们希望的是通过函数交换<code>x</code>和<code>y</code>，而不是交换它们的复制品</strong>。<br>第三个只是想要查找而不改变，因此是传常量引用。<br>传值、传引用、传常量引用是C++的3种参数传递机制（这里都指的左值），它们有各自的用途，接下来说C++ 11添加的第四种，传右值引用。<br>传右值引用的核心概念在于右值中存储的是要销毁的临时量，像<code>x=rval</code>这样的表达式（<code>rval</code>是一个右值）可以通过移动（<code>move</code>）而不是复制来实现。移动一个对象的状态常常比复制它要容易的多。<br>在C++ 11中，如果赋值运算符的右边（或构造函数）是一个右值，那么当对象支持移动操作时我们能够自动的避免复制。vector是支持移动操作的。<br>但是很多情况下我们所见到的都是左值，那么应该怎么移动呢？这里需要讲一个函数<code>std::move</code>，<strong>它能将任何左值转换成右值。它是不移动数据的，只是使一个值易于移动</strong>。这样，我们可以重新编写交换函数，以右值引用的方式移动交换，如下：  </p>
<pre><code>void swap(vector&lt;string&gt; &amp;x,vector&lt;string&gt; &amp;x)
{
    vector&lt;string&gt; tmp=std::move( x );
    x=std::move( y );
    y=std::move( tmp );
}</code></pre><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>前面已经讲过STL里<code>sort()</code>算法的定义如下：  </p>
<pre><code>template&lt;class Ranlt,class Pred&gt;
void sort(Ranlt first,Ranlt last,Pred pr);</code></pre><p>默认按升序排列，判断x是否应该比y靠前，就看pr(x,y)是否为true。假如我们要让容器中元素按从小到大排列，就要修改<code>pr()</code>函数的定义。可以看出还是比较麻烦的，那么有没有什么简单的办法来实现自定义比较呢？<br>C++ 11新特性中添加了lambda表达式，它本质上是一个函数，但是使我们可以不再去定义类和传统的函数那样麻烦，使得变的简化。lambda表达式的定义如下：  </p>
<pre><code>[外部变量访问方式说明符]（参数表）-&gt;返回值类型{ 语句组}</code></pre><p>外部变量访问方式说明符表示了不同的含义：<br>[=] 以传值的形式使用所有外部变量<br>[&amp;] 以引用形式使用所有外部变量<br>[x,&amp;y] x以传值形式使用，y以引用形式使用<br>[=,&amp;x,&amp;y] x，y以引用形式，其他以传值形式使用<br>[&amp;,x,y] x，y以传值形式，其他以引用形式使用<br><code>-&gt;返回值类型</code> 也可以没有，没有则编译器自动判断返回值类型。举个例子：  </p>
<pre><code>auto ff=[=,&amp;y,&amp;z](int n){
cout&lt;&lt;x&lt;&lt;endl; y++;z++;return n*n;};</code></pre><p>x以传值形式，y,z以引用形式，如果输出ff(15)，则结果为225，且y，z都加1。接下来说一下它的应用，以上面的<code>sort()</code>函数为例，若想要实现数组元素按个位数从小到大排列，该怎么定义？代码如下：  </p>
<pre><code>int main()
{
    auto m=[](double a,double b){return a+b;};
    cout&lt;&lt;m(1.2,2.5)&lt;&lt;endl;
    int a[4]{11,2,24,33};
    sort(a,a+4);
    for(int i=0;i&lt;4;i++)
    {
        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    sort(a,a+4,[](int x,int y)-&gt;bool{return x%10&lt;y%10;});
    for_each(a,a+4,[](int x){cout&lt;&lt;x&lt;&lt;&quot; &quot;;});
    return 0;
}</code></pre><p>可以看到代码中共定义了3个lambda表达式，第一个是将两个变量相加。然后定义了一个数组<code>a[4]</code>，其中元素为11，2，24，33，然后调用<code>sort()</code>函数默认从小到大排序再输出，结果应该为2，11，24，33。接下来使用lambda表达式，使排序规则变为比较个位数的大小。可以看到返回值类型为布尔型，若x的个位数比y的个位数小则返回true。当排完序以后用<code>for_each()</code>函数操作输出，本身<code>for_each()</code>函数是不输出数据的，但我们定义lambda表达式，将其数据输出。最后运行结果为：<br><img src="https://i.loli.net/2020/02/18/u8cf5729DLpxM4T.png" alt=""><br>上面虽然只是简单的运用了lambda表达式，但是还是可以感觉到它比传统的再去定义类和函数要方便许多，lambda表达式也不仅限于在这些特定的算法中使用，因此它是非常好用的一个新特性。<br>到此就简单的介绍完了C++ 11的新特性，虽然只介绍了其中的一小部分，但可以看到C++ 11的变化还是很大的，它使得C++更加的全面，也提高了效率，正是不断的对C++进行更新，才使得C++经久不衰。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 11新特性1</title>
    <url>/2020/02/15/C++11%E6%96%B0%E7%89%B9%E6%80%A71/</url>
    <content><![CDATA[<p>摘要：本篇将介绍C++ 11的新特性。这里的11指的是一个版号。C++是在不断更新的，使得程序更加稳定安全，功能也更加强大。因为要介绍的新特性有许多，所以将会分为两篇介绍，本篇将主要介绍统一初始化、auto关键字、decltype关键字、智能指针和空指针等。其他部分将会在下一篇中进行讲解。</p>
<a id="more"></a>
<p>1998年是C++标准委员会成立的第一年，以后每五年视实际需要更新一次标准，它开发于1998年并于2003年更新，统称为C++ 98或者C++ 03，国际标准化组织于2011年9月1号出版发布ISO/IEC 14882:2011，称为C++ 11。相比于C++98/03，C++ 11则带来了数量可观的变化，其中包含了约140个新特性，以及对C++03标准中约600个缺陷的修正，这使得C++ 11更像是从C++ 98/03中孕育出的一种新语言。相比较而言，C++ 11能更好地用于系统开发和库开发、语法更加泛华和简单化、更加稳定和安全，不仅功能更强大，而且能提升程序员的开发效率。   </p>
<h2 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h2><p>初始化是程序必不可少的，不管是一个简单的数组，还是一个对象，我们都需要对其建立时进行初始化。而在以前的定义中，若要定义一个动态数组v，其中的元素为1 2 3 4 5，定义如下：  </p>
<pre><code>vector&lt;int&gt; v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
v.push_back(4);
v.push_back(4);</code></pre><p>可以看到是很麻烦的，而在C++ 11中，我们可以像初始化普通数组一样去初始化自定义类型，用<code>{}</code>进行初始化，如：</p>
<pre><code>vector&lt;int&gt; v{1,2,3,4,5};
int arr[3]{1,2,3};
string s{&quot;hello&quot;};
int *p=new int[20]{1,2,3};</code></pre><p>即使在类里面也可以省略构造函数，对成员变量默认初始值：  </p>
<pre><code>class B
{
    public:
        int m=20;
        int n;
};</code></pre><p>对类的对象实例进行初始化：</p>
<pre><code>A obj1;
A obj2{5};
A obj3{};</code></pre><p>当中A是一个类，设其有多个构造函数，则obj1和obj3调用的就是无参构造函数，obj2调用的是单参数构造函数。以前我们也用圆括号来定义，如<code>A obj(2)</code>虽然这样也可以，但是括号里必须有参数，不然就变成了函数对象。<strong>所以统一的初始化解决了这种混乱现象</strong>。用统一的初始化方法使得语法更加简单，提高了效率，非常的实用。</p>
<h2 id="auto和decltype关键字"><a href="#auto和decltype关键字" class="headerlink" title="auto和decltype关键字"></a>auto和decltype关键字</h2><p>在C语言中也有auto关键字，使用auto关键字的变量，称为自动变量，是具有自动存储器的局部变量。而在C++ 11中，它被赋予了新的含义，作为一个新的类型指示符来指示编译器，编译器可以自动判断变量的类型。示例如下：  </p>
<pre><code>auto i=100;         // i是int
auto p= new A();    //p是A*
auto k=34343LL;    //k是long long
map&lt;string,int,greater&lt;string&gt;&gt; mp;
for(auto i=mp.begin;i!=map.end();++i)
cout&lt;&lt;i-&gt;first&lt;&lt;”,”&lt;&lt;i-&gt;second;  </code></pre><p>迭代器i的类型是<code>map&lt;string,int,greater&lt;string&gt;&gt;::iterator</code>，使用auto自动定义类型就可以不用再写这么长的代码来定义了。当然这只是auto的简单用法，它还有更大的作用。</p>
<pre><code>class A
{
};
A operator+(int n,A &amp;a)
{
    return a;
}
template&lt;class T1,class T2&gt;
auto add(T1 x,T2 y)-&gt;decltype(x+y)
{
    return x+y;
 } 
int main()
{ 
    auto d=add(100,0.5);        
    auto k=add(100,A());       
    return 0;
}</code></pre><p>代码中定义了一个类A，然后重载了<code>+</code>运算符，重载为普通函数，使得<code>n+A的对象</code>返回值为A的对象，又定义了一个函数模板，函数为<code>add</code>，使两个T1和T2类型的变量相加，由于并不知道相加后返回值是什么类型，所以使用auto关键字。<code>-&gt;decltype(x+y)</code>表示的也是返回值类型，decltype关键字会在下面介绍。在主函数里使用<code>add</code>函数将100和0.5加起来，显然结果是100.5，所以d应该是double型的变量。然后将100与A对象加起来，由于前面重载了<code>+</code>运算符，所以结果为A的对象，k是A类型。通过这段代码可以看到auto关键字在函数编写上有很大的作用，在很多情况下我们是无法确定返回值类型的，尤其在遇到模板相关时，这时，使用auto关键字就会带来很大的方便。<br>decltype关键字的作用是求表达式的类型。示例如下：  </p>
<pre><code>int i;
double t; 
structA{double x;}; 
const A* a=new A();

decltype(a) x1; //x1是A*类型
decltype(i) x2; //x2是int类型
decltype(a-&gt;X) x3; //x3是double类型</code></pre><p>x2的类型由<code>decltype(i)</code>决定，i是int型，所以x2是int类型，其他同理。</p>
<h2 id="智能指针和空指针"><a href="#智能指针和空指针" class="headerlink" title="智能指针和空指针"></a>智能指针和空指针</h2><p>首先介绍一下空指针，平常定义指针为空时：</p>
<pre><code>int *p=NULL;</code></pre><p>在C++ 11新特性里增加了空指针nullptr，定义时：</p>
<pre><code>int *p=nullptr;</code></pre><p>其实这里的两个指针p是相等的，而空指针的作用是使得更能体现指针的特征。同时空指针可以转换成布尔变量，输出的结果为false。</p>
<pre><code>bool b=nullptr;  //b=false</code></pre><p>智能指针shared_ptr的头文件为<code>&lt;memory&gt;</code>，通过shared_ptr的构造函数，可以让shared_ptr对象托管一个new运算符返回的指针。写法如下：</p>
<pre><code>shared_ptr&lt;T&gt; ptr(new T);</code></pre><p>其中T可以是int，char，类名等各种类型。此后ptr就可以像<code>T*</code>类型的指针一样来使用，即*ptr就是用new动态分配的那个对象，而且不必操心释放内存的事。多个shared_ptr对象可以同时托管一个指针，系统会维护一个托管计数。当无shared_ptr托管该指针时，delete该指针。shared_ptr对象不能托管指向动态分配的数组的指针，否则程序运行会出错。具体示例如下：  </p>
<pre><code>struct A
{
    int n;
    A(int m=0):n(m)
    {
    }
    ~A()
    {
        cout&lt;&lt;n&lt;&lt;&quot;  ~A&quot;&lt;&lt;endl;
    }
 } ;
 int main()
 {
     A* p=new A(2);
     shared_ptr&lt;A&gt; ptr1(p);    //ptr1托管A(2) 
     cout&lt;&lt;ptr1-&gt;n&lt;&lt;endl;
     shared_ptr&lt;A&gt; ptr2(ptr1);  //ptr2也托管A(2)
     cout&lt;&lt;(*ptr2).n&lt;&lt;endl;
     A* p1=new A(3);
     shared_ptr&lt;A&gt; ptr3(p1);   //ptr3托管A(3)
     cout&lt;&lt;ptr3-&gt;n&lt;&lt;endl;
     ptr2.reset();            //ptr2放弃托管A(2)
    if(!ptr2)
    {
        cout&lt;&lt;&quot;ptr2 is null&quot;&lt;&lt;endl;
     } 
    ptr2=ptr3;               //ptr2托管A(3)
    cout&lt;&lt;ptr2-&gt;n&lt;&lt;endl;
    shared_ptr&lt;A&gt; ptr4;
 //    ptr4.reset(p);            // 不增加托管计数，会使得释放2次，出错 
     cout&lt;&lt;&quot;end&quot;&lt;&lt;endl;
     return 0;
 }</code></pre><p>定义了一个类A，成员变量n，然后构造函数和析构函数。在主函数里定义指针p指向new出的A(2)，然后用智能指针定义ptr1托管p，即ptr1指向A(2)，输出n值验证。然后定义了智能指针ptr2，也托管A(2)，这是A(2)的托管计数为2。又定义了一个指针p1指向A(3)，智能指针ptr3托管A(3)，这是令ptr2放弃托管A(2)，判断一下它为空指针，再令其托管A(3)。这样到最后相当于ptr1托管A(2)，ptr2和ptr3托管A(3)。因此最后结束的时候删除A(2)和A(3)。运行结果为：<br><img src="https://i.loli.net/2020/02/15/Ut9judkxXmWCTYn.png" alt=""><br>智能指针中需要注意一点，可以看到上面代码中的被注释掉的一句<code>ptr4.reset(p);</code>，这句的意思是使ptr4托管p即ptr4指向A(2)，但是编译器却认为这个p与ptr1托管的p是不同的，即不增加托管次数，将它们当作两个指针。所以当结束的时候，A(2)就会被删除2次，因此出错。</p>
<p>在下篇中将会继续对C++ 11新特性进行介绍，比如右值引用、move语义、Lambda表达式等，它们也都有着很大的作用。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>STL算法</title>
    <url>/2020/02/13/STL%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>摘要：本篇将介绍STL的最后一个部分：算法。算法对于程序是非常重要的，在STL中，我们需要用容器来实现需求，而作用在这些容器上的算法则必须要求了解才行。本篇博客会介绍STL中算法的种类以及它们的功能。</p>
<a id="more"></a>
<p>STL算法就是一个个函数模板，它们大多数在头文件<code>&lt;algorithm&gt;</code>中定义。STL中提供能在各种容器中通用的算法，比如查找、排序等。<br>算法通过迭代器来操纵容器中的元素，许多算法可以对容器中的一个局部区间进行操作，因此需要两个参数，一个是起始元素的迭代器，一个是终止元素的后面一个元素的迭代器。比如排序、查找等算法。<br>有些算法是返回一个迭代器，比如<code>find()</code>算法：在容器中查找一个元素，并返回一个指向该元素的迭代器。<br>前面已经说过，算法并不是STL特有的，算法可以处理容器，也可以处理普通数组。  </p>
<h2 id="不变序列算法"><a href="#不变序列算法" class="headerlink" title="不变序列算法"></a>不变序列算法</h2><p>该类算法不会修改算法所作用的容器或对象，适用于顺序容器和关联容器，时间复杂度都是O(n)。<br><code>min</code> :求两个对象中较小的<br><code>max</code> :求两个对象中较大的<br><code>min_element</code> :求区间中的最小值<br><code>max_element</code> :求区间中的最大值<br><code>count</code> :计算区间中等于某值的区间个数<br><code>find</code> :在区间中查找等于某值的元素<br><code>search</code> :在区间中查找另一个区间第一次出现的位置<br><code>equal</code> :判断两区间是否相等<br><code>mismatch</code> :逐个比较两个区间中的元素，返回第一次发生不相等的元素的位置<br>上面只是列举了一部分，在这里选择<code>find()</code>算法简单介绍，因为查找算法是非常常用的。<code>find()</code>算法的定义为：</p>
<pre><code>template&lt;class InIt,class T&gt;
InIt find(InIt first,InIt last,const T&amp; val);</code></pre><p>first和last这两个参数都是容器的迭代器，它们给出了容器中的查找区间起点和终点[first，last）。区间的起点是位于查找范围之中的，而终点不是。find在[first,last）查找等于val的元素。<br>函数返回值是一个迭代器。如果找到，则该迭代器指向被找到的元素。如果找不到，则该迭代器等于last。示例如下：  </p>
<pre><code>p=find(v.begin(),v.end(),3)；  //查找v中等于3的元素的迭代器
if(p!=v.end())
{
    cout&lt;&lt;*p;
}
if(p==v.end())
{
     cout&lt;&lt;”not find”;
}</code></pre><p>在容器v中查找等于3的元素的迭代器，然后赋值给迭代器p，如果查找不到，则把v中最后一个元素的迭代器赋值给p，判断p是否为最后一个元素的迭代器，不是则说明v中有等于3的元素，输出。否则则输出找不到。</p>
<h2 id="变值算法"><a href="#变值算法" class="headerlink" title="变值算法"></a>变值算法</h2><p>此类算法会修改源区间或目标区间元素的值。<strong>值被修改的那个区间，不可以是属于关联容器的</strong>。<br><code>for_each</code> :对区间中的每个元素都做某种操作<br><code>copy</code> :赋值一个区间到别处<br><code>transform</code> :将一个区间的元素变形后拷贝到另一个区间<br><code>fill</code> :用某个值填充区间<br><code>generate</code> :用某个操作的结果填充区间<br><code>replace</code> :将区间中的某个值替换成另一个值<br>这里说一下<code>copy()</code>算法，定义为：</p>
<pre><code>ostream_iterator&lt;int&gt; output(cout,&quot;&quot;);
copy(v.begin(),v.end(),output);</code></pre><p>定义了一个<code>ostream_iterator&lt;int&gt;</code>对象，可以通过cout输出以“”（空格）分割的一个个整数。然后在<code>copy()</code>里调用output，导致v的内容在cout上输出。</p>
<h2 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h2><p>删除算法用于删除一个容器中的某些元素。但是需要说明的是，<strong>删除不会使容器中的元素减少</strong>。将所有应该被删除的元素看成空位子，用留下的元素从后往前移，依次去填空位子，元素往前移后，它原来的位置也是空位子，由后面的元素补上，最后没有被填上的空位子，维持其原来的值不变。删除算法不应作用于关联容器。<br><code>remove</code> :删除区间中等于某个值的元素<br><code>remove_if</code> :删除区间中满足某种条件的元素<br><code>unique</code> :删除区间中连续相等的元素，只留下一个<br><code>unique_copy</code> :拷贝区间到另一个区间，连续相等的元素只拷贝一个<br>算法复杂度都是O(n)。</p>
<h2 id="变序算法"><a href="#变序算法" class="headerlink" title="变序算法"></a>变序算法</h2><p>变序算法改变容器中元素的顺序，但是不改变元素的值。变序算法不适用关联容器，算法复杂度都是O(n)。<br><code>reverse</code> :颠倒区间的前后次序<br><code>reverse_copy</code> :把一个区间颠倒后的结果拷贝到另一个区间，源区间不变<br><code>ratate</code> :将区间进行循环左移<br><code>random_shuffle</code> :随机打乱区间中的元素<br><code>next_permumation</code> :对区间中的元素进行全排列<br>这里说明一个<code>random_shuffle</code>算法，定义为：</p>
<pre><code>template&lt;class Ranlt&gt;
void random_shuffle(Ranlt first,Ranlt last);</code></pre><p>随机打乱[first,last)中的元素，适用于能随机访问的容器。</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><p>比上面的变序算法复杂度更高，一般是O(nlong(n))。排序算法需要随机访问迭代器的支持，不适用关联容器和<code>list</code>。<br><code>sort</code> :将区间从小到大排列<br><code>stable_sort</code> :将区间从小到大排列，并保持相等元素间的相对次序<br><code>partial_sort</code> :对区间部分排序，直到最小的n个元素就位<br><code>partial_sort_copy</code> :将区间前n个元素的排序结果拷贝到别处<br><code>nth_element</code> :对区间部分排序，使得第n小的元素就位，而且比它小的都在它前面，比它大的都在它后面<br>显然<code>sort()</code>算法是最常用的，若定义为：</p>
<pre><code>template&lt;class Ranlt&gt;
void sort(Ranlt first,Ranlt last);</code></pre><p>表示的是按升序排列，判断x是否应该比y靠前，就看<code>x&lt;y</code>是否为true。若定义为：  </p>
<pre><code>template&lt;class Ranlt,class Pred&gt;
void sort(Ranlt first,Ranlt last,Pred pr);</code></pre><p>则按升序排列，判断x是否应该比y靠前，就看pr(x,y)是否为true。前面讲容器的时候已经举例过<code>sort()</code>算法，这里就不再过多说明。 </p>
<h2 id="有序区间算法"><a href="#有序区间算法" class="headerlink" title="有序区间算法"></a>有序区间算法</h2><p>要求所操纵的区间是已经从小到大排好序的，需要随机访问迭代器的支持，因此有序区间算法不能用于关联容器和<code>list</code>。<br><code>binary_search</code> :判断区间中是否包含某个元素<br><code>includes</code> :判断是否一个区间中的每个元素，都在另一个区间中<br><code>lower_bound</code> :查找最后一个不小于某值的元素的位置<br><code>upper_bound</code> :查找第一个大于某值的元素的位置<br><code>equal_range</code> :同时获取<code>lower_bound</code>和<code>upper_bound</code><br><code>merge</code> :合并两个有序区间到第三个区间  </p>
<p>本篇大概介绍了STL中常见的一些算法以及它们所适用的容器，算法非常重要，STL中的算法都是已经编写好的函数模板，直接调用即可，但有时很多算法根据需求的不同需要我们自己去写，关于算法后续的学习会在数据结构与算法中再介绍。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>STL之迭代器</title>
    <url>/2020/02/11/STL%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>摘要：上两篇介绍了STL的容器相关的知识，本篇将会讲解迭代器。不同的容器用到不同的迭代器，因此需要了解各种容器的特征以及它们所适用的迭代器的用法。</p>
<a id="more"></a>
<p>迭代器用于指向顺序容器和关联容器中的元素，它的用法和指针类似。迭代器有<code>const</code>和非<code>const</code>两种，这两种都能读取它指向的元素，其中非<code>const</code>迭代器还可以修改其指向的元素，这也与指针相似。定义一个容器类的迭代器的方法是：<br><code>容器类名::iterator 变量名;</code> 或 <code>容器类名::const_iterator 变量名;</code><br>例如：<br><code>vector&lt;int&gt;::iterator i;</code>    </p>
<p><code>set&lt;double&gt;::const_iterator j;</code><br>而当访问一个迭代器所指向的元素时，与指针相同， <code>*迭代器变量名</code></p>
<h2 id="随机访问迭代器"><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h2><p>顺序容器中的<code>vector</code>、<code>deque</code>用的迭代器是随机访问迭代器，随机访问迭代器的意思即可以直接访问想要位置的元素。示例如下：  </p>
<pre><code>int main()
{
    vector&lt;int&gt; v;
    vector&lt;int&gt;::const_iterator i;                   //const迭代器 
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    v.push_back(4);
    i=v.begin()+2;
    cout&lt;&lt;*i&lt;&lt;endl;
    for(i=v.begin();i&lt;v.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }  
    vector&lt;int&gt;::iterator j;                     //非const迭代器  修改元素的值 
    for(j=v.begin();j&lt;v.end();j++)
    {
        *j=5;
    }
    for(i=v.begin();i&lt;v.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>从代码中可以看到，定义了一个空的动态数组v，输入数据变成1 2 3 4，还定义了一个指向动态数组的迭代器，因为<code>vector</code>用的是随机访问迭代器，可以直接访问想要位置的元素，所以当想要访问v中第3个元素时，令<code>i=v.begin()+2;cout&lt;&lt;*i&lt;&lt;endl;</code>即可。只有<strong>随机访问迭代器</strong>可以这样，其他的迭代器是不能用<code>+</code>运算符的。若想修改v中元素的值，定义了非const迭代器，使得v中元素全部变成5，再输出，运行结果如下：<br><img src="https://i.loli.net/2020/02/11/oLCZQ3MUJ4adjwh.png" alt=""><br>这里再介绍以下反向迭代器，从名字可知，迭代器的顺序进行了反向，即默认迭代器是从头到尾，而方向迭代器是从尾到头。对上面代码进行添加：  </p>
<pre><code>vector&lt;int&gt;::reverse_iterator r;                //反向迭代器 
for(r=v.rbegin();r!=v.rend();r++)
{
    cout&lt;&lt;*r&lt;&lt;&quot; &quot;;
}</code></pre><p>输出的结果就为4 3 2 1。</p>
<h2 id="双向迭代器"><a href="#双向迭代器" class="headerlink" title="双向迭代器"></a>双向迭代器</h2><p>上面已经说到顺序容器中的<code>vector</code>、<code>deque</code>使用的是随机访问迭代器，而顺序容器中还有一个链表<code>list</code>，它和关联容器都使用的是双向迭代器。双向迭代器便不能直接访问第i个元素，而只能从头到后逐个访问。将上篇中<code>set</code>容器的部分代码拿出来如下：</p>
<pre><code>int a[4]={3,2,1,5};
set&lt;int&gt; st(a,a+4);
set&lt;int&gt;::iterator i;   //双向迭代器
for(i=st.begin();i!=st.end();i++)
{
    cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
}</code></pre><p>虽然定义的形式是相同的，但是这里的迭代器是双向迭代器，在for循环的条件可以看到，是<code>i!=st.end()</code>，这里只能这么定义，而不能用<code>i&lt;st.end()</code>，随机访问迭代器两种形式都可以。</p>
<p>顺序容器和关联容器的迭代器都已经讲了，而容器适配器是不支持迭代器的。同样的，因为容器迭代器的限制，某些算法例如排序（sort）、二分查找（binary_search）需要通过随机访问迭代器来访问容器中的元素，那么<code>list</code>和关联容器就不支持该算法。前面讲<code>list</code>的时候讲过，它有自己定义的排序（sort）算法，就是来解决这个问题的。<br>本篇主要介绍了STL中的迭代器，在下篇将会介绍STL算法，算法是非常复杂的一部分，后面数据结构与算法的学习中还会对算法进行更深入的研究，在这里只简单介绍STL中的部分算法。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>STL之关联容器和容器适配器</title>
    <url>/2020/02/09/STL%E4%B9%8B%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<p>摘要：本篇继续上一篇的学习，将会对STL的容器中的关联容器和容器适配器进行介绍。容器具有非常强大的功能，熟练使用它们能给我们提供很大的方便。</p>
<a id="more"></a>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>上篇中已经介绍过顺序容器，即元素的插入位置同元素的值无关，而是由元素的添加到容器中的次序决定的。而关联容器却跟顺序容器不同，关联容器中，元素是排序的。插入任何元素，都按相应的<strong>排序规则</strong>来确定其位置。在查找时具有非常好的性能，通常以平衡二叉树方式实现，插入和检索的时间都是O（log（N））(折半查找)。关联容器包括<code>set</code>， <code>multiset</code>，<code>map</code>，<code>multimap</code>。<br>关联容器中除了各容器都有的函数外，还支持以下成员函数：<br><img src="https://i.loli.net/2020/02/09/SQMOUGPrt98XAcD.png" alt="">  </p>
<h2 id="set和multiset"><a href="#set和multiset" class="headerlink" title="set和multiset"></a>set和multiset</h2><p><code>set</code>和<code>multiset</code>的头文件都是<code>&lt;set&gt;</code>，表示的意思为集合。它们的区别在于<code>set</code>中不允许有相同元素，而<code>multiset</code>允许有相同元素。所以当在set中插入已有的元素时，忽略插入。示例代码如下：  </p>
<pre><code>int main()
{
    int a[4]={3,2,1,5};
    set&lt;int&gt; st(a,a+4);
    set&lt;int&gt;::iterator i;
    for(i=st.begin();i!=st.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    st.insert(4);
    st.insert(3);
    for(i=st.begin();i!=st.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    return 0;
 } </code></pre><p>定义了一个<code>set</code>对象st，一个数组为3 2 1 5，然后将数组输入到st中，然后将st中的元素输出。由下面的结果可以看到，<code>set</code>会自动对数据进行排序（默认为从小到大），变成了1 2 3 5。然后再插入4和3，将插入后的st输出，结果为1 2 3 4 5.可以看出对插入的数据4进行了排序，而3是已有的元素，忽略插入。<br><img src="https://i.loli.net/2020/02/09/6zetijN2WykparA.png" alt="">  </p>
<h2 id="map和multimap"><a href="#map和multimap" class="headerlink" title="map和multimap"></a>map和multimap</h2><p><code>map</code>和<code>multimap</code>的头文件都是<code>&lt;map&gt;</code>。<code>map</code>与<code>set</code>的不同在于<code>map</code>中只能存放对象，而且<code>map</code>中存放的元素有且仅有两个成员变量，一个为<code>first</code>，一个为<code>second</code>，<code>map</code>根据<code>first</code>的值对元素进行从小到大排序，并可快速的根据<code>first</code>来检索元素。<code>map</code>同<code>multimap</code>的不同在于是否允许相同<code>first</code>值的元素。示例代码如下：  </p>
<pre><code>template&lt;class Key,class Value&gt;
ostream &amp; operator&lt;&lt;(ostream &amp; o,const pair&lt;Key,Value&gt; &amp;p)
{
    o&lt;&lt;&quot;(&quot;&lt;&lt;p.first&lt;&lt;&quot;,&quot;&lt;&lt;p.second&lt;&lt;&quot;)&quot;;
    return o;
}
int main()
{
    typedef map&lt;int,double,less&lt;int&gt; &gt; mmid;
    mmid pairs;
    pairs.insert(make_pair(15,99.3));
    pairs.insert(mmid::value_type(20,20.5));
    mmid::iterator i;
    cout&lt;&lt;pairs.count(15)&lt;&lt;endl;
    cout&lt;&lt;pairs.count(10)&lt;&lt;endl;
    for(i=pairs.begin();i!=pairs.end();i++)
    {
        cout&lt;&lt; *i;
    }
    return 0;
}</code></pre><p>这里先介绍以下<code>pair</code>模板类，<code>pair</code>模板定义了两个公共成员变量，<code>first</code>和<code>second</code>，<code>map</code>和<code>multimap</code>容器里放着的都是<code>pair</code>模板类的对象。因此在输入数据的时候用<code>make_pair()</code>来输入，定义的<code>map</code>中第一个成员变量为<code>int</code>型，第二个为<code>double</code>型。输入了两组数据15 99.3和20 20.5，当查询15的数量时，看的是<code>first</code>的值，有一个。当查询10的数量时，没有。因为<code>map</code>中存放的是对象，而对象是不能直接输出的，所以重载了<code>&lt;&lt;</code>运算符，使得输出对象的<code>first</code>和<code>second</code>值。运行结果为：<br><img src="https://i.loli.net/2020/02/09/vCdkzUaDNOWuf1q.png" alt="">  </p>
<h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>容器适配器包括<code>stack</code>，<code>queue</code>，<code>priority_queue</code>3种。<code>stack</code>和<code>queue</code>基于<code>deque</code>实现，<code>priority_queue</code>基于<code>vector</code>实现。为什么叫容器适配器？举个例子，手机充电的时候需要电源适配器来把220v的交流电转换成较低电压的直流电以供手机充电使用，220v的电压太高了，我们不需要那么高的电压，而且高电压还有可能产生其他很多不良后果。基础的容器类型就相当于那220v的电压，经过适配器转换后才成为了我们需要的低电压（<code>stack</code>，<code>queue</code>，<code>priority_queue</code>）。你完全可以在<code>deque</code>上按照<code>stack</code>的方式工作，但是<code>deque</code>太强大了，它提供了远超过<code>stack</code>操作（<code>empty</code>, <code>size</code>,<code>pop</code>,<code>top</code>,<code>push</code>）所需的各种接口，你可以小心翼翼地在<code>deque</code>上只使用那几种操作来模拟一个栈，但是你很有可能一失误来个<code>push_front()</code>之类的操作，你小心翼翼模拟的栈就毁了。所以，我们需要适配器来做一下转换，只保留基础类型提供的接口中的一部分，保留的这部分操作对于你所需要的数据结构来说已经足够了。</p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><code>stack</code>即栈，头文件为<code>&lt;stack&gt;</code>。栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最近插入序列的项（栈顶的项）。栈是后进先出结构，Last in first out，简称LIFO。<br><img src="https://i.loli.net/2020/02/09/Xaqpeg9xKARtMTS.png" alt=""> </p>
<p>栈的成员函数有：<br>成员函数<code>push</code>：用于将一个新的整数插入到top<br>成员函数<code>pop</code>：用于移出top的整数<br>成员函数<code>empty</code>：用于判断是否为空<br>成员函数<code>top</code>：输出栈顶的整数<br>成员函数<code>size</code>：返回栈中元素的个数<br>示例代码如下：  </p>
<pre><code>int main()
{
    stack&lt;int&gt; s;
    cout&lt;&lt;s.empty()&lt;&lt;endl;
    s.push(3);s.push(2);s.push(5);s.push(1);s.push(4);
    cout&lt;&lt;s.empty()&lt;&lt;endl;
    cout&lt;&lt;s.size()&lt;&lt;endl;
    cout&lt;&lt;s.top()&lt;&lt;endl;
    s.pop();
    cout&lt;&lt;s.top();
    return 0;
}</code></pre><p>定义了一个空栈s，判断其是否为空，显然是空栈，所以会输出1。输入数据3 2 5 1 4，再判断栈是否为空，此时不为空，输出0，输出栈中元素的个数5，将栈顶的元素移去，次数栈中变为3 2 5 1，再输出栈顶的元素1。</p>
<h2 id="queue和priority-queue"><a href="#queue和priority-queue" class="headerlink" title="queue和priority_queue"></a>queue和priority_queue</h2><p><code>queue</code>和<code>priority_queue</code>表示的是队列和优先级队列，头文件都是<code>&lt;queue&gt;</code>。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。队列是先进先出的，First in first out，简称FIFO。优先级队列中最高优先级元素总是第一个出列，相当于对输入的数据进行了排序。<br><img src="https://i.loli.net/2020/02/09/gRUsCp3MmioBHvS.png" alt=""><br>示例代码如下：  </p>
<pre><code>int main()
{
    priority_queue&lt;double&gt; pq;
    pq.push(3.2);
    pq.push(9.8);
    pq.push(5.4);
    cout&lt;&lt;pq.top()&lt;&lt;endl;
    pq.pop();
    cout&lt;&lt;pq.top();
    return 0;
}</code></pre><p>定义了一个<code>double</code>型优先级队列pq，向队列输入数据3.2，9.8，5.4。因为是优先级队列，默认按从大到小的优先级排序。所以当输出队头时为9.8，这时候移去队头元素，再输出新的队头为5.4。结果如下：<br><img src="https://i.loli.net/2020/02/09/uLXciGyRxzp67Dq.png" alt="">  </p>
<p>至此就简单的介绍完了STL中容器的相关知识，在下一篇博客中将会开始进入到迭代器的学习，不同的容器有不同的迭代器，熟练掌握迭代器对于使用容器是非常重要的。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>标准模板库（STL)</title>
    <url>/2020/02/07/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%EF%BC%88STL%EF%BC%89/</url>
    <content><![CDATA[<p>摘要：本篇将开始进入到标准模板库（STL）的学习。STL是非常实用的模板库，我将会从标准模板库的概念、组成、应用等方面对其进行介绍。由于STL中的知识很多，因此本篇将会只介绍其中的一部分。</p>
<a id="more"></a>
<p>前面已经学习过模板的知识。而标准模板库（STL）就是一些常用数据结构和算法的模板的集合。STL由容器、算法和迭代器三部分组成。其中<br>容器：可容纳各种数据类型的通用数据结构，是类模板；<br>迭代器：可用于依次存取容器中元素，类似于指针；<br>算法：用来操作容器中的元素的函数模板。<br><strong>算法本身与他们操作的数据的类型无关，因此他们可以从简单数组到高度复杂容器的任何数据结构上使用</strong>。  </p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器包括三部分，顺序容器、关联容器和容器适配器。</p>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><p>顺序容器包括<code>vector</code>、<code>deque</code>、<code>list</code>三种。为什么叫顺序容器，因为容器并非是排好序的，元素的插入位置同元素的值无关，而是由元素的添加到容器中的次序决定的。<br><code>vector</code>表示的是动态数组，元素在内存连续存放，随机存取任何元素都能在常数时间完成。在尾端增删元素具有较佳的性能。<br><img src="https://i.loli.net/2020/02/07/cdN9ojTvuqCgEaP.png" alt=""><br>它的特点是在<strong>尾部</strong>添加速度很快，在中间插入慢。所有STL算法都能对<code>vector</code>操作。在以前的学习中，当我们定义数组时，必须要给定它的内存大小。然而很多情况下，我们是不知道数组的大小的，而且数组大小也会变化。在动态数组<code>vector</code>中，它的大小会自动变化，不需要我们再去设定。<br>构造函数初始化的成员函数有：<br><img src="https://i.loli.net/2020/02/07/AzSLRPmyqF5Iphc.png" alt=""><br>其他常见的成员函数有：<br><img src="https://i.loli.net/2020/02/07/OcPkAtCRiJxqEj4.png" alt=""><br>下面以简单的代码为例说明动态数组的用法：  </p>
<pre><code>int main()
{
    vector&lt;int&gt; v;
    v.push_back(2);
    v.push_back(0);
    v.push_back(2);
    v.push_back(0);
    v.push_back(5);
    v.pop_back();
    cout&lt;&lt;v.size()&lt;&lt;endl;
    for(int i=0;i&lt;v.size();i++)
    {
        cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>可以看到，创建一个空的int型动态数组v，依次向里面输入2、0、2、0、5，然后删除末尾元素5，返回容器中元素的个数，再依次将各个元素输出。  </p>
<p><code>deque</code>表示的是双向队列，元素在内存连续存放。随机存取任何元素都能在常数时间完成（但次于<code>vector</code>）。在<strong>两端增删元素</strong>具有较佳的性能。（大部分情况下是常数时间，但在需要重新增加内存时时间会增加，vector同理）。<br><img src="https://i.loli.net/2020/02/07/Dnz3vmBUWFSHOCh.png" alt=""><br>所有适用于<code>vector</code>上的操作，都适用于<code>deque</code>。除此之外，<code>deque</code>还有<code>push_front()</code>(将元素插入到队列的头部）和<code>pop_front()</code>（删除头部的元素）操作。  </p>
<p><code>list</code>即熟悉的双向链表，元素在内存不连续存放。因为是链表，所以不支持随机存取。但是在任何位置增删元素都能在时间常数完成。前面两个的迭代器是随机访问迭代器，而<code>list</code>的是双向迭代器。<br><img src="https://i.loli.net/2020/02/07/LWIPCDex7bHdVKt.png" alt=""><br><code>list</code>的成员函数有：<br><img src="https://i.loli.net/2020/02/07/EWhcaYkCbe4nxHm.png" alt=""><br>可以看到它的成员函数与前面的<code>vector</code>、<code>deque</code>还是有些区别的。其中第三个<code>sort()</code>函数是<code>list</code>自己定义的排序函数。举例代码如下：  </p>
<pre><code>int main()
{
    list&lt;int&gt; l1,l2;
    l1.push_back(1);l1.push_back(5);l1.push_back(3);
    l1.push_front(2);l1.push_front(4);
    l2.push_back(10);l2.push_back(20);l2.push_back(30);
    list&lt;int&gt;::iterator i;
    for(i=l1.begin();i!=l1.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    l1.sort();
    for(i=l1.begin();i!=l1.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    l1.merge(l2);
    l1.reverse();
    for(i=l1.begin();i!=l1.end();i++)
    {
        cout&lt;&lt;*i&lt;&lt;&quot; &quot;;
    }
    return 0;
}</code></pre><p>其中有关迭代器的知识会在接下来介绍，在这里只需将其当成指针即可。可见定义了两个链表l1和l2，<br>输入数据使l1变为1 5 3 2 4，l2变为10 20 30。将l1输出，然后调用<code>sort()</code>函数对l1进行排序并输出。将两个链表合并，再将其翻转输出。最后运行结果为：<br><img src="https://i.loli.net/2020/02/07/E28fB5buUdjcHGO.png" alt="">  </p>
<p>在本篇中讲解了标准模板库的概念以及容器中的顺序容器这一部分，在下篇中将会继续进入关联容器和容器适配器的学习。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>模板类之string类</title>
    <url>/2020/02/05/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B9%8Bstring%E7%B1%BB/</url>
    <content><![CDATA[<p>摘要：在数据结构里有一个部分为串（或字符串），它是非常常用的一个数据类型。C++中，string类对应的就是实现字符串相关的各种功能。通过对string类的学习，使得解决字符串有关问题时更加方便快捷。</p>
<a id="more"></a>
<p>上篇中已经学习过类模板有关的知识，在本篇将就string类举例进行介绍。<code>&lt;string&gt;</code>是C++标准程序库中的一个头文件，定义了C++标准中的字符串的基本模板类<code>std::basic_string</code>及相关的模板类实例。string是以char作为模板参数的模板类实例，把字符串的内存管理责任由string负责而不是由编程者负责，大大减轻了C语言风格的字符串的麻烦。<code>std::basic_string</code>提供了大量的字符串操作函数，如比较、连接、搜索、替换、获得子串等。并可与C语言风格字符串双向转换。<code>std::basic_string</code>属于C++ STL容器类，用户自定义的类也可以作为它的模板参数，因此也适用C++ STL Algorithm库。<br>string类的成员函数如下：<br><img src="https://i.loli.net/2020/02/05/nDozMjdgFTuX4Vy.png" alt=""><br>这里只介绍一些常用的成员函数。</p>
<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><p>按照以前所学的对类的对象赋值，string类的格式如下：  </p>
<pre><code>string s1(&quot;hello&quot;);</code></pre><p>即令字符串s1的内容为hello，但在string类里还有其他的赋值方式，比如：  </p>
<pre><code>string s1=&quot;hello&quot;;
string s2(8,&apos;x&apos;);</code></pre><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>如果要访问字符串中的字符，需要用到的成员函数为<code>at()</code>，例如逐个访问并输出string对象中的字符代码为：  </p>
<pre><code>for(int i=0;i&lt;s1.length();i++)
{
    cout&lt;&lt;s1.at(i)&lt;&lt;&quot; &quot;;
}</code></pre><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>用<code>+</code>运算符或者<code>append()</code>函数可以实现字符串之间的拼接。例如若将字符串s1和字符串s2拼在一起：  </p>
<pre><code>string s1,s2;
s1=&quot;hello&quot;;
s2=&quot; world&quot;;
s1=s1+s2; //用+运算符实现
s1.append(s2);  //用append函数</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>若要删除字符串中的某些字符，需要用到<code>erase()</code>函数，函数输入的参数为下标，表示去掉该下标及以后的字符。例如我们要使hello world字符串只剩下hello，则：  </p>
<pre><code>string s1=&quot;hello world&quot;;
s1.erase(5);</code></pre><p>需要说明的是该函数只能实现删除字符串后面一部分的功能。</p>
<h2 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h2><p>由上面所述，假如要求得到的不是hello而是world，这样不能用删除函数，应该怎么办？有一个成员函数名字为<code>substr()</code>，它的作用是得到字符串中的一部分，即子串。需要输入两个参数，第一个参数表示下标，第二个参数表示从该下标开始，你想要往后得到的字符个数。</p>
<pre><code>string s1=&quot;hello world&quot;;
s1.substr(6,5);</code></pre><p>这样就能得到子串world。</p>
<h2 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h2><p>若需要在字符串中找到需要的字符的位置，应该怎么办？这个问题是很常见的，需要用到的成员函数为<code>find()</code>，输入参数为想要查询的字符或字符串，返回结果为该字符或字符串在给定的字符串中第一次出现的位置。它是从前往后找的，第一次找到即返回。若要求从后往前找，则成员函数为<code>rfind()</code>。例如若要查到ll在hello world中第一次出现的位置：  </p>
<pre><code>string s1=&quot;hello world&quot;;
s1.find(&quot;ll&quot;);</code></pre><p>除此之外，<code>find_first_of(&quot;abc&quot;)</code>函数表示的是查找abc中任意一个字符第一次出现的位置。<code>find_first_not_of(&quot;abc&quot;)</code>表示的是查找不是abc这3个字符的其他字符第一次出现的位置。</p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>假如字符串中某些地方需要替换，这时候就需要用到成员函数<code>replace()</code>，例如将字符串heloo world变成hello world。</p>
<pre><code>string s1=&quot;heloo world&quot;;
s1.replace(3,1,&quot;l&quot;);</code></pre><p>表示的意思为将字符串s1中下标3开始后的一个字符替换为字符l。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>若要在字符串中插入字符则需要用到成员函数<code>insert()</code>，输入参数为插入位置的下标和要插入的字符。就用上面连接里面的例子：</p>
<pre><code>string s1,s2;
s1=&quot;hello&quot;;
s2=&quot; world&quot;;
s1.insert(5,s2);</code></pre><p>这样将s2插入到s1后面，实现了连接，当然也可以插入到中间和前面，由我们自己定义。</p>
<p>最后将上面所将的成员函数进行一下汇总，放在代码中为： </p>
<pre><code>#include&lt;string&gt;
using namespace std;
int main()
{
    string s1,s2;
    s1=&quot;Hell0 world&quot;;
    for(int i=0;i&lt;s1.length();i++)
    {
        cout&lt;&lt;s1.at(i)&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
    cout&lt;&lt;s1.find(&quot;ll&quot;)&lt;&lt;endl;
    s2=s1.substr(6,5);
    cout&lt;&lt;s2&lt;&lt;endl;
    cout&lt;&lt;s1.append(s2)&lt;&lt;endl;
    cout&lt;&lt;s1.erase(11,5)&lt;&lt;endl;
    cout&lt;&lt;s1.replace(6,5,&quot;ZPL&quot;)&lt;&lt;endl;
    cout&lt;&lt;s1.insert(9,&quot;HHH&quot;)&lt;&lt;endl;
    return 0; 
 } </code></pre><p>运行结果为：<br><img src="https://i.loli.net/2020/02/05/1jSoqHuXc2fEpNO.png" alt=""><br>string类是非常实用的一个模板类，掌握并能运用它的常用的成员函数是很有必要的。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>函数模板、类模板和模板类</title>
    <url>/2020/02/03/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E3%80%81%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB/</url>
    <content><![CDATA[<p>摘要：本篇将进入有关泛型编程相关知识的介绍，泛型程序设计可以减少很多重复的代码，而模板又是泛型编程的基础。通过函数模板、类模板和模板类的学习能够更好的了解泛型程序的概念，也为后面将要学习的标准模板库（STL）打下基础。</p>
<a id="more"></a>
<p>假如编写一个程序实现两个整数的交换，这是很简单的，定义一个中间变量，然后交换两个整数即可。现在要求对程序进行修改，使得既能实现整数的交换，又能实现小数的交换，那应该怎么办？是不是必须要对上面的交换函数进行重载，使得输入参数为小数也可以，若要求再实现字符的交换呢？能不能一个函数实现上面的所有要求，而不能根据每一个要求写一个函数？这就是泛型编程所要实现的，<strong>编写一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同</strong>。泛型即是指具有在多种数据类型上皆可操作的含义。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>模板是创建泛型类或函数的蓝图或公式。模板有类模板和函数模板。针对上面问题，可以用函数模板来解决。</p>
<pre><code>template&lt;class 类型参数1，class 类型参数2  ...&gt;
返回值类型 模板名（形参表）
{
    函数体
}</code></pre><p>其中类型参数是自定义的，比如实现上述要求的交换，只有一个类型参数，用T表示即可。具体实现代码如下：  </p>
<pre><code>template&lt;class T&gt;
void Swap(T&amp;x,T&amp;y)
{
    T tem;
    tem=x;
    x=y;
    y=tem;
 } 
 int main()
 {
     int a=2,b=3;
     Swap(a,b);
     cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;
     double c=2.1,d=3.1;
     Swap(c,d);
     cout&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;endl;
    string s1,s2;
     s1=&quot;hello&quot;;
     s2=&quot;world&quot;;
     Swap(s1,s2);
     cout&lt;&lt;s1&lt;&lt;&quot; &quot;&lt;&lt;s2&lt;&lt;endl;
     return 0;
 }</code></pre><p>可以看到上面利用一个函数模板就实现了多种数据结构的交换。这大大减少了重复代码的编写，提高程序效率。若有两个类型参数，只需要多定义一个即可，如下：  </p>
<pre><code>using namespace std;
print(int a,int b)
{
    cout&lt;&lt;&quot;普通函数优先级最高&quot;&lt;&lt;endl; 
}
template&lt;class T&gt;
void print(T a,T b)
{
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;    
}
template&lt;class T1,class T2&gt;
void print(T1 a,T2 b)
{
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl;    
}
int main()
{
    int x=1,y=2;
    double z1=3.1,z2=5.2;
    string s=&quot;hello&quot;;
    print(x,y);
    print(z1,z2);
    print(x,z1);
    print(s,x);
    return 0;
}</code></pre><p>由上面的代码可以看出，<strong>函数模板可以重载，只要他们的形参表不同即可</strong>。代码中重载了<code>print</code>函数，使它能实现同类型数据的打印和不同数据类型的打印。那么函数调用的顺序是什么样的呢？运行结果如下：<br><img src="https://i.loli.net/2020/02/03/aECSeydDQn3NPU9.png" alt=""><br>从结果也能看出，函数的调用顺序为：<br>1.普通函数<br>2.参数完全匹配的模板函数<br>3.实参经过类型转换后能够匹配的普通函数<br>若经过上面3个顺序还找不到则报错。  </p>
<h2 id="类模板和模板类"><a href="#类模板和模板类" class="headerlink" title="类模板和模板类"></a>类模板和模板类</h2><p>正如定义函数模板一样，也可以定义类模板。在定义类的时候给它一个或多个参数，这些参数表示不同的数据类型，在调用类模板时指定参数，由编译系统根据参数提供的数据类型自动产生相应的模板类。编译器由类模板生成类的过程叫做类模板的实例化。由实例化得到的类叫模板类。函数模板可以作为类模板成员。  </p>
<pre><code>template&lt;class T&gt;
class A
{
      public:
        T a,b;
      void change();
      template&lt;class T1&gt;
      void func(T1 t)
      {
          cout&lt;&lt;t&lt;&lt;endl;
       } 
};    
template&lt;class T&gt;
void A&lt;T&gt;::change()
{
    T &amp;x=a;
    T &amp;y=b;
    T tem;
    tem=x;
    x=y;
    y=tem;
}
int main()
{
    A&lt;double&gt;a;
    a.func(&apos;Z&apos;);
    a.a=3.2;
    a.b=5.1;
    a.change();
    cout&lt;&lt;a.a&lt;&lt;&quot; &quot;&lt;&lt;a.b&lt;&lt;endl;
    return 0;
}</code></pre><p>上面代码中定义了一个类模板A，它的成员中有一个函数模板，用来交换两个数，当在类模板外定义函数时，需要加上<code>template</code>。<strong>类模板使得类的实现不关注数据元素的具体类型，而只关注类所需要实现的功能</strong>。在主函数里，实例化了一个类模板的double对象，模板类a，然后定义它的成员变量。当需要进行整型的功能时，只需要改变类模板A的参数即可。<br>本篇讲的函数模板和类模板都是C++很重要的一部分，在下篇中将会讲解一下string类。string类就是一个模板类，它具有很广泛的应用。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>文件和流</title>
    <url>/2020/01/31/%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/</url>
    <content><![CDATA[<p>摘要：今天将介绍如何从文件读取流和写入流。需要用到的类有iostream和fstream，通过对文件流的学习能更清楚的理解C++是如何读取信息和写入信息的。</p>
<a id="more"></a>
<p>根据前面的学习，在编写代码的时候头文件里都包含了iostream标准库，它提供了cin和cout方法分别用于从标准输入读取流和向标准输出写入流。在C++标准库中，ifstream、ofstream和fstream三个类用于文件操作，统称为文件流类。它们之间的关系如下：<br><img src="https://i.loli.net/2020/01/31/8cfetyEaNqAUnF1.png" alt=""><br>ifstream、ofstream和iostream类由istream和ostream类派生而来，iostream类又派生出fstream类。这三个类的作用如下：<br><img src="https://i.loli.net/2020/01/31/JziZ4H9XpfOasVn.png" alt=""><br>要在C++中进行文件处理，必须在C++源代码文件中包含头文件iostream类和fstream类。  </p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream和fstream对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用ifstream对象。<br>下面是<code>open()</code>函数的标准语法，<code>open()</code>函数是fstream、ifstream和ofstream对象的一个成员。</p>
<pre><code>void open(const char *filename, ios::openmode mode);</code></pre><p><code>open()</code>成员函数的第一个参数为要打开的文件的名称和位置，第二个参数定义文件被打开的模式。例如定义一个用二进制写入的操作。代码为：  </p>
<pre><code>ofstream b;
b.open(&quot;test.out&quot;,ios::out|ios::binary);</code></pre><p>若是定义为读写：</p>
<pre><code>b.open(&quot;test.out&quot;,ios::out|ios::in);  </code></pre><p>同时需要判断是否打开文件成功：  </p>
<pre><code>if(!b){cerr&lt;&lt;”File open error!”&lt;&lt;endl;}</code></pre><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。下面是<code>close()</code>函数的标准语法，<code>close()</code>函数是fstream、ifstream和ofstream对象的一个成员。</p>
<pre><code>void close();</code></pre><h2 id="写入和读取"><a href="#写入和读取" class="headerlink" title="写入和读取"></a>写入和读取</h2><p>在写入和读取时我介绍一个函数，<code>freopen()</code>函数。这个函数是用于C++重定向标准输入输出。什么是重定向？所谓重定向输出，就是可以把原本只是输出在控制台的字符，输出到你指定的路径文件中。(输入类似，就是从指定的文件中读取，而不是读取在控制台中的输入。)重定向函数可以在任何时候开启、关闭。这样我们利用<code>freopen()</code>函数就可以实现对文件的写入和读取。用法如下：  </p>
<pre><code>freopen(&quot;文件名.in&quot;,&quot;r&quot;,stdin);
freopen(&quot;文件名.out&quot;,&quot;w&quot;,stdout);</code></pre><p>r表示读，w表示写。stdin是标准输入流，默认为键盘，<strong>重定向以后变成从文本读取数据</strong>；stdout是标准输出流，默认为屏幕，<strong>重定向以后变为向文本写入数据</strong>。举例如下：  </p>
<pre><code>#include&lt;iostream&gt;
#include&lt;fstream&gt;
using namespace std;
int main()
{
    int x=5,y=6,a,b;
    freopen(&quot;ceshi.txt&quot;,&quot;r&quot;,stdin);    
    cin&gt;&gt;a&gt;&gt;b;
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b;
    freopen(&quot;ceshi.txt&quot;,&quot;w&quot;,stdout);
    cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y;
    fclose(stdin);
    fclose(stdout);
    return 0; 
}</code></pre><p>建立一个名字为ceshi的txt文本，在里面预设两个数为1 2。当重定向以后从本文读取a、b然后输出,此时输出没有重定向因此显示在屏幕上为1 2，实现了从文件中读取的操作。再对输出重定向将x、y写入文本中，关闭文本。因此最终文本中的内容变为5 6。</p>
<p>本篇主要讲解了文件有关的操作和函数，在下篇博客中，将会进入C++的又一重要方面学习：泛型程序设计。将会了解到有关函数模板和类模板等等有关的内容，它们对于程序设计是非常有用的。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>虚析构函数、纯虚函数和抽象类</title>
    <url>/2020/01/28/%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p>摘要：本篇将会对上篇所讲得虚函数再做介绍，主要讲解了虚析构函数和纯虚函数的概念以及为什么要使用它们，通过虚析构函数的学习也能更好的理解内存泄漏的知识。而纯虚函数则能让我们更好的理解多态和使用多态。</p>
<a id="more"></a>
<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p>根据上篇博客中的知识可以明白虚析构函数就是将析构函数定义为虚函数，即在析构函数前面加上<code>virtual</code>关键字，那么为什么要将析构函数定义为虚析构函数呢？首先以下面代码为例：  </p>
<pre><code>class base                                //定义基类 
{
    public:
        int a;
        base(int i);
         ~base();
};
base::base(int i=0)
{
    a=i;
    cout&lt;&lt;&quot;基类构造函数&quot;&lt;&lt;endl;
}
base::~base()
{
    cout&lt;&lt;&quot;基类析构函数&quot;&lt;&lt;endl;
}
class derive:public base                    //定义派生类 
{
    public:
      int b;
      derive(int i=0,int j=0);
       ~derive();
};
derive::derive(int i,int j):base(i)
{
    b=j;
    cout&lt;&lt;&quot;派生类构造函数&quot;&lt;&lt;endl;
}
derive::~derive()
{
    cout&lt;&lt;&quot;派生类析构函数&quot;&lt;&lt;endl;
}
int main()
{ 
    base *p2;      
    p2=new derive;                 //基类指针 
    delete p2;                      //释放 
    return 0;
}</code></pre><p>猜一下上面代码运行的结果是什么？定义了一个基类指针，指向派生类对象，然后再用基类的指针删除派生类的对象。运行结果如下：<br><img src="https://i.loli.net/2020/01/28/pbCiPWYJXxGKTFe.png" alt=""><br>可以看到在删除派生类对象时，没有调用派生类的析构函数，只调用了基类的析构函数，这说明内存并没有完全释放。这是因为定义的是基类指针，当删除时只调用了基类里的析构函数。那该怎么解决这个问题？这就需要虚析构函数了。当我们修改上述代码，将基类和派生类的析构函数定义为虚析构函数时结果为：<br><img src="https://i.loli.net/2020/01/28/7uOWnfCpGPVQwvU.png" alt=""><br>这样就成功了对内存资源完全释放了。虚析构函数主要是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象这一情形的。<br>如果某个类不包含虚函数，那一般是表示它将不作为一个基类来使用。当一个类不准备作为基类使用时，使析构函数为虚一般是个坏主意。因为它会为类增加一个虚函数表，使得对象的体积翻倍，还有可能降低其可移植性。但是虚函数又是很重要的，因此我们常常定义为：当且仅当类里包含至少一个虚函数的时候去声明虚析构函数。</p>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>假如一个虚函数是没有函数体的，那么就叫它纯虚函数。纯虚函数是一种特殊的虚函数，为什么要定义纯虚函数呢？<br>举个例子，我们知道动物类可以作为一个基类派生出老虎类、狮子类等，但是动物类本身是不生成对象的。在很多情况下，基类本身生成对象是不合理的，但是我们又要使用多态这一特性，需要在基类里定义虚函数，而这些虚函数在基类中是没有意义的，它们的实现主要在派生类中进行。因此为了解决这种情况，我们在基类中把虚函数定义为纯虚函数。纯虚函数的定义格式为：<br><code>virtual &lt;类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)=0;</code><br>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。抽象类里的成员函数可以调用纯虚函数。以下面代码为例：  </p>
<pre><code>class base                                  //抽象类 
{
    public:
        int a;
        virtual void change()=0;            //纯虚函数 
        void print()
        {
            this-&gt;change();
        }
};
class derive:public base                 //派生类 
{
    public:
        int b;
        virtual void change();        
};
void derive::change()
{
    cout&lt;&lt;&quot;b=2&quot;;
}
int main()
{
    derive d;
    d.print();                  
    return 0;
}</code></pre><p>在代码中定义了一个基类，它有一个纯虚函数的成员函数，因此它是抽象类。抽象类派生出一个类，在派生类里对纯虚函数进行具体实现。同时抽象类还有一个成员函数<code>print()</code>，它的作用是调用对象的虚函数<code>change()</code>，这也是因为抽象类的成员函数可以调用纯虚函数。在主函数里我们创建了一个派生类对象，当它调用<code>print()</code>函数时，因为this指针指向的对象为派生类，因此调用的是派生类的虚函数<code>change()</code>，即输出结果为<code>b=2</code>。  </p>
<p>虚析构函数的作用是解决基类指针指向派生类对象删除时不完全的情况，纯虚函数和抽象类则更好的完善了基类和多态，这些特殊的虚函数都有着很大的作用，它们也使得程序变的更加准确可靠。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>虚函数和多态</title>
    <url>/2020/01/26/%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>摘要：多态，是面向对象的程序设计语言最核心的特征。多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法。多态是通过虚函数实现的，本篇博客将主要介绍虚函数和多态的概念、定义以及如何使用。</p>
<a id="more"></a>
<p>多态是继封装、继承之后，面向对象的第三大特性。现实事物经常会体现出多种形态，例如一个人叫张三，他是学生，但他也是人，因此他有两种形态学生（student）和人（person）。而学生类又可以是人类继承而来的。这种情形就叫做多态。  </p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>什么是虚函数？在类的定义中，前面有<code>virtual</code>关键字的成员函数就是虚函数。例如：  </p>
<pre><code>virtual int get();</code></pre><p><code>virtual</code>需要在声明时表现出来，但当对函数进行定义时可以省略。<strong>构造函数和静态成员函数不能是虚函数</strong>。这是因为若将构造函数定义为虚函数，在调用构造函数时直接可以确定它的类，而静态成员函数本质上是全局函数，只定义一次。虚函数能参与多态，普通函数不能。</p>
<h2 id="多态的表现形式之一"><a href="#多态的表现形式之一" class="headerlink" title="多态的表现形式之一"></a>多态的表现形式之一</h2><p>我们想要实现的是根据实际的对象类型决定函数调用的具体目标。派生类的指针可以赋给基类指针，当我们通过基类指针调用基类和派生类中的同名虚函数时：<br>1.若该指针指向一个基类的对象，那么被调用的是基类的虚函数。<br>2.若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。<br><strong>即调用哪个虚函数取决于指针指向哪种类型的对象。</strong></p>
<pre><code>derive d;
base *p=&amp;d;
p-&gt;somevirtualfunction();</code></pre><p>可以看到基类指针p指向派生类对象d，因此它调用的虚函数为派生类中的虚函数。</p>
<h2 id="多态的表现形式之二"><a href="#多态的表现形式之二" class="headerlink" title="多态的表现形式之二"></a>多态的表现形式之二</h2><p>前面已经讲过引用的概念。派生类对象同样可以赋给基类引用。通过基类引用调用同名虚函数时取决于引用的对象类型，这种也叫做多态。</p>
<pre><code>derive d;
base &amp;r=d;
r.somevirtualfunction();</code></pre><p>可以看到基类引用引用的对象类型为派生类的对象d，因此它调用的虚函数为派生类中的虚函数。<br>在基类的非构造、非析构函数的成员函数中调用虚函数，就是多态。相当于调用的时候省略了this指针，this是基类指针，指向的对象为主函数里定义的指针指向的对象。若是指向派生类对象，就跳转到派生类的虚函数里执行。</p>
<h2 id="多态实现原理"><a href="#多态实现原理" class="headerlink" title="多态实现原理"></a>多态实现原理</h2><p>前面说到多态时通过虚函数实现的，为什么虚函数能够实现多态呢？这是因为每一个有虚函数的类（或者它的派生类）都有一个虚函数表，该类的任何对象中都放着虚函数表的指针。若查看带有虚函数的类的内存大小，发现多出来4个字节，多出来的4个字节就是用来放虚函数表的地址的。有地址就可以调用虚函数。<br>我们对上篇博客中的代码做下扩充来讲述多态的具体实现：</p>
<pre><code>class base
{
    protected:
    int a;
    public:
    base(int i=0)
    {
        a=i;
        cout&lt;&lt;&quot;基类构造&quot;&lt;&lt;endl;
    } 
    ~base()
    {
        cout&lt;&lt;&quot;基类析构&quot;&lt;&lt;endl;
    }
    virtual int change();
};
int base::change()
{
    a=a+1;
    return a;
}
class derive:public base
{
    public:
        int b;
        derive(int i,int j);
        ~derive()
        {
           cout&lt;&lt;&quot;派生类析构&quot;&lt;&lt;endl;    
        }
        virtual int change();
};
derive::derive(int i,int j):base(i)
{
    b=j;
    cout&lt;&lt;&quot;派生类构造&quot;&lt;&lt;endl;
}
int derive::change()
{
    b=b+a;
    return b;
}
int main()
{
    base b(3);
    derive d(2,5);
    base *p=&amp;d;                     //基类指针指向派生类对象 
    base &amp;r=b;                                        //基类引用引用基类对象 
    cout&lt;&lt;b.change()&lt;&lt;endl;
    cout&lt;&lt;d.change()&lt;&lt;endl;
    cout&lt;&lt;p-&gt;change()&lt;&lt;endl;        //调用派生类的虚函数 
    cout&lt;&lt;r.change()&lt;&lt;endl;                          //调用基类的虚函数 
    return 0;
}</code></pre><p>可以看到，基类中虚函数的作用是加1，派生类中虚函数的作用是使两个数相加。在主函数里，定义了一个基类指针p指向派生类对象d，定义了一个基类引用引用基类对象b，这样指针p调用的是派生类的虚函数，引用调用的是基类的对象b，运行结果为:<br><img src="https://i.loli.net/2020/01/26/smyXV46wLrdTuce.png" alt="">  </p>
<h2 id="多态和重载"><a href="#多态和重载" class="headerlink" title="多态和重载"></a>多态和重载</h2><p>多态的概念很容易想到相似的重载。前面讲过函数重载的概念，重载也可以使得函数有不同的功能，但是多态和重载还是有很大区别的。<br>多态中用的是同名虚函数，函数名和函数参数都完全相同，通过指针指向或引用的对象类型判断需要执行的虚函数。而重载只是函数名相同，参数却不同，通过输入的参数个数或形式来判断调用的函数。重载中，编译器根据函数不同的参数表，对同名函数的名称做修饰。对于编译器而言，这些同名函数就成了不同的函数。它们的调用地址在编译期就绑定了。多态中，虚函数调用在编译期间是无法确定的。<br>不难看出，两者的区别在于编译器何时去寻找所要调用的具体函数，对于重载而言，在函数调用之前，编译器就已经确定了所要调用的函数，这称为“静态绑定”；而对于多态，只有等到函数调用的那一刻，编译器才会确定所要调用的具体函数，这称为“动态绑定”。  </p>
<p>上面就简单介绍了多态的概念，在下一篇博客中，将会对虚函数再进一步学习，学习虚函数中的虚析构函数、纯虚函数以及抽象类的概念。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>继承和派生</title>
    <url>/2020/01/24/%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F/</url>
    <content><![CDATA[<p>摘要：在前面已经讲了类的有关概念，而不同的类之间是有关系的。相关的关系有继承和复合关系等。在本篇中将会介绍以下继承和派生的相关概念。这也是面向对象中很重要的一个概念，通过继承和派生可以提高代码执行效率。</p>
<a id="more"></a>

<p>类并不是孤立的存在的，不同的类之间有着不同的关系，正如前面所讲过的友元类。假如已经定义了一个动物类，里面有动物的成员变量和成员函数，此时若要再定义一个哺乳动物类该怎么办？可以看出，哺乳动物属于动物，它也具有动物类的所有特性。因此只需要继承动物类即可。<br>继承：在定义一个新的类B时，如果该类与某个已有的类A相似（B拥有A的全部特点），那么就可以把A作为一个基类，而把B作为基类的一个派生类。派生类是通过对基类进行修改和扩充得到的。在派生类中，可以扩充新的成员变量和成员函数。派生类一经定义后，可以独立使用，不依赖于基类。继承代表了 is a 关系。<strong>派生类成员函数不能访问基类的私有成员</strong>。<br>根据上面的概念可知，派生类是由基类派生而来，因此基类的成员变量和成员函数在派生类也有。一般情况下，在派生类里的指的是派生类定义的成员，若要访问基类的（公共的）同名成员变量和成员函数，需要加上基类名，即<code>base::I</code>、<code>base::func()</code>。<br>派生类的定义格式为：<br><code>class 派生类名：public 基类名</code><br>这里的<code>public</code>也可以换为<code>protected</code>和<code>private</code>，它们表示了继承类型，但我们通常使用的都是<code>public</code>继承。一个基类可以派生出多个派生类。<br>前面讲过公有成员和私有成员，这里讲一下保护成员（protected）。它与私有成员不同的地方在于它可以被派生类的成员函数访问。其他访问方式与私有成员相同。  </p>
<h2 id="派生类构造函数"><a href="#派生类构造函数" class="headerlink" title="派生类构造函数"></a>派生类构造函数</h2><p>派生类的其他成员函数如前面所讲的定义即可，但构造函数略有不同，因为派生类是继承基类而来，所以在派生类的构造函数中要先去调用基类的构造函数。如果不调用基类构造函数，因为派生类成员函数不能调用基类私有成员，无法实现初始化。派生类的构造函数定义为：<br><code>派生类名（成员变量1，2，3...）：基类构造函数（成员变量1，2...）</code><br>成员变量1，2，3为形参名，以下面代码为例：</p>
<pre><code>class base
{
    private:
        int n;
    public:
        base(int i=0):n(i)
        {
            cout&lt;&lt;&quot;基类构造&quot;&lt;&lt;endl&lt;&lt;n&lt;&lt;endl;
        }
        ~base()
        {
            cout&lt;&lt;&quot;基类析构&quot;&lt;&lt;endl;
        }
        void print();
};
void base::print()
{
    cout&lt;&lt;n&lt;&lt;endl;
}
class derive:public base
{
    public:
        int a;
        derive(int i=0,int j=0);
        ~derive()
        {
            cout&lt;&lt;&quot;继承类析构&quot;&lt;&lt;endl;
        }
};
derive::derive(int i,int j):base(i)
{
    a=j;
    cout&lt;&lt;&quot;继承类构造&quot;&lt;&lt;endl&lt;&lt;a&lt;&lt;endl;
}
int main()
{
  derive b(2,1);
  b.print();
  return 0;
}</code></pre><p>可以看到，在代码的构造函数和析构函数中，都输出是属于哪个类的。在派生类的构造函数中，定义了两个形参i和j，第一形参i是基类构造函数中的参数，派生类新增加的成员变量a用形参j赋值，这样就实现了派生类的构造函数。而派生类也有基类的成员函数，因此派生类对象b可以调用<code>print()</code>函数输出。运行结果为:<br><img src="https://i.loli.net/2020/01/24/ABGCPKpOb9ZjNed.png" alt=""><br>在结果中我们也可以看到构造函数和析构函数的调用顺序，<strong>先构造的后析构，先基类构造再派生类构造</strong>。<br>假如我们定义基类对象为b，派生类对象为d：  </p>
<pre><code>base b;
derive d;</code></pre><p>1.派生类对象可以赋值给基类对象，即<code>b=d</code>。而反过来不行，这也是反映了前面所说的 is a 关系。<br>2.派生类对象可以初始化基类引用，即<code>base &amp;br=d</code>。<br>3.派生类对象的地址可以赋值给基类指针，即<code>base *pd=d</code>。  </p>
<h2 id="直接基类和间接基类"><a href="#直接基类和间接基类" class="headerlink" title="直接基类和间接基类"></a>直接基类和间接基类</h2><p>上面所讲一个类可以派生出多个类。而派生类也可以作为基类再派生。如动物类可以派生出哺乳动物类，而哺乳动物类又可以派生出人类。这样，动物类和哺乳动物类都是人类的基类。哺乳动物类是直接基类，动物类是间接基类。声明派生类时，只需列出它的直接基类。但是派生类的成员包括自己定义、直接基类、间接基类的所有成员。<br>上面介绍了继承和派生的概念，类与类之间可能是继承关系，但如果一个类的对象是另一个类的成员呢？这属于什么关系？以圆类为例，圆有两个重要的成员，圆心和半径。而圆心是一个点，它属于点类的一个对象。此时定义圆类和点类为复合关系，<strong>复合关系一般把大的类声明为另一个类的友元</strong>。<br>面向对象的三个特征：封装、继承、多态。在下篇中将会进入到多态的学习，多态使得C++变的非常灵活，大大提高效率，是非常重要的一部分。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/2020/01/21/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>摘要：上一篇博客当中已经讲了什么是运算符重载，并且介绍了加减乘除等运算符如何重载及它们的用法。在本篇博客当中将会继续就运算符重载进行深入介绍，主要有赋值运算符的重载、流插入和流提取运算符、自加自减运算符以及函数调用<code>（）</code>运算符的重载。</p>
<a id="more"></a>

<p>在众多的运算符当中，不是所有的都可以被重载，只有一部分可以，下面是可以被重载的运算符列表：<br><img src="https://i.loli.net/2020/01/21/kVxI5OW4FAGDiY3.png" alt=""><br>可以看到，上篇博客中讲的是双目算术运算符的重载，本篇将会讲解其他类型的运算符重载，比如赋值运算符等。不同的运算符重载具有不同的功能。</p>
<h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>在赋值运算符重载中，我将会讲解<code>=</code>这个运算符，从名字就可以看出来，重载的功能主要是赋值，但特殊的地方在于它两边的类型可以不匹配。例如将一个<code>int</code>类型变量赋值给一个<code>complex</code>对象，将一个<code>char*</code>类型的字符串赋值给一个字符串对象或者将一个对象赋值给另一个对象等。需要注意的一点是，赋值运算符<code>=</code>只能重载为成员函数。继续以上篇博客中的代码为例，添加赋值运算符<code>=</code>的重载代码如下：</p>
<pre><code>complex&amp; complex::operator=(const complex &amp;s3)
 {
     real=s3.real;
     image=s3.image;
     return *this;
 }</code></pre><p>主函数：</p>
<pre><code>int main()
{
    complex s1(2,3);
    complex s2(3,4);
    complex s3,s4;
    s3=s1+s2;
    s3.showcomplex();
    s4=s3-s2;
    s4.showcomplex();
    s4=s2;
    s4.showcomplex();
    return 0;
} </code></pre><p>运行结果为：<br><img src="https://i.loli.net/2020/01/21/qrTbeNRiX8tMdlx.png" alt=""><br>可见将对象s2成功赋值给了s4。若是想要将数据赋给对象只需要修改参数即可。</p>
<h2 id="流插入和流提取运算符重载"><a href="#流插入和流提取运算符重载" class="headerlink" title="流插入和流提取运算符重载"></a>流插入和流提取运算符重载</h2><p>在介绍这部分知识之前，先提出一个问题，为什么<code>cout&lt;&lt;5</code>、<code>cin&gt;&gt;a</code>能够成立，能够在编译器里运行？按照C语言当中学习的知识，我们想要输出一个东西时，会用<code>printf</code>关键字，要输入一个东西时，会用<code>scanf</code>关键字。在C++中为什么用<code>cout&lt;&lt;</code>、<code>cin&gt;&gt;</code>可以实现上述功能呢？<br><code>cout</code>是在<code>iostream</code>中定义的，<code>ostream</code>类的对象。<code>&lt;&lt;</code>能用在<code>cout</code>上是因为在<code>iostream</code>里对<code>&lt;&lt;</code>进行了重载。</p>
<pre><code>ostream&amp; ostream::operator&lt;&lt;(int n)
{
    ....//输出n的代码
    return *this;
}</code></pre><p>为什么返回值类型为<code>ostream&amp;</code>？这是因为这样可以实现连续输出，如<code>cout&lt;&lt;5&lt;&lt;4</code>。当然只有这个重载是不够的，因为这样只能实现输出数字，而<code>cout&lt;&lt;&quot;hello&quot;</code>是也成立的，因此还要有：</p>
<pre><code>ostream&amp; ostream::operator&lt;&lt;(const char* s)
{
    ....//输出s的代码
    return *this;
}</code></pre><p>等等适用于各种情况的代码。当然我们自己也是可以继续对<code>&lt;&lt;</code>进行重载的，使得它能够满足我们输出的需要。</p>
<h2 id="自加自减运算符的重载"><a href="#自加自减运算符的重载" class="headerlink" title="自加自减运算符的重载"></a>自加自减运算符的重载</h2><p>递增运算符<code>++</code>和递减运算符<code>--</code>是C++语言中两个重要的一元运算符。它们有前缀和后缀两种用法。继续上面的例子，演示如何使用递增运算符重载。</p>
<pre><code>complex&amp; complex::operator++()
 {
     real=real+1;
     return *this;
 }</code></pre><p>我重载<code>++</code>运算符的作用为使复数的实部加1。仔细观察代码，我们可以发现与其他运算符的重载不同，因为不涉及其他对象，所以无参数。当重载为后缀的时候有一个参数，但是是无意义的，只是用来说明为后缀运算符而已。</p>
<h2 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h2><p>函数调用运算符<code>()</code>可以被重载用于类的对象。如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。继续以上面代码为例：</p>
<pre><code>complex&amp; complex::operator()(int a,int b,int c)
 {
     real=a+b+c;
     image=a-b-c;
     return *this;
 }</code></pre><p>主函数里：</p>
<pre><code>s4=s4(3,2,1);
s4.showcomplex();</code></pre><p>输出结果为：<br><img src="https://i.loli.net/2020/01/21/TvjEFWsxKgYHlbV.png" alt=""><br>可以看到，以调用函数的方式调用了对象，调用对象实际上是在运行重载的调用运算符。函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。如果类定义了调用运算符，则该类的对象称作函数对象。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。在后面会讲到有关函数对象的知识。  </p>
<p>还有很多的运算符可以进行重载，它们的功能也各不相同，在此就不一一介绍，运算符重载是很重要的一个部分，对程序的编写有很大帮助。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>类及类的成员3</title>
    <url>/2020/01/19/%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%983/</url>
    <content><![CDATA[<p>摘要：本篇博客中将主要介绍this指针、常量对象及常量成员函数、运算符重载方面的知识。其中运算符重载是应用很广泛的，也是C++中很重要的一个知识，对运算符重载进行掌握是很有必要的。</p>
<a id="more"></a>

<p>C++是从C发展而来的，而在C语言中是没有类的概念的，C语言中的函数都是全局函数，C++中则有成员函数，所以问题来了，成员函数在C中该如何表达？C中用<code>struct</code>结构体可以将类表示出来，而成员函数则需要借助this指针。</p>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>this指针指向了成员函数作用的对象，在成员函数执行的过程中，正是通过this指针才能找到对象所在的地址，因而也就能找到对象的所有非静态成员变量的地址。<br>C++ 规定，在非静态成员函数内部可以直接使用<code>this</code>关键字，<code>this</code>就代表指向该函数所作用的对象的指针。我们以下面运算符重载的代码中的一部分为例：</p>
<pre><code>complex&amp; complex::operator+(const complex &amp;s1)
{
    real=real+s1.real;
    image=image+s1.image;
    return *this ;
 } </code></pre><p>return应该返回的是函数的返回值类型<code>complex&amp;</code>，所以此时this指针指向的对象就是<code>complex</code>的一个对象的引用（返回对象同理）。这里的<code>this-&gt;real</code>和<code>real</code>是等价的。</p>
<h2 id="常量对象和常量成员函数"><a href="#常量对象和常量成员函数" class="headerlink" title="常量对象和常量成员函数"></a>常量对象和常量成员函数</h2><p>假如不希望某些东西被修改，可以使用<code>const</code>关键字进行限定。C++中，<code>const</code>可以用来修饰对象、成员变量和成员函数。<br>在类的成员函数说明后面加<code>const</code>，const成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const成员函数也称为常量成员函数。需要强调的是，必须在成员函数的声明和定义处同时加上<code>const</code>关键字。</p>
<pre><code>class sample
{
    public:
        int value;
        void getvalue() const;    
};
void sample::getvalue() const
{
    value=0;  //出错，不能改变变量的值 
}</code></pre><p><code>const</code>的位置不同，表示的含义也不同，函数开头的<code>const</code>用来修饰函数的返回值，表示返回值是<code>const</code>类型，也就是不能被修改。函数头部的结尾加上<code>const</code>表示常量成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值。<br>定义对象时同样可以定义为常量对象，这样对象初始化以后就不会再改变。<br>常量成员变量就和普通的const变量相似。</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>前面我们已经学过函数重载的概念，一个类中可以有多个构造函数，它们也是通过重载实现的。函数重载可以让一个函数有多种功能，在不同情况下实现不同的操作。运算符重载也是相同的道理，使运算符具有不同的功能。<br>C++本身已经对运算符进行了重载，比如我们进行<code>int</code>型数据相加时，直接调用加号就行。但是当我们使两个对象相加时，该怎么办呢？例如我们定义了复数类的两个对象，使它们相加，只用加号是无法实现的。这时候就需要我们自己对运算符重载，使得复数的实部和实部相加，虚部和虚部相加。<br>运算符重载可以重载为成员函数，普通函数和友元函数。声明格式一般为：</p>
<p><code>返回值类型 operator 运算符 (形参表)</code><br>以下面的代码为例，可知运算符重载的方法和作用：</p>
<pre><code>class complex
{
    public:
        int real,image;
        complex(int,int);
        ~complex();
        complex&amp; operator+(const complex&amp;);
        complex&amp; operator-(const complex&amp;);
        void showcomplex();
};
complex::complex(int a=0,int b=0)
{
    real=a;
    image=b;
}
complex::~complex()
{
}
complex&amp; complex::operator+(const complex &amp;s1)
{
    real=real+s1.real;
    image=image+s1.image;
    return *this ;
 } 
 complex&amp; complex::operator-(const complex &amp;s2)
 {
     real=real-s2.real;
     image=image-s2.image;
     return *this;
 }
 void complex::showcomplex()
 {
     cout&lt;&lt;real&lt;&lt;&quot;+j&quot;&lt;&lt;image&lt;&lt;endl;
 }
int main()
{
    complex s1(2,3);
    complex s2(3,4);
    complex s3,s4;
    s3=s1+s2;
    s3.showcomplex();
    s4=s3-s2;
    s4.showcomplex();
    return 0;
} </code></pre><p>代码的运行结果为:<br><img src="https://i.loli.net/2020/01/19/Y2ki3ZNgez7ElKX.png" alt=""><br>可见通过运算符重载，实现了复数类对象的运算。上面讲的只是简单的加减乘除运算符的重载。在下篇博客里，将会针对运算符重载深入研究，讲解赋值运算符、流插入和流提取运算符等其他运算符重载的用法。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>类及类的成员2</title>
    <url>/2020/01/15/%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%982/</url>
    <content><![CDATA[<p>摘要：本篇博客接着上一篇的向下学习，将对静态成员、成员对象和封闭类、友元以及this指针进行介绍并说明它们的用法。</p>
<a id="more"></a>

<p>在上一篇中已经讲过了类的概念，知道类包括成员变量和成员函数两部分，而在C的知识学习中，也学习过静态变量这一概念。同样的，当在定义类时，根据需求的不同，我们可以定义为静态成员变量和静态成员函数。</p>
<h2 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h2><p>静态成员的关键字为<code>static</code>，静态成员变量就是在定义时前面加了 <code>static</code>关键字的成员变量；静态成员函数就是在声明时前面加了<code>static</code>关键字的成员函数。<br>普通成员变量为每个对象有各自的一份，而静态成员变量一共就一份，为所有对象共享。普通成员函数必须作用于某个对象(例如在上一篇时钟代码中的设置时间函数，访问方式为<code>r.settime()</code>)，而静态成员函数并不具体作用于某个对象。因此静态成员不需要通过对象就能访问，可以直接<code>clock::settime()</code>访问，通过类名而不需要通过对象。它的本质上是全局变量和全局函数，<strong>因此必须在定义类的文件中静态成员变量进行一次声明，否则不行</strong>。静态成员函数内部不能访问非静态成员变量，设置静态成员的目的，是为了将和某些类紧密相关的全局变量和全局函数写到类里面，形式上成为一个整体。</p>
<h2 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h2><p>成员对象指的是一个类的成员变量是另一个类的对象。包含成员对象的类叫封闭类。比如封闭类汽车的成员变量有类轮胎的一个实例化对象和类引擎的一个实例化对象，这两个成员对象。封闭类需要自定义构造函数，不能再用默认构造函数，因为有些成员对象无法默认初始化。在定义封闭类的构造函数时，添加初始化列表：</p>
<p><code>类名：：构造函数（参数表）：成员变量1（参数表），成员变量2（参数表）,…{     }</code></p>
<p>当封闭类对象生成时，先执行所有成员对象的构造函数，再执行封闭类的构造函数。成员对象的构造函数调用顺序和成员对象在类中的声明顺序一致与在初始化列表中出现的顺序无关。当封闭类的对象消亡时，先执行封闭类的析构函数，再执行成员对象的析构函数。析构函数调用顺序和构造函数调用顺序相反。</p>
<pre><code>class Engine
{
    private:
        int price;
    public:
        Engine(int p)
       {
           price = p;
           cout &lt;&lt; &quot;Engine constructor is called&quot; &lt;&lt; endl;
        }
        ~Engine()
        {
            cout &lt;&lt; &quot;Engine deconstructor is called&quot; &lt;&lt; endl;
        }
};
class tyer
{
    private :
        int width, length;
    public:
        tyer(int w, int l) :width(w), length(l)
        {
            cout &lt;&lt; &quot;tyer constructor is called&quot; &lt;&lt; endl;
        };
        ~tyer()
        {
            cout &lt;&lt; &quot;tyer destructor is called&quot; &lt;&lt; endl;
        }
};
class car
{
    private :
        tyer ty;
        Engine en;
        int color;
    public:
        car(int col, int p, int w, int l);
        ~car()
        {
            cout &lt;&lt; &quot;car deconstructor is called&quot; &lt;&lt; endl;
        }
};
car::car(int col, int p, int w, int l) :color(col), en(p), ty(w, l)
{
    cout &lt;&lt; &quot;car constructor is called&quot; &lt;&lt; endl;
}
int main()
{
    car car1(2, 1, 4, 5);
    return 0;
}</code></pre><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在C++中，一个类中可以有<code>public、protected、private</code>三种属性的成员，通过对象可以访问<code>public</code>成员，只有本类中的函数可以访问本类的 <code>private</code>成员。现在，我们来介绍一种例外情况——友元（<code>friend</code>）。借助友元（<code>friend</code>），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的<code>private</code>成员。就相当于我是你的朋友，有些你的东西我也可以借用。<br>友元包括友元函数和友元类。一个类的友元函数可以访问该类的私有成员。若A是B的友元类，则A的所有成员函数都可以访问B的私有成员。</p>
<pre><code>class A
{
    private:
        int a;
    public:
        A(int);
        void show();
        friend void add(A); 
 } ;
 A::A(int b)
 {
     a=b;
 }
 void A::show()
 {
     cout&lt;&lt;a;
 }
 void add(A A1)
 {
     int b;
     b=A1.a+1;
     cout&lt;&lt;b&lt;&lt;endl;
 }
 int main()
 {
     A A1(4);
     add(A1);
     A1.show();
     return 0;
 }</code></pre><p>如上面代码所示，我定义了一个类A，又定义了一个友元函数<code>add()</code>，使得它可以访问A的私有成员。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>类及类的成员1</title>
    <url>/2020/01/13/%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%981/</url>
    <content><![CDATA[<p>摘要：在本篇博客里主要讲了C++的一些基础知识，主要有类的概念、类的成员、构造函数和析构函数等。并用代码举例说明构造函数和析构函数的调用顺序。</p>
<a id="more"></a>

<p>C++是完全包容C的，它与C的不同之处在于C++是面向对象的语言，而C是面向过程的。什么是面向过程？即分析出实现需求所需要的步骤，通过函数一步步实现这些步骤，依次调用函数即可。什么是面向对象？我们将繁琐的步骤，通过行为、功能模块化。创建了对象这一概念。而要体现面向对象这一思想，类是很关键的一个部分。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>将一类事物的共同特性抽象出来，包括了数据结构和算法，数据结构表示了共同属性，算法即函数表示了它们的行为。将它们封装构成了一个类。这有点类似于C语言中的<code>struct</code>结构，但是又是不一样的，<code>struct</code>只包括了数据结构即成员变量，而类还包含了成员函数。</p>
<h3 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h3><p>类的成员包括成员变量和成员函数。成员又包括私有成员和公共成员。私有成员只能通过成员函数内部访问，但是不能在该类之外通过其他函数对私有成员进行访问。公共成员都可以进行访问。<br>一般在类中只定义成员变量和成员函数以及它们的类型（公共还是私有），数据一般定义为私有，函数定义为公共的。<br>创建类的关键字为<code>class</code>或<code>struct</code>,<code>class</code>中未说明的成员类型为私有，<code>struct</code>中未说明的成员类型为公共。</p>
<pre><code>class student
{
    string sname;
    public:
    void showname();
}</code></pre><p>如上面代码所示，我们定义了函数<code>showname()</code>为公共类型，而对数据变量<code>sname</code>并没有说明，此时默认它是私有的，只能由内部的成员函数访问。而在<code>struct</code>中则正好相反，未说明则为公共的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>在类的成员函数中，首先就要先学习构造函数。构造函数用于当类创建一个对象时，对该对象进行初始化。构造函数是没有返回值类型的。如果不自定义构造函数，编译器生成一个默认构造函数（无参数）。它不做任何操作，无作用。</p>
<pre><code>class clock
{
    public:
     clock(int newh,int newm,int news);
     void settime(int newh,int newm,int news);
     void showtime();
    private:
     int hour,minute,second;
};
clock::clock(int newh,int newm,int news)
{
    hour=newh;
    minute=newm;
    second=news;
}
void clock::settime(int newh,int newm,int news)
{
    hour=newh;
    minute=newm;
    second=news;
}
void clock::showtime()
{
    cout&lt;&lt;hour&lt;&lt;&quot;:&quot;&lt;&lt;minute&lt;&lt;&quot;:&quot;&lt;&lt;second;
}
int main()
{
    int a,b,c;
    clock r(0,0,0);
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
    r.settime(a,b,c);
    r.showtime();
    return 0;
}</code></pre><p>在上面所示的代码中，我定义了一个时钟类，构造函数传入了3个参数，用于初始化时间。成员变量为时、分、秒，定义为私有的，成员函数有构造函数、设置时间函数、显示时间函数，定义为公共的，这样我们对其调用。<br><strong>一个类里可以有多个构造函数，根据需求自定义和调用</strong>。复制构造函数是一种特殊的构造函数，它由编译器调用来完成一些基于同一类的其他对象的构建及初始化。例如在上面的代码中，如果我们再创建一个clock对象r1，就可以调用默认的复制构造函数，使它与r相同：</p>
<pre><code>clock r1(r);</code></pre><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>名字与类名相同，但在前面多了一个~符号，没有返回值类型。<strong>一个类只能有一个析构函数，且没有参数</strong>。若定义类时不写析构函数，则编译器生成缺省析构函数。当对数组进行析构函数定义时，数组的每个元素都会调用一次析构函数，构造函数同理。先被构造的函数最后被释放，每生成一个对象的同时必会调用构造函数，在作用域结束时会调用析构函数。</p>
<pre><code>class student
{
    public:
        student();
        ~student();
        void setnameage(string,int);
        void showname();
        void showage();
    private:    
        int age;
        string s;
};
student::student()
{
    cout&lt;&lt;&quot;构造函数调用了&quot;&lt;&lt;endl;
}
student::~student()
{
    cout&lt;&lt;&quot;析构函数调用了&quot;&lt;&lt;endl;
}
void student::setnameage(string ss,int newage)
{
    s=ss;
    age=newage;
}
void student::showname()
{
    cout&lt;&lt;s&lt;&lt;endl;
}
void student::showage()
{
    cout&lt;&lt;age&lt;&lt;endl;
}
int main()
{
    string s;
    int a;
    student s1;
    cin&gt;&gt;s&gt;&gt;a;
    s1.setnameage(s,a);
    s1.showname();
    s1.showage();
    return 0;
}</code></pre><p>上面代码的运行结果如下：<br><img src="https://i.loli.net/2020/01/13/RfKcNU1atTCdPnG.png" alt=""></p>
<p>由结果可知，当创建了对象s1的那一刻，就已经调用了构造函数，然后才是输入，输出，当运行到<code>return 0</code>时，对象s1消失，因此调用了析构函数，程序结束。</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>C语言知识强化</title>
    <url>/2020/01/11/C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E5%BC%BA%E5%8C%96/</url>
    <content><![CDATA[<p>摘要：对已经学习过的C语言知识中一些比较特殊的地方进行强化记忆，主要有强制转换、全局变量、指针函数和函数指针、静态局部变量以及结构体等方面。</p>
<a id="more"></a>

<p>在本篇博客里我将会对C语言中的一些知识进行再次介绍，这些知识对以后的学习也很有帮助。</p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>C语言中的强制转换即在变量前面用括号声明你想要转换成的类型，这种方法简单实用，但是却无法说明转换的安全性。举例如下（将float类型的变量c转换为int型）：</p>
<pre><code>float c=2.5;
cout&lt;&lt;(int)c;</code></pre><p>这种情况下输出的值为2，也可以看出在编译器里不是四舍五入的。前面提到过转换的安全性，即强制类型转换是有风险的不是想转换就能随便转换的，在后面C++知识的学习中，将会有一节专门讲强制类型转换，依靠<code>static_cast</code>、<code>interpret_cast</code>、<code>const_cast</code>、 <code>dynamic_cast</code>四种，它们比C语言的这种更加安全和功能具体。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>变量分为局部与全局，局部变量又可称之为内部变量。由某对象或某个函数所创建的变量通常都是局部变量，只能被内部引用，而无法被其它对象或函数引用。<br>全局变量既可以是某对象函数创建，也可以是在本程序任何地方创建。全局变量是可以被本程序所有对象或函数引用。只有定义为全局变量，void子函数作用的值才会传递到main函数里。定义完全局变量后，函数里就不再定义。</p>
<pre><code>void exchange(int m,int n)
{
    int p=0;
    p=m;m=n;n=p;
}
int main()
{
    int a,b;
    cin&gt;&gt;a&gt;&gt;b;
    exchange(a,b);
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b;
    return 0;
}</code></pre><p>在上面的例子中，a、b的值并不会被交换，这是因为a、b并没有真的被传递到exchange函数中，且函数并没有返回值，也不会改变主函数中的a、b。如果我们定义a、b为全局变量，如下则可实现功能：</p>
<pre><code>int a,b;
void exchange()
{
    int p=0;
    p=a;a=b;b=p;
}
int main()
{
    cin&gt;&gt;a&gt;&gt;b;
    exchange();
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b;
    return 0;
}</code></pre><p>这时，主函数以及exchange函数中的a、b都为全局变量定义的a、b，会随之改变。需要强调的一点是，当一个变量既是局部变量又是全局变量时，局部变量会屏蔽作用范围的全局变量。由于在C++中引入了类的概念，变量被封装在类中，对别的类不可见，相当于抛弃了全局变量。</p>
<h2 id="指针函数和函数指针"><a href="#指针函数和函数指针" class="headerlink" title="指针函数和函数指针"></a>指针函数和函数指针</h2><p>指针是指向变量的地址。指针一般与数组用在一起。数组名也相当于指向数组第一个元素的指针，但是它不能被改变。指针函数的意思是函数传入的参数为指针变量。如<code>void change(int *p)</code>，当我们调用指针函数时直接把指针当参数输入即可<code>change(p)</code>。函数指针指的是一个函数它的返回值是指针类型的。即<code>int *p(int x,int y)</code>。下面是一个指针函数的例子，与上面的比较可知，它能避免定义全局变量的同时使交换起作用：</p>
<pre><code>void change(int *q1,int *q2)
{
    int temp;
    temp=*q1;
    *q1=*q2;
    *q2=temp;
}
int main()
{
    int a,b,*p1,*p2;
    cin&gt;&gt;a&gt;&gt;b;
    p1=&amp;a;
    p2=&amp;b;
    change(p1,p2);
    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b;
    return 0;
 } </code></pre><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><p>静态局部变量的关键字为<code>static</code>，静态局部变量在函数里定义，但是它跟局部变量不同，局部变量会随着函数的结束而释放，当静态局部变量不会，它只定义一次，而且不会被重新赋值和消失直到整个程序结束。</p>
<pre><code>void a()
{
    int a=0;
    static int b=0;
    a=a+1;
    b=b+1;
    cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl;
}
int main()
{
    int i=0;
    for(i=0;i&lt;4;i++)
    {
        a();
    }
    return 0;
}</code></pre><p>a的输出结果为1、1、1、1，b的输出结果为1、2、3、4。产生这种差别的原因就是a不是静态局部变量，当a函数结束，a也消失，而b不会消失，依然保持着自己的值。当再次调用a函数时，a重新被赋值为0，但b却不在赋值，它只会在第一次调用时赋值一次，因此b随着循环每次加1，而a总是变成0再加1。</p>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>结构体的关键字是<code>struct</code>，需要注意的是在C++中也有这个关键字，但是不再表示结构体，而是类，会在以后的学习中介绍。C语言中的结构体主要是把多个有关系的变量写在一个结构里，便于调用和赋值。如下所示：    </p>
<pre><code>struct student
{ 
    int id-num;
    Int name[10];
}; </code></pre><p>定义了一个学生的结构体，其中有学生的名字和学号，当调用时：</p>
<pre><code>student  mike；  
mike.id-num=123;
mike.name[10]=mike;</code></pre><p>C语言中还有很多的知识和技巧，这里就不再一一列述。在接下来会进入到C++基础知识的学习。加油！</p>
]]></content>
      <categories>
        <category>C++知识学习</category>
      </categories>
  </entry>
  <entry>
    <title>博客初识</title>
    <url>/2020/01/10/%E5%8D%9A%E5%AE%A2%E5%88%9D%E5%A7%8B/</url>
    <content><![CDATA[<p>开始尝试写博客啦</p>
<a id="more"></a>

<h2 id="很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced-road-，希望我的水平不断提高。"><a href="#很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced-road-，希望我的水平不断提高。" class="headerlink" title="很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced road)，希望我的水平不断提高。"></a>很开心成功搭建了博客并开始初次尝试写博客，我会将已经学习过、正在学习和即将要学习的东西都整理记录在博客上。我把签名改为进阶之路（Advanced road)，希望我的水平不断提高。</h2><pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;&quot;Hello,world!&quot;;
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/01/09/hello-world/</url>
    <content><![CDATA[<p>Welcome!</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
